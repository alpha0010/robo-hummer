/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ({

/***/ 52:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(53);
module.exports = __webpack_require__(55);


/***/ }),

/***/ 53:
/***/ (function(module, exports, __webpack_require__) {

eval("var Reveal = __webpack_require__(54);\n\nReveal.addKeyBinding({ keyCode: 68, key: 'D', description: 'Toggle Dynamic Presentation Options' }, function () {\n  window.toggleDynamicOptions();\n});\nReveal.addKeyBinding({ keyCode: 77, key: 'M', description: 'Play/Stop audio' }, function () {\n  window.playPauseAudio();\n});\n\nReveal.initialize({\n  controlsTutorial: false,\n  // TODO: use linear navigationMode when that feature is added to reveal.js.\n  // 'navigationMode': 'linear',\n  transition: 'none'\n});\n\nfunction playPauseAudio() {\n  var audio = document.getElementById('audio');\n  if (audio.paused) {\n    audio.currentTime = 0;\n    audio.play();\n  } else {\n    audio.pause();\n  }\n}\n\nwindow.playPauseAudio = playPauseAudio;\nwindow.Reveal = Reveal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2xpZGVzLmpzPzYzZGMiXSwibmFtZXMiOlsiUmV2ZWFsIiwicmVxdWlyZSIsImFkZEtleUJpbmRpbmciLCJrZXlDb2RlIiwia2V5IiwiZGVzY3JpcHRpb24iLCJ3aW5kb3ciLCJ0b2dnbGVEeW5hbWljT3B0aW9ucyIsInBsYXlQYXVzZUF1ZGlvIiwiaW5pdGlhbGl6ZSIsImNvbnRyb2xzVHV0b3JpYWwiLCJ0cmFuc2l0aW9uIiwiYXVkaW8iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicGF1c2VkIiwiY3VycmVudFRpbWUiLCJwbGF5IiwicGF1c2UiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDLEVBQVIsQ0FBYjs7QUFFQUQsT0FBT0UsYUFBUCxDQUNFLEVBQUVDLFNBQVMsRUFBWCxFQUFlQyxLQUFLLEdBQXBCLEVBQXlCQyxhQUFhLHFDQUF0QyxFQURGLEVBRUUsWUFBWTtBQUNWQyxTQUFPQyxvQkFBUDtBQUNELENBSkg7QUFNQVAsT0FBT0UsYUFBUCxDQUNFLEVBQUVDLFNBQVMsRUFBWCxFQUFlQyxLQUFLLEdBQXBCLEVBQXlCQyxhQUFhLGlCQUF0QyxFQURGLEVBRUUsWUFBWTtBQUNWQyxTQUFPRSxjQUFQO0FBQ0QsQ0FKSDs7QUFPQVIsT0FBT1MsVUFBUCxDQUFrQjtBQUNoQkMsb0JBQWtCLEtBREY7QUFFaEI7QUFDQTtBQUNBQyxjQUFZO0FBSkksQ0FBbEI7O0FBT0EsU0FBU0gsY0FBVCxHQUEyQjtBQUN6QixNQUFJSSxRQUFRQyxTQUFTQyxjQUFULENBQXdCLE9BQXhCLENBQVo7QUFDQSxNQUFJRixNQUFNRyxNQUFWLEVBQWtCO0FBQ2hCSCxVQUFNSSxXQUFOLEdBQW9CLENBQXBCO0FBQ0FKLFVBQU1LLElBQU47QUFDRCxHQUhELE1BR087QUFDTEwsVUFBTU0sS0FBTjtBQUNEO0FBQ0Y7O0FBRURaLE9BQU9FLGNBQVAsR0FBd0JBLGNBQXhCO0FBQ0FGLE9BQU9OLE1BQVAsR0FBZ0JBLE1BQWhCIiwiZmlsZSI6IjUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFJldmVhbCA9IHJlcXVpcmUoJ3JldmVhbC5qcycpO1xuXG5SZXZlYWwuYWRkS2V5QmluZGluZyhcbiAgeyBrZXlDb2RlOiA2OCwga2V5OiAnRCcsIGRlc2NyaXB0aW9uOiAnVG9nZ2xlIER5bmFtaWMgUHJlc2VudGF0aW9uIE9wdGlvbnMnIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cudG9nZ2xlRHluYW1pY09wdGlvbnMoKTtcbiAgfVxuKTtcblJldmVhbC5hZGRLZXlCaW5kaW5nKFxuICB7IGtleUNvZGU6IDc3LCBrZXk6ICdNJywgZGVzY3JpcHRpb246ICdQbGF5L1N0b3AgYXVkaW8nIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucGxheVBhdXNlQXVkaW8oKTtcbiAgfVxuKTtcblxuUmV2ZWFsLmluaXRpYWxpemUoe1xuICBjb250cm9sc1R1dG9yaWFsOiBmYWxzZSxcbiAgLy8gVE9ETzogdXNlIGxpbmVhciBuYXZpZ2F0aW9uTW9kZSB3aGVuIHRoYXQgZmVhdHVyZSBpcyBhZGRlZCB0byByZXZlYWwuanMuXG4gIC8vICduYXZpZ2F0aW9uTW9kZSc6ICdsaW5lYXInLFxuICB0cmFuc2l0aW9uOiAnbm9uZSdcbn0pO1xuXG5mdW5jdGlvbiBwbGF5UGF1c2VBdWRpbyAoKSB7XG4gIHZhciBhdWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdWRpbycpO1xuICBpZiAoYXVkaW8ucGF1c2VkKSB7XG4gICAgYXVkaW8uY3VycmVudFRpbWUgPSAwO1xuICAgIGF1ZGlvLnBsYXkoKTtcbiAgfSBlbHNlIHtcbiAgICBhdWRpby5wYXVzZSgpO1xuICB9XG59XG5cbndpbmRvdy5wbGF5UGF1c2VBdWRpbyA9IHBsYXlQYXVzZUF1ZGlvO1xud2luZG93LlJldmVhbCA9IFJldmVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9qcy9zbGlkZXMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n");

/***/ }),

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * reveal.js\n * http://revealjs.com\n * MIT licensed\n *\n * Copyright (C) 2018 Hakim El Hattab, http://hakim.se\n */\n(function( root, factory ) {\n\tif( true ) {\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\troot.Reveal = factory();\n\t\t\treturn root.Reveal;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if( typeof exports === 'object' ) {\n\t\t// Node. Does not work with strict CommonJS.\n\t\tmodule.exports = factory();\n\t} else {\n\t\t// Browser globals.\n\t\troot.Reveal = factory();\n\t}\n}( this, function() {\n\n\t'use strict';\n\n\tvar Reveal;\n\n\t// The reveal.js version\n\tvar VERSION = '3.7.0';\n\n\tvar SLIDES_SELECTOR = '.slides section',\n\t\tHORIZONTAL_SLIDES_SELECTOR = '.slides>section',\n\t\tVERTICAL_SLIDES_SELECTOR = '.slides>section.present>section',\n\t\tHOME_SLIDE_SELECTOR = '.slides>section:first-of-type',\n\t\tUA = navigator.userAgent,\n\n\t\t// Configuration defaults, can be overridden at initialization time\n\t\tconfig = {\n\n\t\t\t// The \"normal\" size of the presentation, aspect ratio will be preserved\n\t\t\t// when the presentation is scaled to fit different resolutions\n\t\t\twidth: 960,\n\t\t\theight: 700,\n\n\t\t\t// Factor of the display size that should remain empty around the content\n\t\t\tmargin: 0.04,\n\n\t\t\t// Bounds for smallest/largest possible scale to apply to content\n\t\t\tminScale: 0.2,\n\t\t\tmaxScale: 2.0,\n\n\t\t\t// Display presentation control arrows\n\t\t\tcontrols: true,\n\n\t\t\t// Help the user learn the controls by providing hints, for example by\n\t\t\t// bouncing the down arrow when they first encounter a vertical slide\n\t\t\tcontrolsTutorial: true,\n\n\t\t\t// Determines where controls appear, \"edges\" or \"bottom-right\"\n\t\t\tcontrolsLayout: 'bottom-right',\n\n\t\t\t// Visibility rule for backwards navigation arrows; \"faded\", \"hidden\"\n\t\t\t// or \"visible\"\n\t\t\tcontrolsBackArrows: 'faded',\n\n\t\t\t// Display a presentation progress bar\n\t\t\tprogress: true,\n\n\t\t\t// Display the page number of the current slide\n\t\t\tslideNumber: false,\n\n\t\t\t// Use 1 based indexing for # links to match slide number (default is zero\n\t\t\t// based)\n\t\t\thashOneBasedIndex: false,\n\n\t\t\t// Determine which displays to show the slide number on\n\t\t\tshowSlideNumber: 'all',\n\n\t\t\t// Push each slide change to the browser history\n\t\t\thistory: false,\n\n\t\t\t// Enable keyboard shortcuts for navigation\n\t\t\tkeyboard: true,\n\n\t\t\t// Optional function that blocks keyboard events when retuning false\n\t\t\tkeyboardCondition: null,\n\n\t\t\t// Enable the slide overview mode\n\t\t\toverview: true,\n\n\t\t\t// Disables the default reveal.js slide layout so that you can use\n\t\t\t// custom CSS layout\n\t\t\tdisableLayout: false,\n\n\t\t\t// Vertical centering of slides\n\t\t\tcenter: true,\n\n\t\t\t// Enables touch navigation on devices with touch input\n\t\t\ttouch: true,\n\n\t\t\t// Loop the presentation\n\t\t\tloop: false,\n\n\t\t\t// Change the presentation direction to be RTL\n\t\t\trtl: false,\n\n\t\t\t// Randomizes the order of slides each time the presentation loads\n\t\t\tshuffle: false,\n\n\t\t\t// Turns fragments on and off globally\n\t\t\tfragments: true,\n\n\t\t\t// Flags whether to include the current fragment in the URL,\n\t\t\t// so that reloading brings you to the same fragment position\n\t\t\tfragmentInURL: false,\n\n\t\t\t// Flags if the presentation is running in an embedded mode,\n\t\t\t// i.e. contained within a limited portion of the screen\n\t\t\tembedded: false,\n\n\t\t\t// Flags if we should show a help overlay when the question-mark\n\t\t\t// key is pressed\n\t\t\thelp: true,\n\n\t\t\t// Flags if it should be possible to pause the presentation (blackout)\n\t\t\tpause: true,\n\n\t\t\t// Flags if speaker notes should be visible to all viewers\n\t\t\tshowNotes: false,\n\n\t\t\t// Global override for autolaying embedded media (video/audio/iframe)\n\t\t\t// - null:   Media will only autoplay if data-autoplay is present\n\t\t\t// - true:   All media will autoplay, regardless of individual setting\n\t\t\t// - false:  No media will autoplay, regardless of individual setting\n\t\t\tautoPlayMedia: null,\n\n\t\t\t// Controls automatic progression to the next slide\n\t\t\t// - 0:      Auto-sliding only happens if the data-autoslide HTML attribute\n\t\t\t//           is present on the current slide or fragment\n\t\t\t// - 1+:     All slides will progress automatically at the given interval\n\t\t\t// - false:  No auto-sliding, even if data-autoslide is present\n\t\t\tautoSlide: 0,\n\n\t\t\t// Stop auto-sliding after user input\n\t\t\tautoSlideStoppable: true,\n\n\t\t\t// Use this method for navigation when auto-sliding (defaults to navigateNext)\n\t\t\tautoSlideMethod: null,\n\n\t\t\t// Specify the average time in seconds that you think you will spend\n\t\t\t// presenting each slide. This is used to show a pacing timer in the\n\t\t\t// speaker view\n\t\t\tdefaultTiming: null,\n\n\t\t\t// Enable slide navigation via mouse wheel\n\t\t\tmouseWheel: false,\n\n\t\t\t// Apply a 3D roll to links on hover\n\t\t\trollingLinks: false,\n\n\t\t\t// Hides the address bar on mobile devices\n\t\t\thideAddressBar: true,\n\n\t\t\t// Opens links in an iframe preview overlay\n\t\t\t// Add `data-preview-link` and `data-preview-link=\"false\"` to customise each link\n\t\t\t// individually\n\t\t\tpreviewLinks: false,\n\n\t\t\t// Exposes the reveal.js API through window.postMessage\n\t\t\tpostMessage: true,\n\n\t\t\t// Dispatches all reveal.js events to the parent window through postMessage\n\t\t\tpostMessageEvents: false,\n\n\t\t\t// Focuses body when page changes visibility to ensure keyboard shortcuts work\n\t\t\tfocusBodyOnPageVisibilityChange: true,\n\n\t\t\t// Transition style\n\t\t\ttransition: 'slide', // none/fade/slide/convex/concave/zoom\n\n\t\t\t// Transition speed\n\t\t\ttransitionSpeed: 'default', // default/fast/slow\n\n\t\t\t// Transition style for full page slide backgrounds\n\t\t\tbackgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom\n\n\t\t\t// Parallax background image\n\t\t\tparallaxBackgroundImage: '', // CSS syntax, e.g. \"a.jpg\"\n\n\t\t\t// Parallax background size\n\t\t\tparallaxBackgroundSize: '', // CSS syntax, e.g. \"3000px 2000px\"\n\n\t\t\t// Parallax background repeat\n\t\t\tparallaxBackgroundRepeat: '', // repeat/repeat-x/repeat-y/no-repeat/initial/inherit\n\n\t\t\t// Parallax background position\n\t\t\tparallaxBackgroundPosition: '', // CSS syntax, e.g. \"top left\"\n\n\t\t\t// Amount of pixels to move the parallax background per slide step\n\t\t\tparallaxBackgroundHorizontal: null,\n\t\t\tparallaxBackgroundVertical: null,\n\n\t\t\t// The maximum number of pages a single slide can expand onto when printing\n\t\t\t// to PDF, unlimited by default\n\t\t\tpdfMaxPagesPerSlide: Number.POSITIVE_INFINITY,\n\n\t\t\t// Prints each fragment on a separate slide\n\t\t\tpdfSeparateFragments: true,\n\n\t\t\t// Offset used to reduce the height of content within exported PDF pages.\n\t\t\t// This exists to account for environment differences based on how you\n\t\t\t// print to PDF. CLI printing options, like phantomjs and wkpdf, can end\n\t\t\t// on precisely the total height of the document whereas in-browser\n\t\t\t// printing has to end one pixel before.\n\t\t\tpdfPageHeightOffset: -1,\n\n\t\t\t// Number of slides away from the current that are visible\n\t\t\tviewDistance: 3,\n\n\t\t\t// The display mode that will be used to show slides\n\t\t\tdisplay: 'block',\n\n\t\t\t// Script dependencies to load\n\t\t\tdependencies: []\n\n\t\t},\n\n\t\t// Flags if Reveal.initialize() has been called\n\t\tinitialized = false,\n\n\t\t// Flags if reveal.js is loaded (has dispatched the 'ready' event)\n\t\tloaded = false,\n\n\t\t// Flags if the overview mode is currently active\n\t\toverview = false,\n\n\t\t// Holds the dimensions of our overview slides, including margins\n\t\toverviewSlideWidth = null,\n\t\toverviewSlideHeight = null,\n\n\t\t// The horizontal and vertical index of the currently active slide\n\t\tindexh,\n\t\tindexv,\n\n\t\t// The previous and current slide HTML elements\n\t\tpreviousSlide,\n\t\tcurrentSlide,\n\n\t\tpreviousBackground,\n\n\t\t// Remember which directions that the user has navigated towards\n\t\thasNavigatedRight = false,\n\t\thasNavigatedDown = false,\n\n\t\t// Slides may hold a data-state attribute which we pick up and apply\n\t\t// as a class to the body. This list contains the combined state of\n\t\t// all current slides.\n\t\tstate = [],\n\n\t\t// The current scale of the presentation (see width/height config)\n\t\tscale = 1,\n\n\t\t// CSS transform that is currently applied to the slides container,\n\t\t// split into two groups\n\t\tslidesTransform = { layout: '', overview: '' },\n\n\t\t// Cached references to DOM elements\n\t\tdom = {},\n\n\t\t// Features supported by the browser, see #checkCapabilities()\n\t\tfeatures = {},\n\n\t\t// Client is a mobile device, see #checkCapabilities()\n\t\tisMobileDevice,\n\n\t\t// Client is a desktop Chrome, see #checkCapabilities()\n\t\tisChrome,\n\n\t\t// Throttles mouse wheel navigation\n\t\tlastMouseWheelStep = 0,\n\n\t\t// Delays updates to the URL due to a Chrome thumbnailer bug\n\t\twriteURLTimeout = 0,\n\n\t\t// Flags if the interaction event listeners are bound\n\t\teventsAreBound = false,\n\n\t\t// The current auto-slide duration\n\t\tautoSlide = 0,\n\n\t\t// Auto slide properties\n\t\tautoSlidePlayer,\n\t\tautoSlideTimeout = 0,\n\t\tautoSlideStartTime = -1,\n\t\tautoSlidePaused = false,\n\n\t\t// Holds information about the currently ongoing touch input\n\t\ttouch = {\n\t\t\tstartX: 0,\n\t\t\tstartY: 0,\n\t\t\tstartSpan: 0,\n\t\t\tstartCount: 0,\n\t\t\tcaptured: false,\n\t\t\tthreshold: 40\n\t\t},\n\n\t\t// Holds information about the keyboard shortcuts\n\t\tkeyboardShortcuts = {\n\t\t\t'N  ,  SPACE':\t\t\t'Next slide',\n\t\t\t'P':\t\t\t\t\t'Previous slide',\n\t\t\t'&#8592;  ,  H':\t\t'Navigate left',\n\t\t\t'&#8594;  ,  L':\t\t'Navigate right',\n\t\t\t'&#8593;  ,  K':\t\t'Navigate up',\n\t\t\t'&#8595;  ,  J':\t\t'Navigate down',\n\t\t\t'Home':\t\t\t\t\t'First slide',\n\t\t\t'End':\t\t\t\t\t'Last slide',\n\t\t\t'B  ,  .':\t\t\t\t'Pause',\n\t\t\t'F':\t\t\t\t\t'Fullscreen',\n\t\t\t'ESC, O':\t\t\t\t'Slide overview'\n\t\t},\n\n\t\t// Holds custom key code mappings\n\t\tregisteredKeyBindings = {};\n\n\t/**\n\t * Starts up the presentation if the client is capable.\n\t */\n\tfunction initialize( options ) {\n\n\t\t// Make sure we only initialize once\n\t\tif( initialized === true ) return;\n\n\t\tinitialized = true;\n\n\t\tcheckCapabilities();\n\n\t\tif( !features.transforms2d && !features.transforms3d ) {\n\t\t\tdocument.body.setAttribute( 'class', 'no-transforms' );\n\n\t\t\t// Since JS won't be running any further, we load all lazy\n\t\t\t// loading elements upfront\n\t\t\tvar images = toArray( document.getElementsByTagName( 'img' ) ),\n\t\t\t\tiframes = toArray( document.getElementsByTagName( 'iframe' ) );\n\n\t\t\tvar lazyLoadable = images.concat( iframes );\n\n\t\t\tfor( var i = 0, len = lazyLoadable.length; i < len; i++ ) {\n\t\t\t\tvar element = lazyLoadable[i];\n\t\t\t\tif( element.getAttribute( 'data-src' ) ) {\n\t\t\t\t\telement.setAttribute( 'src', element.getAttribute( 'data-src' ) );\n\t\t\t\t\telement.removeAttribute( 'data-src' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the browser doesn't support core features we won't be\n\t\t\t// using JavaScript to control the presentation\n\t\t\treturn;\n\t\t}\n\n\t\t// Cache references to key DOM elements\n\t\tdom.wrapper = document.querySelector( '.reveal' );\n\t\tdom.slides = document.querySelector( '.reveal .slides' );\n\n\t\t// Force a layout when the whole page, incl fonts, has loaded\n\t\twindow.addEventListener( 'load', layout, false );\n\n\t\tvar query = Reveal.getQueryHash();\n\n\t\t// Do not accept new dependencies via query config to avoid\n\t\t// the potential of malicious script injection\n\t\tif( typeof query['dependencies'] !== 'undefined' ) delete query['dependencies'];\n\n\t\t// Copy options over to our config object\n\t\textend( config, options );\n\t\textend( config, query );\n\n\t\t// Hide the address bar in mobile browsers\n\t\thideAddressBar();\n\n\t\t// Loads the dependencies and continues to #start() once done\n\t\tload();\n\n\t}\n\n\t/**\n\t * Inspect the client to see what it's capable of, this\n\t * should only happens once per runtime.\n\t */\n\tfunction checkCapabilities() {\n\n\t\tisMobileDevice = /(iphone|ipod|ipad|android)/gi.test( UA );\n\t\tisChrome = /chrome/i.test( UA ) && !/edge/i.test( UA );\n\n\t\tvar testElement = document.createElement( 'div' );\n\n\t\tfeatures.transforms3d = 'WebkitPerspective' in testElement.style ||\n\t\t\t\t\t\t\t\t'MozPerspective' in testElement.style ||\n\t\t\t\t\t\t\t\t'msPerspective' in testElement.style ||\n\t\t\t\t\t\t\t\t'OPerspective' in testElement.style ||\n\t\t\t\t\t\t\t\t'perspective' in testElement.style;\n\n\t\tfeatures.transforms2d = 'WebkitTransform' in testElement.style ||\n\t\t\t\t\t\t\t\t'MozTransform' in testElement.style ||\n\t\t\t\t\t\t\t\t'msTransform' in testElement.style ||\n\t\t\t\t\t\t\t\t'OTransform' in testElement.style ||\n\t\t\t\t\t\t\t\t'transform' in testElement.style;\n\n\t\tfeatures.requestAnimationFrameMethod = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\t\tfeatures.requestAnimationFrame = typeof features.requestAnimationFrameMethod === 'function';\n\n\t\tfeatures.canvas = !!document.createElement( 'canvas' ).getContext;\n\n\t\t// Transitions in the overview are disabled in desktop and\n\t\t// Safari due to lag\n\t\tfeatures.overviewTransitions = !/Version\\/[\\d\\.]+.*Safari/.test( UA );\n\n\t\t// Flags if we should use zoom instead of transform to scale\n\t\t// up slides. Zoom produces crisper results but has a lot of\n\t\t// xbrowser quirks so we only use it in whitelsited browsers.\n\t\tfeatures.zoom = 'zoom' in testElement.style && !isMobileDevice &&\n\t\t\t\t\t\t( isChrome || /Version\\/[\\d\\.]+.*Safari/.test( UA ) );\n\n\t}\n\n\t/**\n\t * Loads the dependencies of reveal.js. Dependencies are\n\t * defined via the configuration option 'dependencies'\n\t * and will be loaded prior to starting/binding reveal.js.\n\t * Some dependencies may have an 'async' flag, if so they\n\t * will load after reveal.js has been started up.\n\t */\n\tfunction load() {\n\n\t\tvar scripts = [],\n\t\t\tscriptsAsync = [],\n\t\t\tscriptsToPreload = 0;\n\n\t\t// Called once synchronous scripts finish loading\n\t\tfunction proceed() {\n\t\t\tif( scriptsAsync.length ) {\n\t\t\t\t// Load asynchronous scripts\n\t\t\t\thead.js.apply( null, scriptsAsync );\n\t\t\t}\n\n\t\t\tstart();\n\t\t}\n\n\t\tfunction loadScript( s ) {\n\t\t\thead.ready( s.src.match( /([\\w\\d_\\-]*)\\.?js(\\?[\\w\\d.=&]*)?$|[^\\\\\\/]*$/i )[0], function() {\n\t\t\t\t// Extension may contain callback functions\n\t\t\t\tif( typeof s.callback === 'function' ) {\n\t\t\t\t\ts.callback.apply( this );\n\t\t\t\t}\n\n\t\t\t\tif( --scriptsToPreload === 0 ) {\n\t\t\t\t\tproceed();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfor( var i = 0, len = config.dependencies.length; i < len; i++ ) {\n\t\t\tvar s = config.dependencies[i];\n\n\t\t\t// Load if there's no condition or the condition is truthy\n\t\t\tif( !s.condition || s.condition() ) {\n\t\t\t\tif( s.async ) {\n\t\t\t\t\tscriptsAsync.push( s.src );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscripts.push( s.src );\n\t\t\t\t}\n\n\t\t\t\tloadScript( s );\n\t\t\t}\n\t\t}\n\n\t\tif( scripts.length ) {\n\t\t\tscriptsToPreload = scripts.length;\n\n\t\t\t// Load synchronous scripts\n\t\t\thead.js.apply( null, scripts );\n\t\t}\n\t\telse {\n\t\t\tproceed();\n\t\t}\n\n\t}\n\n\t/**\n\t * Starts up reveal.js by binding input events and navigating\n\t * to the current URL deeplink if there is one.\n\t */\n\tfunction start() {\n\n\t\tloaded = true;\n\n\t\t// Make sure we've got all the DOM elements we need\n\t\tsetupDOM();\n\n\t\t// Listen to messages posted to this window\n\t\tsetupPostMessage();\n\n\t\t// Prevent the slides from being scrolled out of view\n\t\tsetupScrollPrevention();\n\n\t\t// Resets all vertical slides so that only the first is visible\n\t\tresetVerticalSlides();\n\n\t\t// Updates the presentation to match the current configuration values\n\t\tconfigure();\n\n\t\t// Read the initial hash\n\t\treadURL();\n\n\t\t// Update all backgrounds\n\t\tupdateBackground( true );\n\n\t\t// Notify listeners that the presentation is ready but use a 1ms\n\t\t// timeout to ensure it's not fired synchronously after #initialize()\n\t\tsetTimeout( function() {\n\t\t\t// Enable transitions now that we're loaded\n\t\t\tdom.slides.classList.remove( 'no-transition' );\n\n\t\t\tdom.wrapper.classList.add( 'ready' );\n\n\t\t\tdispatchEvent( 'ready', {\n\t\t\t\t'indexh': indexh,\n\t\t\t\t'indexv': indexv,\n\t\t\t\t'currentSlide': currentSlide\n\t\t\t} );\n\t\t}, 1 );\n\n\t\t// Special setup and config is required when printing to PDF\n\t\tif( isPrintingPDF() ) {\n\t\t\tremoveEventListeners();\n\n\t\t\t// The document needs to have loaded for the PDF layout\n\t\t\t// measurements to be accurate\n\t\t\tif( document.readyState === 'complete' ) {\n\t\t\t\tsetupPDF();\n\t\t\t}\n\t\t\telse {\n\t\t\t\twindow.addEventListener( 'load', setupPDF );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Finds and stores references to DOM elements which are\n\t * required by the presentation. If a required element is\n\t * not found, it is created.\n\t */\n\tfunction setupDOM() {\n\n\t\t// Prevent transitions while we're loading\n\t\tdom.slides.classList.add( 'no-transition' );\n\n\t\tif( isMobileDevice ) {\n\t\t\tdom.wrapper.classList.add( 'no-hover' );\n\t\t}\n\t\telse {\n\t\t\tdom.wrapper.classList.remove( 'no-hover' );\n\t\t}\n\n\t\tif( /iphone/gi.test( UA ) ) {\n\t\t\tdom.wrapper.classList.add( 'ua-iphone' );\n\t\t}\n\t\telse {\n\t\t\tdom.wrapper.classList.remove( 'ua-iphone' );\n\t\t}\n\n\t\t// Background element\n\t\tdom.background = createSingletonNode( dom.wrapper, 'div', 'backgrounds', null );\n\n\t\t// Progress bar\n\t\tdom.progress = createSingletonNode( dom.wrapper, 'div', 'progress', '<span></span>' );\n\t\tdom.progressbar = dom.progress.querySelector( 'span' );\n\n\t\t// Arrow controls\n\t\tdom.controls = createSingletonNode( dom.wrapper, 'aside', 'controls',\n\t\t\t'<button class=\"navigate-left\" aria-label=\"previous slide\"><div class=\"controls-arrow\"></div></button>' +\n\t\t\t'<button class=\"navigate-right\" aria-label=\"next slide\"><div class=\"controls-arrow\"></div></button>' +\n\t\t\t'<button class=\"navigate-up\" aria-label=\"above slide\"><div class=\"controls-arrow\"></div></button>' +\n\t\t\t'<button class=\"navigate-down\" aria-label=\"below slide\"><div class=\"controls-arrow\"></div></button>' );\n\n\t\t// Slide number\n\t\tdom.slideNumber = createSingletonNode( dom.wrapper, 'div', 'slide-number', '' );\n\n\t\t// Element containing notes that are visible to the audience\n\t\tdom.speakerNotes = createSingletonNode( dom.wrapper, 'div', 'speaker-notes', null );\n\t\tdom.speakerNotes.setAttribute( 'data-prevent-swipe', '' );\n\t\tdom.speakerNotes.setAttribute( 'tabindex', '0' );\n\n\t\t// Overlay graphic which is displayed during the paused mode\n\t\tdom.pauseOverlay = createSingletonNode( dom.wrapper, 'div', 'pause-overlay', '<button class=\"resume-button\">Resume presentation</button>' );\n\t\tdom.resumeButton = dom.pauseOverlay.querySelector( '.resume-button' );\n\n\t\tdom.wrapper.setAttribute( 'role', 'application' );\n\n\t\t// There can be multiple instances of controls throughout the page\n\t\tdom.controlsLeft = toArray( document.querySelectorAll( '.navigate-left' ) );\n\t\tdom.controlsRight = toArray( document.querySelectorAll( '.navigate-right' ) );\n\t\tdom.controlsUp = toArray( document.querySelectorAll( '.navigate-up' ) );\n\t\tdom.controlsDown = toArray( document.querySelectorAll( '.navigate-down' ) );\n\t\tdom.controlsPrev = toArray( document.querySelectorAll( '.navigate-prev' ) );\n\t\tdom.controlsNext = toArray( document.querySelectorAll( '.navigate-next' ) );\n\n\t\t// The right and down arrows in the standard reveal.js controls\n\t\tdom.controlsRightArrow = dom.controls.querySelector( '.navigate-right' );\n\t\tdom.controlsDownArrow = dom.controls.querySelector( '.navigate-down' );\n\n\t\tdom.statusDiv = createStatusDiv();\n\t}\n\n\t/**\n\t * Creates a hidden div with role aria-live to announce the\n\t * current slide content. Hide the div off-screen to make it\n\t * available only to Assistive Technologies.\n\t *\n\t * @return {HTMLElement}\n\t */\n\tfunction createStatusDiv() {\n\n\t\tvar statusDiv = document.getElementById( 'aria-status-div' );\n\t\tif( !statusDiv ) {\n\t\t\tstatusDiv = document.createElement( 'div' );\n\t\t\tstatusDiv.style.position = 'absolute';\n\t\t\tstatusDiv.style.height = '1px';\n\t\t\tstatusDiv.style.width = '1px';\n\t\t\tstatusDiv.style.overflow = 'hidden';\n\t\t\tstatusDiv.style.clip = 'rect( 1px, 1px, 1px, 1px )';\n\t\t\tstatusDiv.setAttribute( 'id', 'aria-status-div' );\n\t\t\tstatusDiv.setAttribute( 'aria-live', 'polite' );\n\t\t\tstatusDiv.setAttribute( 'aria-atomic','true' );\n\t\t\tdom.wrapper.appendChild( statusDiv );\n\t\t}\n\t\treturn statusDiv;\n\n\t}\n\n\t/**\n\t * Converts the given HTML element into a string of text\n\t * that can be announced to a screen reader. Hidden\n\t * elements are excluded.\n\t */\n\tfunction getStatusText( node ) {\n\n\t\tvar text = '';\n\n\t\t// Text node\n\t\tif( node.nodeType === 3 ) {\n\t\t\ttext += node.textContent;\n\t\t}\n\t\t// Element node\n\t\telse if( node.nodeType === 1 ) {\n\n\t\t\tvar isAriaHidden = node.getAttribute( 'aria-hidden' );\n\t\t\tvar isDisplayHidden = window.getComputedStyle( node )['display'] === 'none';\n\t\t\tif( isAriaHidden !== 'true' && !isDisplayHidden ) {\n\n\t\t\t\ttoArray( node.childNodes ).forEach( function( child ) {\n\t\t\t\t\ttext += getStatusText( child );\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn text;\n\n\t}\n\n\t/**\n\t * Configures the presentation for printing to a static\n\t * PDF.\n\t */\n\tfunction setupPDF() {\n\n\t\tvar slideSize = getComputedSlideSize( window.innerWidth, window.innerHeight );\n\n\t\t// Dimensions of the PDF pages\n\t\tvar pageWidth = Math.floor( slideSize.width * ( 1 + config.margin ) ),\n\t\t\tpageHeight = Math.floor( slideSize.height * ( 1 + config.margin ) );\n\n\t\t// Dimensions of slides within the pages\n\t\tvar slideWidth = slideSize.width,\n\t\t\tslideHeight = slideSize.height;\n\n\t\t// Let the browser know what page size we want to print\n\t\tinjectStyleSheet( '@page{size:'+ pageWidth +'px '+ pageHeight +'px; margin: 0px;}' );\n\n\t\t// Limit the size of certain elements to the dimensions of the slide\n\t\tinjectStyleSheet( '.reveal section>img, .reveal section>video, .reveal section>iframe{max-width: '+ slideWidth +'px; max-height:'+ slideHeight +'px}' );\n\n\t\tdocument.body.classList.add( 'print-pdf' );\n\t\tdocument.body.style.width = pageWidth + 'px';\n\t\tdocument.body.style.height = pageHeight + 'px';\n\n\t\t// Make sure stretch elements fit on slide\n\t\tlayoutSlideContents( slideWidth, slideHeight );\n\n\t\t// Add each slide's index as attributes on itself, we need these\n\t\t// indices to generate slide numbers below\n\t\ttoArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( hslide, h ) {\n\t\t\thslide.setAttribute( 'data-index-h', h );\n\n\t\t\tif( hslide.classList.contains( 'stack' ) ) {\n\t\t\t\ttoArray( hslide.querySelectorAll( 'section' ) ).forEach( function( vslide, v ) {\n\t\t\t\t\tvslide.setAttribute( 'data-index-h', h );\n\t\t\t\t\tvslide.setAttribute( 'data-index-v', v );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Slide and slide background layout\n\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {\n\n\t\t\t// Vertical stacks are not centred since their section\n\t\t\t// children will be\n\t\t\tif( slide.classList.contains( 'stack' ) === false ) {\n\t\t\t\t// Center the slide inside of the page, giving the slide some margin\n\t\t\t\tvar left = ( pageWidth - slideWidth ) / 2,\n\t\t\t\t\ttop = ( pageHeight - slideHeight ) / 2;\n\n\t\t\t\tvar contentHeight = slide.scrollHeight;\n\t\t\t\tvar numberOfPages = Math.max( Math.ceil( contentHeight / pageHeight ), 1 );\n\n\t\t\t\t// Adhere to configured pages per slide limit\n\t\t\t\tnumberOfPages = Math.min( numberOfPages, config.pdfMaxPagesPerSlide );\n\n\t\t\t\t// Center slides vertically\n\t\t\t\tif( numberOfPages === 1 && config.center || slide.classList.contains( 'center' ) ) {\n\t\t\t\t\ttop = Math.max( ( pageHeight - contentHeight ) / 2, 0 );\n\t\t\t\t}\n\n\t\t\t\t// Wrap the slide in a page element and hide its overflow\n\t\t\t\t// so that no page ever flows onto another\n\t\t\t\tvar page = document.createElement( 'div' );\n\t\t\t\tpage.className = 'pdf-page';\n\t\t\t\tpage.style.height = ( ( pageHeight + config.pdfPageHeightOffset ) * numberOfPages ) + 'px';\n\t\t\t\tslide.parentNode.insertBefore( page, slide );\n\t\t\t\tpage.appendChild( slide );\n\n\t\t\t\t// Position the slide inside of the page\n\t\t\t\tslide.style.left = left + 'px';\n\t\t\t\tslide.style.top = top + 'px';\n\t\t\t\tslide.style.width = slideWidth + 'px';\n\n\t\t\t\tif( slide.slideBackgroundElement ) {\n\t\t\t\t\tpage.insertBefore( slide.slideBackgroundElement, slide );\n\t\t\t\t}\n\n\t\t\t\t// Inject notes if `showNotes` is enabled\n\t\t\t\tif( config.showNotes ) {\n\n\t\t\t\t\t// Are there notes for this slide?\n\t\t\t\t\tvar notes = getSlideNotes( slide );\n\t\t\t\t\tif( notes ) {\n\n\t\t\t\t\t\tvar notesSpacing = 8;\n\t\t\t\t\t\tvar notesLayout = typeof config.showNotes === 'string' ? config.showNotes : 'inline';\n\t\t\t\t\t\tvar notesElement = document.createElement( 'div' );\n\t\t\t\t\t\tnotesElement.classList.add( 'speaker-notes' );\n\t\t\t\t\t\tnotesElement.classList.add( 'speaker-notes-pdf' );\n\t\t\t\t\t\tnotesElement.setAttribute( 'data-layout', notesLayout );\n\t\t\t\t\t\tnotesElement.innerHTML = notes;\n\n\t\t\t\t\t\tif( notesLayout === 'separate-page' ) {\n\t\t\t\t\t\t\tpage.parentNode.insertBefore( notesElement, page.nextSibling );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnotesElement.style.left = notesSpacing + 'px';\n\t\t\t\t\t\t\tnotesElement.style.bottom = notesSpacing + 'px';\n\t\t\t\t\t\t\tnotesElement.style.width = ( pageWidth - notesSpacing*2 ) + 'px';\n\t\t\t\t\t\t\tpage.appendChild( notesElement );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Inject slide numbers if `slideNumbers` are enabled\n\t\t\t\tif( config.slideNumber && /all|print/i.test( config.showSlideNumber ) ) {\n\t\t\t\t\tvar slideNumberH = parseInt( slide.getAttribute( 'data-index-h' ), 10 ) + 1,\n\t\t\t\t\t\tslideNumberV = parseInt( slide.getAttribute( 'data-index-v' ), 10 ) + 1;\n\n\t\t\t\t\tvar numberElement = document.createElement( 'div' );\n\t\t\t\t\tnumberElement.classList.add( 'slide-number' );\n\t\t\t\t\tnumberElement.classList.add( 'slide-number-pdf' );\n\t\t\t\t\tnumberElement.innerHTML = formatSlideNumber( slideNumberH, '.', slideNumberV );\n\t\t\t\t\tpage.appendChild( numberElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy page and show fragments one after another\n\t\t\t\tif( config.pdfSeparateFragments ) {\n\n\t\t\t\t\t// Each fragment 'group' is an array containing one or more\n\t\t\t\t\t// fragments. Multiple fragments that appear at the same time\n\t\t\t\t\t// are part of the same group.\n\t\t\t\t\tvar fragmentGroups = sortFragments( page.querySelectorAll( '.fragment' ), true );\n\n\t\t\t\t\tvar previousFragmentStep;\n\t\t\t\t\tvar previousPage;\n\n\t\t\t\t\tfragmentGroups.forEach( function( fragments ) {\n\n\t\t\t\t\t\t// Remove 'current-fragment' from the previous group\n\t\t\t\t\t\tif( previousFragmentStep ) {\n\t\t\t\t\t\t\tpreviousFragmentStep.forEach( function( fragment ) {\n\t\t\t\t\t\t\t\tfragment.classList.remove( 'current-fragment' );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Show the fragments for the current index\n\t\t\t\t\t\tfragments.forEach( function( fragment ) {\n\t\t\t\t\t\t\tfragment.classList.add( 'visible', 'current-fragment' );\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Create a separate page for the current fragment state\n\t\t\t\t\t\tvar clonedPage = page.cloneNode( true );\n\t\t\t\t\t\tpage.parentNode.insertBefore( clonedPage, ( previousPage || page ).nextSibling );\n\n\t\t\t\t\t\tpreviousFragmentStep = fragments;\n\t\t\t\t\t\tpreviousPage = clonedPage;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Reset the first/original page so that all fragments are hidden\n\t\t\t\t\tfragmentGroups.forEach( function( fragments ) {\n\t\t\t\t\t\tfragments.forEach( function( fragment ) {\n\t\t\t\t\t\t\tfragment.classList.remove( 'visible', 'current-fragment' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\t\t\t\t// Show all fragments\n\t\t\t\telse {\n\t\t\t\t\ttoArray( page.querySelectorAll( '.fragment:not(.fade-out)' ) ).forEach( function( fragment ) {\n\t\t\t\t\t\tfragment.classList.add( 'visible' );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Notify subscribers that the PDF layout is good to go\n\t\tdispatchEvent( 'pdf-ready' );\n\n\t}\n\n\t/**\n\t * This is an unfortunate necessity. Some actions – such as\n\t * an input field being focused in an iframe or using the\n\t * keyboard to expand text selection beyond the bounds of\n\t * a slide – can trigger our content to be pushed out of view.\n\t * This scrolling can not be prevented by hiding overflow in\n\t * CSS (we already do) so we have to resort to repeatedly\n\t * checking if the slides have been offset :(\n\t */\n\tfunction setupScrollPrevention() {\n\n\t\tsetInterval( function() {\n\t\t\tif( dom.wrapper.scrollTop !== 0 || dom.wrapper.scrollLeft !== 0 ) {\n\t\t\t\tdom.wrapper.scrollTop = 0;\n\t\t\t\tdom.wrapper.scrollLeft = 0;\n\t\t\t}\n\t\t}, 1000 );\n\n\t}\n\n\t/**\n\t * Creates an HTML element and returns a reference to it.\n\t * If the element already exists the existing instance will\n\t * be returned.\n\t *\n\t * @param {HTMLElement} container\n\t * @param {string} tagname\n\t * @param {string} classname\n\t * @param {string} innerHTML\n\t *\n\t * @return {HTMLElement}\n\t */\n\tfunction createSingletonNode( container, tagname, classname, innerHTML ) {\n\n\t\t// Find all nodes matching the description\n\t\tvar nodes = container.querySelectorAll( '.' + classname );\n\n\t\t// Check all matches to find one which is a direct child of\n\t\t// the specified container\n\t\tfor( var i = 0; i < nodes.length; i++ ) {\n\t\t\tvar testNode = nodes[i];\n\t\t\tif( testNode.parentNode === container ) {\n\t\t\t\treturn testNode;\n\t\t\t}\n\t\t}\n\n\t\t// If no node was found, create it now\n\t\tvar node = document.createElement( tagname );\n\t\tnode.className = classname;\n\t\tif( typeof innerHTML === 'string' ) {\n\t\t\tnode.innerHTML = innerHTML;\n\t\t}\n\t\tcontainer.appendChild( node );\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Creates the slide background elements and appends them\n\t * to the background container. One element is created per\n\t * slide no matter if the given slide has visible background.\n\t */\n\tfunction createBackgrounds() {\n\n\t\tvar printMode = isPrintingPDF();\n\n\t\t// Clear prior backgrounds\n\t\tdom.background.innerHTML = '';\n\t\tdom.background.classList.add( 'no-transition' );\n\n\t\t// Iterate over all horizontal slides\n\t\ttoArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( slideh ) {\n\n\t\t\tvar backgroundStack = createBackground( slideh, dom.background );\n\n\t\t\t// Iterate over all vertical slides\n\t\t\ttoArray( slideh.querySelectorAll( 'section' ) ).forEach( function( slidev ) {\n\n\t\t\t\tcreateBackground( slidev, backgroundStack );\n\n\t\t\t\tbackgroundStack.classList.add( 'stack' );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// Add parallax background if specified\n\t\tif( config.parallaxBackgroundImage ) {\n\n\t\t\tdom.background.style.backgroundImage = 'url(\"' + config.parallaxBackgroundImage + '\")';\n\t\t\tdom.background.style.backgroundSize = config.parallaxBackgroundSize;\n\t\t\tdom.background.style.backgroundRepeat = config.parallaxBackgroundRepeat;\n\t\t\tdom.background.style.backgroundPosition = config.parallaxBackgroundPosition;\n\n\t\t\t// Make sure the below properties are set on the element - these properties are\n\t\t\t// needed for proper transitions to be set on the element via CSS. To remove\n\t\t\t// annoying background slide-in effect when the presentation starts, apply\n\t\t\t// these properties after short time delay\n\t\t\tsetTimeout( function() {\n\t\t\t\tdom.wrapper.classList.add( 'has-parallax-background' );\n\t\t\t}, 1 );\n\n\t\t}\n\t\telse {\n\n\t\t\tdom.background.style.backgroundImage = '';\n\t\t\tdom.wrapper.classList.remove( 'has-parallax-background' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a background for the given slide.\n\t *\n\t * @param {HTMLElement} slide\n\t * @param {HTMLElement} container The element that the background\n\t * should be appended to\n\t * @return {HTMLElement} New background div\n\t */\n\tfunction createBackground( slide, container ) {\n\n\n\t\t// Main slide background element\n\t\tvar element = document.createElement( 'div' );\n\t\telement.className = 'slide-background ' + slide.className.replace( /present|past|future/, '' );\n\n\t\t// Inner background element that wraps images/videos/iframes\n\t\tvar contentElement = document.createElement( 'div' );\n\t\tcontentElement.className = 'slide-background-content';\n\n\t\telement.appendChild( contentElement );\n\t\tcontainer.appendChild( element );\n\n\t\tslide.slideBackgroundElement = element;\n\t\tslide.slideBackgroundContentElement = contentElement;\n\n\t\t// Syncs the background to reflect all current background settings\n\t\tsyncBackground( slide );\n\n\t\treturn element;\n\n\t}\n\n\t/**\n\t * Renders all of the visual properties of a slide background\n\t * based on the various background attributes.\n\t *\n\t * @param {HTMLElement} slide\n\t */\n\tfunction syncBackground( slide ) {\n\n\t\tvar element = slide.slideBackgroundElement,\n\t\t\tcontentElement = slide.slideBackgroundContentElement;\n\n\t\t// Reset the prior background state in case this is not the\n\t\t// initial sync\n\t\tslide.classList.remove( 'has-dark-background' );\n\t\tslide.classList.remove( 'has-light-background' );\n\n\t\telement.removeAttribute( 'data-loaded' );\n\t\telement.removeAttribute( 'data-background-hash' );\n\t\telement.removeAttribute( 'data-background-size' );\n\t\telement.removeAttribute( 'data-background-transition' );\n\t\telement.style.backgroundColor = '';\n\n\t\tcontentElement.style.backgroundSize = '';\n\t\tcontentElement.style.backgroundRepeat = '';\n\t\tcontentElement.style.backgroundPosition = '';\n\t\tcontentElement.style.backgroundImage = '';\n\t\tcontentElement.style.opacity = '';\n\t\tcontentElement.innerHTML = '';\n\n\t\tvar data = {\n\t\t\tbackground: slide.getAttribute( 'data-background' ),\n\t\t\tbackgroundSize: slide.getAttribute( 'data-background-size' ),\n\t\t\tbackgroundImage: slide.getAttribute( 'data-background-image' ),\n\t\t\tbackgroundVideo: slide.getAttribute( 'data-background-video' ),\n\t\t\tbackgroundIframe: slide.getAttribute( 'data-background-iframe' ),\n\t\t\tbackgroundColor: slide.getAttribute( 'data-background-color' ),\n\t\t\tbackgroundRepeat: slide.getAttribute( 'data-background-repeat' ),\n\t\t\tbackgroundPosition: slide.getAttribute( 'data-background-position' ),\n\t\t\tbackgroundTransition: slide.getAttribute( 'data-background-transition' ),\n\t\t\tbackgroundOpacity: slide.getAttribute( 'data-background-opacity' )\n\t\t};\n\n\t\tif( data.background ) {\n\t\t\t// Auto-wrap image urls in url(...)\n\t\t\tif( /^(http|file|\\/\\/)/gi.test( data.background ) || /\\.(svg|png|jpg|jpeg|gif|bmp)([?#\\s]|$)/gi.test( data.background ) ) {\n\t\t\t\tslide.setAttribute( 'data-background-image', data.background );\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.style.background = data.background;\n\t\t\t}\n\t\t}\n\n\t\t// Create a hash for this combination of background settings.\n\t\t// This is used to determine when two slide backgrounds are\n\t\t// the same.\n\t\tif( data.background || data.backgroundColor || data.backgroundImage || data.backgroundVideo || data.backgroundIframe ) {\n\t\t\telement.setAttribute( 'data-background-hash', data.background +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundSize +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundImage +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundVideo +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundIframe +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundColor +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundRepeat +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundPosition +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundTransition +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.backgroundOpacity );\n\t\t}\n\n\t\t// Additional and optional background properties\n\t\tif( data.backgroundSize ) element.setAttribute( 'data-background-size', data.backgroundSize );\n\t\tif( data.backgroundColor ) element.style.backgroundColor = data.backgroundColor;\n\t\tif( data.backgroundTransition ) element.setAttribute( 'data-background-transition', data.backgroundTransition );\n\n\t\t// Background image options are set on the content wrapper\n\t\tif( data.backgroundSize ) contentElement.style.backgroundSize = data.backgroundSize;\n\t\tif( data.backgroundRepeat ) contentElement.style.backgroundRepeat = data.backgroundRepeat;\n\t\tif( data.backgroundPosition ) contentElement.style.backgroundPosition = data.backgroundPosition;\n\t\tif( data.backgroundOpacity ) contentElement.style.opacity = data.backgroundOpacity;\n\n\t\t// If this slide has a background color, add a class that\n\t\t// signals if it is light or dark. If the slide has no background\n\t\t// color, no class will be set\n\t\tvar computedBackgroundStyle = window.getComputedStyle( element );\n\t\tif( computedBackgroundStyle && computedBackgroundStyle.backgroundColor ) {\n\t\t\tvar rgb = colorToRgb( computedBackgroundStyle.backgroundColor );\n\n\t\t\t// Ignore fully transparent backgrounds. Some browsers return\n\t\t\t// rgba(0,0,0,0) when reading the computed background color of\n\t\t\t// an element with no background\n\t\t\tif( rgb && rgb.a !== 0 ) {\n\t\t\t\tif( colorBrightness( computedBackgroundStyle.backgroundColor ) < 128 ) {\n\t\t\t\t\tslide.classList.add( 'has-dark-background' );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tslide.classList.add( 'has-light-background' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Registers a listener to postMessage events, this makes it\n\t * possible to call all reveal.js API methods from another\n\t * window. For example:\n\t *\n\t * revealWindow.postMessage( JSON.stringify({\n\t *   method: 'slide',\n\t *   args: [ 2 ]\n\t * }), '*' );\n\t */\n\tfunction setupPostMessage() {\n\n\t\tif( config.postMessage ) {\n\t\t\twindow.addEventListener( 'message', function ( event ) {\n\t\t\t\tvar data = event.data;\n\n\t\t\t\t// Make sure we're dealing with JSON\n\t\t\t\tif( typeof data === 'string' && data.charAt( 0 ) === '{' && data.charAt( data.length - 1 ) === '}' ) {\n\t\t\t\t\tdata = JSON.parse( data );\n\n\t\t\t\t\t// Check if the requested method can be found\n\t\t\t\t\tif( data.method && typeof Reveal[data.method] === 'function' ) {\n\t\t\t\t\t\tReveal[data.method].apply( Reveal, data.args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, false );\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies the configuration settings from the config\n\t * object. May be called multiple times.\n\t *\n\t * @param {object} options\n\t */\n\tfunction configure( options ) {\n\n\t\tvar oldTransition = config.transition;\n\n\t\t// New config options may be passed when this method\n\t\t// is invoked through the API after initialization\n\t\tif( typeof options === 'object' ) extend( config, options );\n\n\t\t// Abort if reveal.js hasn't finished loading, config\n\t\t// changes will be applied automatically once loading\n\t\t// finishes\n\t\tif( loaded === false ) return;\n\n\t\tvar numberOfSlides = dom.wrapper.querySelectorAll( SLIDES_SELECTOR ).length;\n\n\t\t// Remove the previously configured transition class\n\t\tdom.wrapper.classList.remove( oldTransition );\n\n\t\t// Force linear transition based on browser capabilities\n\t\tif( features.transforms3d === false ) config.transition = 'linear';\n\n\t\tdom.wrapper.classList.add( config.transition );\n\n\t\tdom.wrapper.setAttribute( 'data-transition-speed', config.transitionSpeed );\n\t\tdom.wrapper.setAttribute( 'data-background-transition', config.backgroundTransition );\n\n\t\tdom.controls.style.display = config.controls ? 'block' : 'none';\n\t\tdom.progress.style.display = config.progress ? 'block' : 'none';\n\n\t\tdom.controls.setAttribute( 'data-controls-layout', config.controlsLayout );\n\t\tdom.controls.setAttribute( 'data-controls-back-arrows', config.controlsBackArrows );\n\n\t\tif( config.shuffle ) {\n\t\t\tshuffle();\n\t\t}\n\n\t\tif( config.rtl ) {\n\t\t\tdom.wrapper.classList.add( 'rtl' );\n\t\t}\n\t\telse {\n\t\t\tdom.wrapper.classList.remove( 'rtl' );\n\t\t}\n\n\t\tif( config.center ) {\n\t\t\tdom.wrapper.classList.add( 'center' );\n\t\t}\n\t\telse {\n\t\t\tdom.wrapper.classList.remove( 'center' );\n\t\t}\n\n\t\t// Exit the paused mode if it was configured off\n\t\tif( config.pause === false ) {\n\t\t\tresume();\n\t\t}\n\n\t\tif( config.showNotes ) {\n\t\t\tdom.speakerNotes.setAttribute( 'data-layout', typeof config.showNotes === 'string' ? config.showNotes : 'inline' );\n\t\t}\n\n\t\tif( config.mouseWheel ) {\n\t\t\tdocument.addEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF\n\t\t\tdocument.addEventListener( 'mousewheel', onDocumentMouseScroll, false );\n\t\t}\n\t\telse {\n\t\t\tdocument.removeEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF\n\t\t\tdocument.removeEventListener( 'mousewheel', onDocumentMouseScroll, false );\n\t\t}\n\n\t\t// Rolling 3D links\n\t\tif( config.rollingLinks ) {\n\t\t\tenableRollingLinks();\n\t\t}\n\t\telse {\n\t\t\tdisableRollingLinks();\n\t\t}\n\n\t\t// Iframe link previews\n\t\tif( config.previewLinks ) {\n\t\t\tenablePreviewLinks();\n\t\t\tdisablePreviewLinks( '[data-preview-link=false]' );\n\t\t}\n\t\telse {\n\t\t\tdisablePreviewLinks();\n\t\t\tenablePreviewLinks( '[data-preview-link]:not([data-preview-link=false])' );\n\t\t}\n\n\t\t// Remove existing auto-slide controls\n\t\tif( autoSlidePlayer ) {\n\t\t\tautoSlidePlayer.destroy();\n\t\t\tautoSlidePlayer = null;\n\t\t}\n\n\t\t// Generate auto-slide controls if needed\n\t\tif( numberOfSlides > 1 && config.autoSlide && config.autoSlideStoppable && features.canvas && features.requestAnimationFrame ) {\n\t\t\tautoSlidePlayer = new Playback( dom.wrapper, function() {\n\t\t\t\treturn Math.min( Math.max( ( Date.now() - autoSlideStartTime ) / autoSlide, 0 ), 1 );\n\t\t\t} );\n\n\t\t\tautoSlidePlayer.on( 'click', onAutoSlidePlayerClick );\n\t\t\tautoSlidePaused = false;\n\t\t}\n\n\t\t// When fragments are turned off they should be visible\n\t\tif( config.fragments === false ) {\n\t\t\ttoArray( dom.slides.querySelectorAll( '.fragment' ) ).forEach( function( element ) {\n\t\t\t\telement.classList.add( 'visible' );\n\t\t\t\telement.classList.remove( 'current-fragment' );\n\t\t\t} );\n\t\t}\n\n\t\t// Slide numbers\n\t\tvar slideNumberDisplay = 'none';\n\t\tif( config.slideNumber && !isPrintingPDF() ) {\n\t\t\tif( config.showSlideNumber === 'all' ) {\n\t\t\t\tslideNumberDisplay = 'block';\n\t\t\t}\n\t\t\telse if( config.showSlideNumber === 'speaker' && isSpeakerNotes() ) {\n\t\t\t\tslideNumberDisplay = 'block';\n\t\t\t}\n\t\t}\n\n\t\tdom.slideNumber.style.display = slideNumberDisplay;\n\n\t\tsync();\n\n\t}\n\n\t/**\n\t * Binds all event listeners.\n\t */\n\tfunction addEventListeners() {\n\n\t\teventsAreBound = true;\n\n\t\twindow.addEventListener( 'hashchange', onWindowHashChange, false );\n\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\tif( config.touch ) {\n\t\t\tif( 'onpointerdown' in window ) {\n\t\t\t\t// Use W3C pointer events\n\t\t\t\tdom.wrapper.addEventListener( 'pointerdown', onPointerDown, false );\n\t\t\t\tdom.wrapper.addEventListener( 'pointermove', onPointerMove, false );\n\t\t\t\tdom.wrapper.addEventListener( 'pointerup', onPointerUp, false );\n\t\t\t}\n\t\t\telse if( window.navigator.msPointerEnabled ) {\n\t\t\t\t// IE 10 uses prefixed version of pointer events\n\t\t\t\tdom.wrapper.addEventListener( 'MSPointerDown', onPointerDown, false );\n\t\t\t\tdom.wrapper.addEventListener( 'MSPointerMove', onPointerMove, false );\n\t\t\t\tdom.wrapper.addEventListener( 'MSPointerUp', onPointerUp, false );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fall back to touch events\n\t\t\t\tdom.wrapper.addEventListener( 'touchstart', onTouchStart, false );\n\t\t\t\tdom.wrapper.addEventListener( 'touchmove', onTouchMove, false );\n\t\t\t\tdom.wrapper.addEventListener( 'touchend', onTouchEnd, false );\n\t\t\t}\n\t\t}\n\n\t\tif( config.keyboard ) {\n\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown, false );\n\t\t\tdocument.addEventListener( 'keypress', onDocumentKeyPress, false );\n\t\t}\n\n\t\tif( config.progress && dom.progress ) {\n\t\t\tdom.progress.addEventListener( 'click', onProgressClicked, false );\n\t\t}\n\n\t\tdom.resumeButton.addEventListener( 'click', resume, false );\n\n\t\tif( config.focusBodyOnPageVisibilityChange ) {\n\t\t\tvar visibilityChange;\n\n\t\t\tif( 'hidden' in document ) {\n\t\t\t\tvisibilityChange = 'visibilitychange';\n\t\t\t}\n\t\t\telse if( 'msHidden' in document ) {\n\t\t\t\tvisibilityChange = 'msvisibilitychange';\n\t\t\t}\n\t\t\telse if( 'webkitHidden' in document ) {\n\t\t\t\tvisibilityChange = 'webkitvisibilitychange';\n\t\t\t}\n\n\t\t\tif( visibilityChange ) {\n\t\t\t\tdocument.addEventListener( visibilityChange, onPageVisibilityChange, false );\n\t\t\t}\n\t\t}\n\n\t\t// Listen to both touch and click events, in case the device\n\t\t// supports both\n\t\tvar pointerEvents = [ 'touchstart', 'click' ];\n\n\t\t// Only support touch for Android, fixes double navigations in\n\t\t// stock browser\n\t\tif( UA.match( /android/gi ) ) {\n\t\t\tpointerEvents = [ 'touchstart' ];\n\t\t}\n\n\t\tpointerEvents.forEach( function( eventName ) {\n\t\t\tdom.controlsLeft.forEach( function( el ) { el.addEventListener( eventName, onNavigateLeftClicked, false ); } );\n\t\t\tdom.controlsRight.forEach( function( el ) { el.addEventListener( eventName, onNavigateRightClicked, false ); } );\n\t\t\tdom.controlsUp.forEach( function( el ) { el.addEventListener( eventName, onNavigateUpClicked, false ); } );\n\t\t\tdom.controlsDown.forEach( function( el ) { el.addEventListener( eventName, onNavigateDownClicked, false ); } );\n\t\t\tdom.controlsPrev.forEach( function( el ) { el.addEventListener( eventName, onNavigatePrevClicked, false ); } );\n\t\t\tdom.controlsNext.forEach( function( el ) { el.addEventListener( eventName, onNavigateNextClicked, false ); } );\n\t\t} );\n\n\t}\n\n\t/**\n\t * Unbinds all event listeners.\n\t */\n\tfunction removeEventListeners() {\n\n\t\teventsAreBound = false;\n\n\t\tdocument.removeEventListener( 'keydown', onDocumentKeyDown, false );\n\t\tdocument.removeEventListener( 'keypress', onDocumentKeyPress, false );\n\t\twindow.removeEventListener( 'hashchange', onWindowHashChange, false );\n\t\twindow.removeEventListener( 'resize', onWindowResize, false );\n\n\t\tdom.wrapper.removeEventListener( 'pointerdown', onPointerDown, false );\n\t\tdom.wrapper.removeEventListener( 'pointermove', onPointerMove, false );\n\t\tdom.wrapper.removeEventListener( 'pointerup', onPointerUp, false );\n\n\t\tdom.wrapper.removeEventListener( 'MSPointerDown', onPointerDown, false );\n\t\tdom.wrapper.removeEventListener( 'MSPointerMove', onPointerMove, false );\n\t\tdom.wrapper.removeEventListener( 'MSPointerUp', onPointerUp, false );\n\n\t\tdom.wrapper.removeEventListener( 'touchstart', onTouchStart, false );\n\t\tdom.wrapper.removeEventListener( 'touchmove', onTouchMove, false );\n\t\tdom.wrapper.removeEventListener( 'touchend', onTouchEnd, false );\n\n\t\tdom.resumeButton.removeEventListener( 'click', resume, false );\n\n\t\tif ( config.progress && dom.progress ) {\n\t\t\tdom.progress.removeEventListener( 'click', onProgressClicked, false );\n\t\t}\n\n\t\t[ 'touchstart', 'click' ].forEach( function( eventName ) {\n\t\t\tdom.controlsLeft.forEach( function( el ) { el.removeEventListener( eventName, onNavigateLeftClicked, false ); } );\n\t\t\tdom.controlsRight.forEach( function( el ) { el.removeEventListener( eventName, onNavigateRightClicked, false ); } );\n\t\t\tdom.controlsUp.forEach( function( el ) { el.removeEventListener( eventName, onNavigateUpClicked, false ); } );\n\t\t\tdom.controlsDown.forEach( function( el ) { el.removeEventListener( eventName, onNavigateDownClicked, false ); } );\n\t\t\tdom.controlsPrev.forEach( function( el ) { el.removeEventListener( eventName, onNavigatePrevClicked, false ); } );\n\t\t\tdom.controlsNext.forEach( function( el ) { el.removeEventListener( eventName, onNavigateNextClicked, false ); } );\n\t\t} );\n\n\t}\n\n\t/**\n\t * Add a custom key binding with optional description to\n\t * be added to the help screen.\n\t */\n\tfunction addKeyBinding( binding, callback ) {\n\n\t\tif( typeof binding === 'object' && binding.keyCode ) {\n\t\t\tregisteredKeyBindings[binding.keyCode] = {\n\t\t\t\tcallback: callback,\n\t\t\t\tkey: binding.key,\n\t\t\t\tdescription: binding.description\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\tregisteredKeyBindings[binding] = {\n\t\t\t\tcallback: callback,\n\t\t\t\tkey: null,\n\t\t\t\tdescription: null\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes the specified custom key binding.\n\t */\n\tfunction removeKeyBinding( keyCode ) {\n\n\t\tdelete registeredKeyBindings[keyCode];\n\n\t}\n\n\t/**\n\t * Extend object a with the properties of object b.\n\t * If there's a conflict, object b takes precedence.\n\t *\n\t * @param {object} a\n\t * @param {object} b\n\t */\n\tfunction extend( a, b ) {\n\n\t\tfor( var i in b ) {\n\t\t\ta[ i ] = b[ i ];\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t/**\n\t * Converts the target object to an array.\n\t *\n\t * @param {object} o\n\t * @return {object[]}\n\t */\n\tfunction toArray( o ) {\n\n\t\treturn Array.prototype.slice.call( o );\n\n\t}\n\n\t/**\n\t * Utility for deserializing a value.\n\t *\n\t * @param {*} value\n\t * @return {*}\n\t */\n\tfunction deserialize( value ) {\n\n\t\tif( typeof value === 'string' ) {\n\t\t\tif( value === 'null' ) return null;\n\t\t\telse if( value === 'true' ) return true;\n\t\t\telse if( value === 'false' ) return false;\n\t\t\telse if( value.match( /^-?[\\d\\.]+$/ ) ) return parseFloat( value );\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Measures the distance in pixels between point a\n\t * and point b.\n\t *\n\t * @param {object} a point with x/y properties\n\t * @param {object} b point with x/y properties\n\t *\n\t * @return {number}\n\t */\n\tfunction distanceBetween( a, b ) {\n\n\t\tvar dx = a.x - b.x,\n\t\t\tdy = a.y - b.y;\n\n\t\treturn Math.sqrt( dx*dx + dy*dy );\n\n\t}\n\n\t/**\n\t * Applies a CSS transform to the target element.\n\t *\n\t * @param {HTMLElement} element\n\t * @param {string} transform\n\t */\n\tfunction transformElement( element, transform ) {\n\n\t\telement.style.WebkitTransform = transform;\n\t\telement.style.MozTransform = transform;\n\t\telement.style.msTransform = transform;\n\t\telement.style.transform = transform;\n\n\t}\n\n\t/**\n\t * Applies CSS transforms to the slides container. The container\n\t * is transformed from two separate sources: layout and the overview\n\t * mode.\n\t *\n\t * @param {object} transforms\n\t */\n\tfunction transformSlides( transforms ) {\n\n\t\t// Pick up new transforms from arguments\n\t\tif( typeof transforms.layout === 'string' ) slidesTransform.layout = transforms.layout;\n\t\tif( typeof transforms.overview === 'string' ) slidesTransform.overview = transforms.overview;\n\n\t\t// Apply the transforms to the slides container\n\t\tif( slidesTransform.layout ) {\n\t\t\ttransformElement( dom.slides, slidesTransform.layout + ' ' + slidesTransform.overview );\n\t\t}\n\t\telse {\n\t\t\ttransformElement( dom.slides, slidesTransform.overview );\n\t\t}\n\n\t}\n\n\t/**\n\t * Injects the given CSS styles into the DOM.\n\t *\n\t * @param {string} value\n\t */\n\tfunction injectStyleSheet( value ) {\n\n\t\tvar tag = document.createElement( 'style' );\n\t\ttag.type = 'text/css';\n\t\tif( tag.styleSheet ) {\n\t\t\ttag.styleSheet.cssText = value;\n\t\t}\n\t\telse {\n\t\t\ttag.appendChild( document.createTextNode( value ) );\n\t\t}\n\t\tdocument.getElementsByTagName( 'head' )[0].appendChild( tag );\n\n\t}\n\n\t/**\n\t * Find the closest parent that matches the given\n\t * selector.\n\t *\n\t * @param {HTMLElement} target The child element\n\t * @param {String} selector The CSS selector to match\n\t * the parents against\n\t *\n\t * @return {HTMLElement} The matched parent or null\n\t * if no matching parent was found\n\t */\n\tfunction closestParent( target, selector ) {\n\n\t\tvar parent = target.parentNode;\n\n\t\twhile( parent ) {\n\n\t\t\t// There's some overhead doing this each time, we don't\n\t\t\t// want to rewrite the element prototype but should still\n\t\t\t// be enough to feature detect once at startup...\n\t\t\tvar matchesMethod = parent.matches || parent.matchesSelector || parent.msMatchesSelector;\n\n\t\t\t// If we find a match, we're all set\n\t\t\tif( matchesMethod && matchesMethod.call( parent, selector ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Keep searching\n\t\t\tparent = parent.parentNode;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Converts various color input formats to an {r:0,g:0,b:0} object.\n\t *\n\t * @param {string} color The string representation of a color\n\t * @example\n\t * colorToRgb('#000');\n\t * @example\n\t * colorToRgb('#000000');\n\t * @example\n\t * colorToRgb('rgb(0,0,0)');\n\t * @example\n\t * colorToRgb('rgba(0,0,0)');\n\t *\n\t * @return {{r: number, g: number, b: number, [a]: number}|null}\n\t */\n\tfunction colorToRgb( color ) {\n\n\t\tvar hex3 = color.match( /^#([0-9a-f]{3})$/i );\n\t\tif( hex3 && hex3[1] ) {\n\t\t\thex3 = hex3[1];\n\t\t\treturn {\n\t\t\t\tr: parseInt( hex3.charAt( 0 ), 16 ) * 0x11,\n\t\t\t\tg: parseInt( hex3.charAt( 1 ), 16 ) * 0x11,\n\t\t\t\tb: parseInt( hex3.charAt( 2 ), 16 ) * 0x11\n\t\t\t};\n\t\t}\n\n\t\tvar hex6 = color.match( /^#([0-9a-f]{6})$/i );\n\t\tif( hex6 && hex6[1] ) {\n\t\t\thex6 = hex6[1];\n\t\t\treturn {\n\t\t\t\tr: parseInt( hex6.substr( 0, 2 ), 16 ),\n\t\t\t\tg: parseInt( hex6.substr( 2, 2 ), 16 ),\n\t\t\t\tb: parseInt( hex6.substr( 4, 2 ), 16 )\n\t\t\t};\n\t\t}\n\n\t\tvar rgb = color.match( /^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i );\n\t\tif( rgb ) {\n\t\t\treturn {\n\t\t\t\tr: parseInt( rgb[1], 10 ),\n\t\t\t\tg: parseInt( rgb[2], 10 ),\n\t\t\t\tb: parseInt( rgb[3], 10 )\n\t\t\t};\n\t\t}\n\n\t\tvar rgba = color.match( /^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\,\\s*([\\d]+|[\\d]*.[\\d]+)\\s*\\)$/i );\n\t\tif( rgba ) {\n\t\t\treturn {\n\t\t\t\tr: parseInt( rgba[1], 10 ),\n\t\t\t\tg: parseInt( rgba[2], 10 ),\n\t\t\t\tb: parseInt( rgba[3], 10 ),\n\t\t\t\ta: parseFloat( rgba[4] )\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Calculates brightness on a scale of 0-255.\n\t *\n\t * @param {string} color See colorToRgb for supported formats.\n\t * @see {@link colorToRgb}\n\t */\n\tfunction colorBrightness( color ) {\n\n\t\tif( typeof color === 'string' ) color = colorToRgb( color );\n\n\t\tif( color ) {\n\t\t\treturn ( color.r * 299 + color.g * 587 + color.b * 114 ) / 1000;\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the remaining height within the parent of the\n\t * target element.\n\t *\n\t * remaining height = [ configured parent height ] - [ current parent height ]\n\t *\n\t * @param {HTMLElement} element\n\t * @param {number} [height]\n\t */\n\tfunction getRemainingHeight( element, height ) {\n\n\t\theight = height || 0;\n\n\t\tif( element ) {\n\t\t\tvar newHeight, oldHeight = element.style.height;\n\n\t\t\t// Change the .stretch element height to 0 in order find the height of all\n\t\t\t// the other elements\n\t\t\telement.style.height = '0px';\n\t\t\tnewHeight = height - element.parentNode.offsetHeight;\n\n\t\t\t// Restore the old height, just in case\n\t\t\telement.style.height = oldHeight + 'px';\n\n\t\t\treturn newHeight;\n\t\t}\n\n\t\treturn height;\n\n\t}\n\n\t/**\n\t * Checks if this instance is being used to print a PDF.\n\t */\n\tfunction isPrintingPDF() {\n\n\t\treturn ( /print-pdf/gi ).test( window.location.search );\n\n\t}\n\n\t/**\n\t * Check if this instance is being used to print a PDF with fragments.\n\t */\n\tfunction isPrintingPDFFragments() {\n\n\t\treturn ( /print-pdf-fragments/gi ).test( window.location.search );\n\n\t}\n\n\t/**\n\t * Hides the address bar if we're on a mobile device.\n\t */\n\tfunction hideAddressBar() {\n\n\t\tif( config.hideAddressBar && isMobileDevice ) {\n\t\t\t// Events that should trigger the address bar to hide\n\t\t\twindow.addEventListener( 'load', removeAddressBar, false );\n\t\t\twindow.addEventListener( 'orientationchange', removeAddressBar, false );\n\t\t}\n\n\t}\n\n\t/**\n\t * Causes the address bar to hide on mobile devices,\n\t * more vertical space ftw.\n\t */\n\tfunction removeAddressBar() {\n\n\t\tsetTimeout( function() {\n\t\t\twindow.scrollTo( 0, 1 );\n\t\t}, 10 );\n\n\t}\n\n\t/**\n\t * Dispatches an event of the specified type from the\n\t * reveal DOM element.\n\t */\n\tfunction dispatchEvent( type, args ) {\n\n\t\tvar event = document.createEvent( 'HTMLEvents', 1, 2 );\n\t\tevent.initEvent( type, true, true );\n\t\textend( event, args );\n\t\tdom.wrapper.dispatchEvent( event );\n\n\t\t// If we're in an iframe, post each reveal.js event to the\n\t\t// parent window. Used by the notes plugin\n\t\tif( config.postMessageEvents && window.parent !== window.self ) {\n\t\t\twindow.parent.postMessage( JSON.stringify({ namespace: 'reveal', eventName: type, state: getState() }), '*' );\n\t\t}\n\n\t}\n\n\t/**\n\t * Wrap all links in 3D goodness.\n\t */\n\tfunction enableRollingLinks() {\n\n\t\tif( features.transforms3d && !( 'msPerspective' in document.body.style ) ) {\n\t\t\tvar anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a' );\n\n\t\t\tfor( var i = 0, len = anchors.length; i < len; i++ ) {\n\t\t\t\tvar anchor = anchors[i];\n\n\t\t\t\tif( anchor.textContent && !anchor.querySelector( '*' ) && ( !anchor.className || !anchor.classList.contains( anchor, 'roll' ) ) ) {\n\t\t\t\t\tvar span = document.createElement('span');\n\t\t\t\t\tspan.setAttribute('data-title', anchor.text);\n\t\t\t\t\tspan.innerHTML = anchor.innerHTML;\n\n\t\t\t\t\tanchor.classList.add( 'roll' );\n\t\t\t\t\tanchor.innerHTML = '';\n\t\t\t\t\tanchor.appendChild(span);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Unwrap all 3D links.\n\t */\n\tfunction disableRollingLinks() {\n\n\t\tvar anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a.roll' );\n\n\t\tfor( var i = 0, len = anchors.length; i < len; i++ ) {\n\t\t\tvar anchor = anchors[i];\n\t\t\tvar span = anchor.querySelector( 'span' );\n\n\t\t\tif( span ) {\n\t\t\t\tanchor.classList.remove( 'roll' );\n\t\t\t\tanchor.innerHTML = span.innerHTML;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Bind preview frame links.\n\t *\n\t * @param {string} [selector=a] - selector for anchors\n\t */\n\tfunction enablePreviewLinks( selector ) {\n\n\t\tvar anchors = toArray( document.querySelectorAll( selector ? selector : 'a' ) );\n\n\t\tanchors.forEach( function( element ) {\n\t\t\tif( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {\n\t\t\t\telement.addEventListener( 'click', onPreviewLinkClicked, false );\n\t\t\t}\n\t\t} );\n\n\t}\n\n\t/**\n\t * Unbind preview frame links.\n\t */\n\tfunction disablePreviewLinks( selector ) {\n\n\t\tvar anchors = toArray( document.querySelectorAll( selector ? selector : 'a' ) );\n\n\t\tanchors.forEach( function( element ) {\n\t\t\tif( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {\n\t\t\t\telement.removeEventListener( 'click', onPreviewLinkClicked, false );\n\t\t\t}\n\t\t} );\n\n\t}\n\n\t/**\n\t * Opens a preview window for the target URL.\n\t *\n\t * @param {string} url - url for preview iframe src\n\t */\n\tfunction showPreview( url ) {\n\n\t\tcloseOverlay();\n\n\t\tdom.overlay = document.createElement( 'div' );\n\t\tdom.overlay.classList.add( 'overlay' );\n\t\tdom.overlay.classList.add( 'overlay-preview' );\n\t\tdom.wrapper.appendChild( dom.overlay );\n\n\t\tdom.overlay.innerHTML = [\n\t\t\t'<header>',\n\t\t\t\t'<a class=\"close\" href=\"#\"><span class=\"icon\"></span></a>',\n\t\t\t\t'<a class=\"external\" href=\"'+ url +'\" target=\"_blank\"><span class=\"icon\"></span></a>',\n\t\t\t'</header>',\n\t\t\t'<div class=\"spinner\"></div>',\n\t\t\t'<div class=\"viewport\">',\n\t\t\t\t'<iframe src=\"'+ url +'\"></iframe>',\n\t\t\t\t'<small class=\"viewport-inner\">',\n\t\t\t\t\t'<span class=\"x-frame-error\">Unable to load iframe. This is likely due to the site\\'s policy (x-frame-options).</span>',\n\t\t\t\t'</small>',\n\t\t\t'</div>'\n\t\t].join('');\n\n\t\tdom.overlay.querySelector( 'iframe' ).addEventListener( 'load', function( event ) {\n\t\t\tdom.overlay.classList.add( 'loaded' );\n\t\t}, false );\n\n\t\tdom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {\n\t\t\tcloseOverlay();\n\t\t\tevent.preventDefault();\n\t\t}, false );\n\n\t\tdom.overlay.querySelector( '.external' ).addEventListener( 'click', function( event ) {\n\t\t\tcloseOverlay();\n\t\t}, false );\n\n\t\tsetTimeout( function() {\n\t\t\tdom.overlay.classList.add( 'visible' );\n\t\t}, 1 );\n\n\t}\n\n\t/**\n\t * Open or close help overlay window.\n\t *\n\t * @param {Boolean} [override] Flag which overrides the\n\t * toggle logic and forcibly sets the desired state. True means\n\t * help is open, false means it's closed.\n\t */\n\tfunction toggleHelp( override ){\n\n\t\tif( typeof override === 'boolean' ) {\n\t\t\toverride ? showHelp() : closeOverlay();\n\t\t}\n\t\telse {\n\t\t\tif( dom.overlay ) {\n\t\t\t\tcloseOverlay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tshowHelp();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Opens an overlay window with help material.\n\t */\n\tfunction showHelp() {\n\n\t\tif( config.help ) {\n\n\t\t\tcloseOverlay();\n\n\t\t\tdom.overlay = document.createElement( 'div' );\n\t\t\tdom.overlay.classList.add( 'overlay' );\n\t\t\tdom.overlay.classList.add( 'overlay-help' );\n\t\t\tdom.wrapper.appendChild( dom.overlay );\n\n\t\t\tvar html = '<p class=\"title\">Keyboard Shortcuts</p><br/>';\n\n\t\t\thtml += '<table><th>KEY</th><th>ACTION</th>';\n\t\t\tfor( var key in keyboardShortcuts ) {\n\t\t\t\thtml += '<tr><td>' + key + '</td><td>' + keyboardShortcuts[ key ] + '</td></tr>';\n\t\t\t}\n\n\t\t\t// Add custom key bindings that have associated descriptions\n\t\t\tfor( var binding in registeredKeyBindings ) {\n\t\t\t\tif( registeredKeyBindings[binding].key && registeredKeyBindings[binding].description ) {\n\t\t\t\t\thtml += '<tr><td>' + registeredKeyBindings[binding].key + '</td><td>' + registeredKeyBindings[binding].description + '</td></tr>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thtml += '</table>';\n\n\t\t\tdom.overlay.innerHTML = [\n\t\t\t\t'<header>',\n\t\t\t\t\t'<a class=\"close\" href=\"#\"><span class=\"icon\"></span></a>',\n\t\t\t\t'</header>',\n\t\t\t\t'<div class=\"viewport\">',\n\t\t\t\t\t'<div class=\"viewport-inner\">'+ html +'</div>',\n\t\t\t\t'</div>'\n\t\t\t].join('');\n\n\t\t\tdom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {\n\t\t\t\tcloseOverlay();\n\t\t\t\tevent.preventDefault();\n\t\t\t}, false );\n\n\t\t\tsetTimeout( function() {\n\t\t\t\tdom.overlay.classList.add( 'visible' );\n\t\t\t}, 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Closes any currently open overlay.\n\t */\n\tfunction closeOverlay() {\n\n\t\tif( dom.overlay ) {\n\t\t\tdom.overlay.parentNode.removeChild( dom.overlay );\n\t\t\tdom.overlay = null;\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies JavaScript-controlled layout rules to the\n\t * presentation.\n\t */\n\tfunction layout() {\n\n\t\tif( dom.wrapper && !isPrintingPDF() ) {\n\n\t\t\tif( !config.disableLayout ) {\n\n\t\t\t\tvar size = getComputedSlideSize();\n\n\t\t\t\t// Layout the contents of the slides\n\t\t\t\tlayoutSlideContents( config.width, config.height );\n\n\t\t\t\tdom.slides.style.width = size.width + 'px';\n\t\t\t\tdom.slides.style.height = size.height + 'px';\n\n\t\t\t\t// Determine scale of content to fit within available space\n\t\t\t\tscale = Math.min( size.presentationWidth / size.width, size.presentationHeight / size.height );\n\n\t\t\t\t// Respect max/min scale settings\n\t\t\t\tscale = Math.max( scale, config.minScale );\n\t\t\t\tscale = Math.min( scale, config.maxScale );\n\n\t\t\t\t// Don't apply any scaling styles if scale is 1\n\t\t\t\tif( scale === 1 ) {\n\t\t\t\t\tdom.slides.style.zoom = '';\n\t\t\t\t\tdom.slides.style.left = '';\n\t\t\t\t\tdom.slides.style.top = '';\n\t\t\t\t\tdom.slides.style.bottom = '';\n\t\t\t\t\tdom.slides.style.right = '';\n\t\t\t\t\ttransformSlides( { layout: '' } );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Prefer zoom for scaling up so that content remains crisp.\n\t\t\t\t\t// Don't use zoom to scale down since that can lead to shifts\n\t\t\t\t\t// in text layout/line breaks.\n\t\t\t\t\tif( scale > 1 && features.zoom ) {\n\t\t\t\t\t\tdom.slides.style.zoom = scale;\n\t\t\t\t\t\tdom.slides.style.left = '';\n\t\t\t\t\t\tdom.slides.style.top = '';\n\t\t\t\t\t\tdom.slides.style.bottom = '';\n\t\t\t\t\t\tdom.slides.style.right = '';\n\t\t\t\t\t\ttransformSlides( { layout: '' } );\n\t\t\t\t\t}\n\t\t\t\t\t// Apply scale transform as a fallback\n\t\t\t\t\telse {\n\t\t\t\t\t\tdom.slides.style.zoom = '';\n\t\t\t\t\t\tdom.slides.style.left = '50%';\n\t\t\t\t\t\tdom.slides.style.top = '50%';\n\t\t\t\t\t\tdom.slides.style.bottom = 'auto';\n\t\t\t\t\t\tdom.slides.style.right = 'auto';\n\t\t\t\t\t\ttransformSlides( { layout: 'translate(-50%, -50%) scale('+ scale +')' } );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Select all slides, vertical and horizontal\n\t\t\t\tvar slides = toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) );\n\n\t\t\t\tfor( var i = 0, len = slides.length; i < len; i++ ) {\n\t\t\t\t\tvar slide = slides[ i ];\n\n\t\t\t\t\t// Don't bother updating invisible slides\n\t\t\t\t\tif( slide.style.display === 'none' ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( config.center || slide.classList.contains( 'center' ) ) {\n\t\t\t\t\t\t// Vertical stacks are not centred since their section\n\t\t\t\t\t\t// children will be\n\t\t\t\t\t\tif( slide.classList.contains( 'stack' ) ) {\n\t\t\t\t\t\t\tslide.style.top = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tslide.style.top = Math.max( ( size.height - slide.scrollHeight ) / 2, 0 ) + 'px';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tslide.style.top = '';\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tupdateProgress();\n\t\t\tupdateParallax();\n\n\t\t\tif( isOverview() ) {\n\t\t\t\tupdateOverview();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies layout logic to the contents of all slides in\n\t * the presentation.\n\t *\n\t * @param {string|number} width\n\t * @param {string|number} height\n\t */\n\tfunction layoutSlideContents( width, height ) {\n\n\t\t// Handle sizing of elements with the 'stretch' class\n\t\ttoArray( dom.slides.querySelectorAll( 'section > .stretch' ) ).forEach( function( element ) {\n\n\t\t\t// Determine how much vertical space we can use\n\t\t\tvar remainingHeight = getRemainingHeight( element, height );\n\n\t\t\t// Consider the aspect ratio of media elements\n\t\t\tif( /(img|video)/gi.test( element.nodeName ) ) {\n\t\t\t\tvar nw = element.naturalWidth || element.videoWidth,\n\t\t\t\t\tnh = element.naturalHeight || element.videoHeight;\n\n\t\t\t\tvar es = Math.min( width / nw, remainingHeight / nh );\n\n\t\t\t\telement.style.width = ( nw * es ) + 'px';\n\t\t\t\telement.style.height = ( nh * es ) + 'px';\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.style.width = width + 'px';\n\t\t\t\telement.style.height = remainingHeight + 'px';\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Calculates the computed pixel size of our slides. These\n\t * values are based on the width and height configuration\n\t * options.\n\t *\n\t * @param {number} [presentationWidth=dom.wrapper.offsetWidth]\n\t * @param {number} [presentationHeight=dom.wrapper.offsetHeight]\n\t */\n\tfunction getComputedSlideSize( presentationWidth, presentationHeight ) {\n\n\t\tvar size = {\n\t\t\t// Slide size\n\t\t\twidth: config.width,\n\t\t\theight: config.height,\n\n\t\t\t// Presentation size\n\t\t\tpresentationWidth: presentationWidth || dom.wrapper.offsetWidth,\n\t\t\tpresentationHeight: presentationHeight || dom.wrapper.offsetHeight\n\t\t};\n\n\t\t// Reduce available space by margin\n\t\tsize.presentationWidth -= ( size.presentationWidth * config.margin );\n\t\tsize.presentationHeight -= ( size.presentationHeight * config.margin );\n\n\t\t// Slide width may be a percentage of available width\n\t\tif( typeof size.width === 'string' && /%$/.test( size.width ) ) {\n\t\t\tsize.width = parseInt( size.width, 10 ) / 100 * size.presentationWidth;\n\t\t}\n\n\t\t// Slide height may be a percentage of available height\n\t\tif( typeof size.height === 'string' && /%$/.test( size.height ) ) {\n\t\t\tsize.height = parseInt( size.height, 10 ) / 100 * size.presentationHeight;\n\t\t}\n\n\t\treturn size;\n\n\t}\n\n\t/**\n\t * Stores the vertical index of a stack so that the same\n\t * vertical slide can be selected when navigating to and\n\t * from the stack.\n\t *\n\t * @param {HTMLElement} stack The vertical stack element\n\t * @param {string|number} [v=0] Index to memorize\n\t */\n\tfunction setPreviousVerticalIndex( stack, v ) {\n\n\t\tif( typeof stack === 'object' && typeof stack.setAttribute === 'function' ) {\n\t\t\tstack.setAttribute( 'data-previous-indexv', v || 0 );\n\t\t}\n\n\t}\n\n\t/**\n\t * Retrieves the vertical index which was stored using\n\t * #setPreviousVerticalIndex() or 0 if no previous index\n\t * exists.\n\t *\n\t * @param {HTMLElement} stack The vertical stack element\n\t */\n\tfunction getPreviousVerticalIndex( stack ) {\n\n\t\tif( typeof stack === 'object' && typeof stack.setAttribute === 'function' && stack.classList.contains( 'stack' ) ) {\n\t\t\t// Prefer manually defined start-indexv\n\t\t\tvar attributeName = stack.hasAttribute( 'data-start-indexv' ) ? 'data-start-indexv' : 'data-previous-indexv';\n\n\t\t\treturn parseInt( stack.getAttribute( attributeName ) || 0, 10 );\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Displays the overview of slides (quick nav) by scaling\n\t * down and arranging all slide elements.\n\t */\n\tfunction activateOverview() {\n\n\t\t// Only proceed if enabled in config\n\t\tif( config.overview && !isOverview() ) {\n\n\t\t\toverview = true;\n\n\t\t\tdom.wrapper.classList.add( 'overview' );\n\t\t\tdom.wrapper.classList.remove( 'overview-deactivating' );\n\n\t\t\tif( features.overviewTransitions ) {\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tdom.wrapper.classList.add( 'overview-animated' );\n\t\t\t\t}, 1 );\n\t\t\t}\n\n\t\t\t// Don't auto-slide while in overview mode\n\t\t\tcancelAutoSlide();\n\n\t\t\t// Move the backgrounds element into the slide container to\n\t\t\t// that the same scaling is applied\n\t\t\tdom.slides.appendChild( dom.background );\n\n\t\t\t// Clicking on an overview slide navigates to it\n\t\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {\n\t\t\t\tif( !slide.classList.contains( 'stack' ) ) {\n\t\t\t\t\tslide.addEventListener( 'click', onOverviewSlideClicked, true );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Calculate slide sizes\n\t\t\tvar margin = 70;\n\t\t\tvar slideSize = getComputedSlideSize();\n\t\t\toverviewSlideWidth = slideSize.width + margin;\n\t\t\toverviewSlideHeight = slideSize.height + margin;\n\n\t\t\t// Reverse in RTL mode\n\t\t\tif( config.rtl ) {\n\t\t\t\toverviewSlideWidth = -overviewSlideWidth;\n\t\t\t}\n\n\t\t\tupdateSlidesVisibility();\n\t\t\tlayoutOverview();\n\t\t\tupdateOverview();\n\n\t\t\tlayout();\n\n\t\t\t// Notify observers of the overview showing\n\t\t\tdispatchEvent( 'overviewshown', {\n\t\t\t\t'indexh': indexh,\n\t\t\t\t'indexv': indexv,\n\t\t\t\t'currentSlide': currentSlide\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uses CSS transforms to position all slides in a grid for\n\t * display inside of the overview mode.\n\t */\n\tfunction layoutOverview() {\n\n\t\t// Layout slides\n\t\ttoArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( hslide, h ) {\n\t\t\thslide.setAttribute( 'data-index-h', h );\n\t\t\ttransformElement( hslide, 'translate3d(' + ( h * overviewSlideWidth ) + 'px, 0, 0)' );\n\n\t\t\tif( hslide.classList.contains( 'stack' ) ) {\n\n\t\t\t\ttoArray( hslide.querySelectorAll( 'section' ) ).forEach( function( vslide, v ) {\n\t\t\t\t\tvslide.setAttribute( 'data-index-h', h );\n\t\t\t\t\tvslide.setAttribute( 'data-index-v', v );\n\n\t\t\t\t\ttransformElement( vslide, 'translate3d(0, ' + ( v * overviewSlideHeight ) + 'px, 0)' );\n\t\t\t\t} );\n\n\t\t\t}\n\t\t} );\n\n\t\t// Layout slide backgrounds\n\t\ttoArray( dom.background.childNodes ).forEach( function( hbackground, h ) {\n\t\t\ttransformElement( hbackground, 'translate3d(' + ( h * overviewSlideWidth ) + 'px, 0, 0)' );\n\n\t\t\ttoArray( hbackground.querySelectorAll( '.slide-background' ) ).forEach( function( vbackground, v ) {\n\t\t\t\ttransformElement( vbackground, 'translate3d(0, ' + ( v * overviewSlideHeight ) + 'px, 0)' );\n\t\t\t} );\n\t\t} );\n\n\t}\n\n\t/**\n\t * Moves the overview viewport to the current slides.\n\t * Called each time the current slide changes.\n\t */\n\tfunction updateOverview() {\n\n\t\tvar vmin = Math.min( window.innerWidth, window.innerHeight );\n\t\tvar scale = Math.max( vmin / 5, 150 ) / vmin;\n\n\t\ttransformSlides( {\n\t\t\toverview: [\n\t\t\t\t'scale('+ scale +')',\n\t\t\t\t'translateX('+ ( -indexh * overviewSlideWidth ) +'px)',\n\t\t\t\t'translateY('+ ( -indexv * overviewSlideHeight ) +'px)'\n\t\t\t].join( ' ' )\n\t\t} );\n\n\t}\n\n\t/**\n\t * Exits the slide overview and enters the currently\n\t * active slide.\n\t */\n\tfunction deactivateOverview() {\n\n\t\t// Only proceed if enabled in config\n\t\tif( config.overview ) {\n\n\t\t\toverview = false;\n\n\t\t\tdom.wrapper.classList.remove( 'overview' );\n\t\t\tdom.wrapper.classList.remove( 'overview-animated' );\n\n\t\t\t// Temporarily add a class so that transitions can do different things\n\t\t\t// depending on whether they are exiting/entering overview, or just\n\t\t\t// moving from slide to slide\n\t\t\tdom.wrapper.classList.add( 'overview-deactivating' );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tdom.wrapper.classList.remove( 'overview-deactivating' );\n\t\t\t}, 1 );\n\n\t\t\t// Move the background element back out\n\t\t\tdom.wrapper.appendChild( dom.background );\n\n\t\t\t// Clean up changes made to slides\n\t\t\ttoArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {\n\t\t\t\ttransformElement( slide, '' );\n\n\t\t\t\tslide.removeEventListener( 'click', onOverviewSlideClicked, true );\n\t\t\t} );\n\n\t\t\t// Clean up changes made to backgrounds\n\t\t\ttoArray( dom.background.querySelectorAll( '.slide-background' ) ).forEach( function( background ) {\n\t\t\t\ttransformElement( background, '' );\n\t\t\t} );\n\n\t\t\ttransformSlides( { overview: '' } );\n\n\t\t\tslide( indexh, indexv );\n\n\t\t\tlayout();\n\n\t\t\tcueAutoSlide();\n\n\t\t\t// Notify observers of the overview hiding\n\t\t\tdispatchEvent( 'overviewhidden', {\n\t\t\t\t'indexh': indexh,\n\t\t\t\t'indexv': indexv,\n\t\t\t\t'currentSlide': currentSlide\n\t\t\t} );\n\n\t\t}\n\t}\n\n\t/**\n\t * Toggles the slide overview mode on and off.\n\t *\n\t * @param {Boolean} [override] Flag which overrides the\n\t * toggle logic and forcibly sets the desired state. True means\n\t * overview is open, false means it's closed.\n\t */\n\tfunction toggleOverview( override ) {\n\n\t\tif( typeof override === 'boolean' ) {\n\t\t\toverride ? activateOverview() : deactivateOverview();\n\t\t}\n\t\telse {\n\t\t\tisOverview() ? deactivateOverview() : activateOverview();\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the overview is currently active.\n\t *\n\t * @return {Boolean} true if the overview is active,\n\t * false otherwise\n\t */\n\tfunction isOverview() {\n\n\t\treturn overview;\n\n\t}\n\n\t/**\n\t * Return a hash URL that will resolve to the current slide location.\n\t */\n\tfunction locationHash() {\n\n\t\tvar url = '/';\n\n\t\t// Attempt to create a named link based on the slide's ID\n\t\tvar id = currentSlide ? currentSlide.getAttribute( 'id' ) : null;\n\t\tif( id ) {\n\t\t\tid = encodeURIComponent( id );\n\t\t}\n\n\t\tvar indexf;\n\t\tif( config.fragmentInURL ) {\n\t\t\tindexf = getIndices().f;\n\t\t}\n\n\t\t// If the current slide has an ID, use that as a named link,\n\t\t// but we don't support named links with a fragment index\n\t\tif( typeof id === 'string' && id.length && indexf === undefined ) {\n\t\t\turl = '/' + id;\n\t\t}\n\t\t// Otherwise use the /h/v index\n\t\telse {\n\t\t\tvar hashIndexBase = config.hashOneBasedIndex ? 1 : 0;\n\t\t\tif( indexh > 0 || indexv > 0 || indexf !== undefined ) url += indexh + hashIndexBase;\n\t\t\tif( indexv > 0 || indexf !== undefined ) url += '/' + (indexv + hashIndexBase );\n\t\t\tif( indexf !== undefined ) url += '/' + indexf;\n\t\t}\n\n\t\treturn url;\n\n\t}\n\n\t/**\n\t * Checks if the current or specified slide is vertical\n\t * (nested within another slide).\n\t *\n\t * @param {HTMLElement} [slide=currentSlide] The slide to check\n\t * orientation of\n\t * @return {Boolean}\n\t */\n\tfunction isVerticalSlide( slide ) {\n\n\t\t// Prefer slide argument, otherwise use current slide\n\t\tslide = slide ? slide : currentSlide;\n\n\t\treturn slide && slide.parentNode && !!slide.parentNode.nodeName.match( /section/i );\n\n\t}\n\n\t/**\n\t * Handling the fullscreen functionality via the fullscreen API\n\t *\n\t * @see http://fullscreen.spec.whatwg.org/\n\t * @see https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode\n\t */\n\tfunction enterFullscreen() {\n\n\t\tvar element = document.documentElement;\n\n\t\t// Check which implementation is available\n\t\tvar requestMethod = element.requestFullscreen ||\n\t\t\t\t\t\t\telement.webkitRequestFullscreen ||\n\t\t\t\t\t\t\telement.webkitRequestFullScreen ||\n\t\t\t\t\t\t\telement.mozRequestFullScreen ||\n\t\t\t\t\t\t\telement.msRequestFullscreen;\n\n\t\tif( requestMethod ) {\n\t\t\trequestMethod.apply( element );\n\t\t}\n\n\t}\n\n\t/**\n\t * Enters the paused mode which fades everything on screen to\n\t * black.\n\t */\n\tfunction pause() {\n\n\t\tif( config.pause ) {\n\t\t\tvar wasPaused = dom.wrapper.classList.contains( 'paused' );\n\n\t\t\tcancelAutoSlide();\n\t\t\tdom.wrapper.classList.add( 'paused' );\n\n\t\t\tif( wasPaused === false ) {\n\t\t\t\tdispatchEvent( 'paused' );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Exits from the paused mode.\n\t */\n\tfunction resume() {\n\n\t\tvar wasPaused = dom.wrapper.classList.contains( 'paused' );\n\t\tdom.wrapper.classList.remove( 'paused' );\n\n\t\tcueAutoSlide();\n\n\t\tif( wasPaused ) {\n\t\t\tdispatchEvent( 'resumed' );\n\t\t}\n\n\t}\n\n\t/**\n\t * Toggles the paused mode on and off.\n\t */\n\tfunction togglePause( override ) {\n\n\t\tif( typeof override === 'boolean' ) {\n\t\t\toverride ? pause() : resume();\n\t\t}\n\t\telse {\n\t\t\tisPaused() ? resume() : pause();\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if we are currently in the paused mode.\n\t *\n\t * @return {Boolean}\n\t */\n\tfunction isPaused() {\n\n\t\treturn dom.wrapper.classList.contains( 'paused' );\n\n\t}\n\n\t/**\n\t * Toggles the auto slide mode on and off.\n\t *\n\t * @param {Boolean} [override] Flag which sets the desired state.\n\t * True means autoplay starts, false means it stops.\n\t */\n\n\tfunction toggleAutoSlide( override ) {\n\n\t\tif( typeof override === 'boolean' ) {\n\t\t\toverride ? resumeAutoSlide() : pauseAutoSlide();\n\t\t}\n\n\t\telse {\n\t\t\tautoSlidePaused ? resumeAutoSlide() : pauseAutoSlide();\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the auto slide mode is currently on.\n\t *\n\t * @return {Boolean}\n\t */\n\tfunction isAutoSliding() {\n\n\t\treturn !!( autoSlide && !autoSlidePaused );\n\n\t}\n\n\t/**\n\t * Steps from the current point in the presentation to the\n\t * slide which matches the specified horizontal and vertical\n\t * indices.\n\t *\n\t * @param {number} [h=indexh] Horizontal index of the target slide\n\t * @param {number} [v=indexv] Vertical index of the target slide\n\t * @param {number} [f] Index of a fragment within the\n\t * target slide to activate\n\t * @param {number} [o] Origin for use in multimaster environments\n\t */\n\tfunction slide( h, v, f, o ) {\n\n\t\t// Remember where we were at before\n\t\tpreviousSlide = currentSlide;\n\n\t\t// Query all horizontal slides in the deck\n\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );\n\n\t\t// Abort if there are no slides\n\t\tif( horizontalSlides.length === 0 ) return;\n\n\t\t// If no vertical index is specified and the upcoming slide is a\n\t\t// stack, resume at its previous vertical index\n\t\tif( v === undefined && !isOverview() ) {\n\t\t\tv = getPreviousVerticalIndex( horizontalSlides[ h ] );\n\t\t}\n\n\t\t// If we were on a vertical stack, remember what vertical index\n\t\t// it was on so we can resume at the same position when returning\n\t\tif( previousSlide && previousSlide.parentNode && previousSlide.parentNode.classList.contains( 'stack' ) ) {\n\t\t\tsetPreviousVerticalIndex( previousSlide.parentNode, indexv );\n\t\t}\n\n\t\t// Remember the state before this slide\n\t\tvar stateBefore = state.concat();\n\n\t\t// Reset the state array\n\t\tstate.length = 0;\n\n\t\tvar indexhBefore = indexh || 0,\n\t\t\tindexvBefore = indexv || 0;\n\n\t\t// Activate and transition to the new slide\n\t\tindexh = updateSlides( HORIZONTAL_SLIDES_SELECTOR, h === undefined ? indexh : h );\n\t\tindexv = updateSlides( VERTICAL_SLIDES_SELECTOR, v === undefined ? indexv : v );\n\n\t\t// Update the visibility of slides now that the indices have changed\n\t\tupdateSlidesVisibility();\n\n\t\tlayout();\n\n\t\t// Apply the new state\n\t\tstateLoop: for( var i = 0, len = state.length; i < len; i++ ) {\n\t\t\t// Check if this state existed on the previous slide. If it\n\t\t\t// did, we will avoid adding it repeatedly\n\t\t\tfor( var j = 0; j < stateBefore.length; j++ ) {\n\t\t\t\tif( stateBefore[j] === state[i] ) {\n\t\t\t\t\tstateBefore.splice( j, 1 );\n\t\t\t\t\tcontinue stateLoop;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.documentElement.classList.add( state[i] );\n\n\t\t\t// Dispatch custom event matching the state's name\n\t\t\tdispatchEvent( state[i] );\n\t\t}\n\n\t\t// Clean up the remains of the previous state\n\t\twhile( stateBefore.length ) {\n\t\t\tdocument.documentElement.classList.remove( stateBefore.pop() );\n\t\t}\n\n\t\t// Update the overview if it's currently active\n\t\tif( isOverview() ) {\n\t\t\tupdateOverview();\n\t\t}\n\n\t\t// Find the current horizontal slide and any possible vertical slides\n\t\t// within it\n\t\tvar currentHorizontalSlide = horizontalSlides[ indexh ],\n\t\t\tcurrentVerticalSlides = currentHorizontalSlide.querySelectorAll( 'section' );\n\n\t\t// Store references to the previous and current slides\n\t\tcurrentSlide = currentVerticalSlides[ indexv ] || currentHorizontalSlide;\n\n\t\t// Show fragment, if specified\n\t\tif( typeof f !== 'undefined' ) {\n\t\t\tnavigateFragment( f );\n\t\t}\n\n\t\t// Dispatch an event if the slide changed\n\t\tvar slideChanged = ( indexh !== indexhBefore || indexv !== indexvBefore );\n\t\tif (!slideChanged) {\n\t\t\t// Ensure that the previous slide is never the same as the current\n\t\t\tpreviousSlide = null;\n\t\t}\n\n\t\t// Solves an edge case where the previous slide maintains the\n\t\t// 'present' class when navigating between adjacent vertical\n\t\t// stacks\n\t\tif( previousSlide && previousSlide !== currentSlide ) {\n\t\t\tpreviousSlide.classList.remove( 'present' );\n\t\t\tpreviousSlide.setAttribute( 'aria-hidden', 'true' );\n\n\t\t\t// Reset all slides upon navigate to home\n\t\t\t// Issue: #285\n\t\t\tif ( dom.wrapper.querySelector( HOME_SLIDE_SELECTOR ).classList.contains( 'present' ) ) {\n\t\t\t\t// Launch async task\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\tvar slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.stack') ), i;\n\t\t\t\t\tfor( i in slides ) {\n\t\t\t\t\t\tif( slides[i] ) {\n\t\t\t\t\t\t\t// Reset stack\n\t\t\t\t\t\t\tsetPreviousVerticalIndex( slides[i], 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 0 );\n\t\t\t}\n\t\t}\n\n\t\tif( slideChanged ) {\n\t\t\tdispatchEvent( 'slidechanged', {\n\t\t\t\t'indexh': indexh,\n\t\t\t\t'indexv': indexv,\n\t\t\t\t'previousSlide': previousSlide,\n\t\t\t\t'currentSlide': currentSlide,\n\t\t\t\t'origin': o\n\t\t\t} );\n\t\t}\n\n\t\t// Handle embedded content\n\t\tif( slideChanged || !previousSlide ) {\n\t\t\tstopEmbeddedContent( previousSlide );\n\t\t\tstartEmbeddedContent( currentSlide );\n\t\t}\n\n\t\t// Announce the current slide contents, for screen readers\n\t\tdom.statusDiv.textContent = getStatusText( currentSlide );\n\n\t\tupdateControls();\n\t\tupdateProgress();\n\t\tupdateBackground();\n\t\tupdateParallax();\n\t\tupdateSlideNumber();\n\t\tupdateNotes();\n\n\t\t// Update the URL hash\n\t\twriteURL();\n\n\t\tcueAutoSlide();\n\n\t}\n\n\t/**\n\t * Syncs the presentation with the current DOM. Useful\n\t * when new slides or control elements are added or when\n\t * the configuration has changed.\n\t */\n\tfunction sync() {\n\n\t\t// Subscribe to input\n\t\tremoveEventListeners();\n\t\taddEventListeners();\n\n\t\t// Force a layout to make sure the current config is accounted for\n\t\tlayout();\n\n\t\t// Reflect the current autoSlide value\n\t\tautoSlide = config.autoSlide;\n\n\t\t// Start auto-sliding if it's enabled\n\t\tcueAutoSlide();\n\n\t\t// Re-create the slide backgrounds\n\t\tcreateBackgrounds();\n\n\t\t// Write the current hash to the URL\n\t\twriteURL();\n\n\t\tsortAllFragments();\n\n\t\tupdateControls();\n\t\tupdateProgress();\n\t\tupdateSlideNumber();\n\t\tupdateSlidesVisibility();\n\t\tupdateBackground( true );\n\t\tupdateNotesVisibility();\n\t\tupdateNotes();\n\n\t\tformatEmbeddedContent();\n\n\t\t// Start or stop embedded content depending on global config\n\t\tif( config.autoPlayMedia === false ) {\n\t\t\tstopEmbeddedContent( currentSlide, { unloadIframes: false } );\n\t\t}\n\t\telse {\n\t\t\tstartEmbeddedContent( currentSlide );\n\t\t}\n\n\t\tif( isOverview() ) {\n\t\t\tlayoutOverview();\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates reveal.js to keep in sync with new slide attributes. For\n\t * example, if you add a new `data-background-image` you can call\n\t * this to have reveal.js render the new background image.\n\t *\n\t * Similar to #sync() but more efficient when you only need to\n\t * refresh a specific slide.\n\t *\n\t * @param {HTMLElement} slide\n\t */\n\tfunction syncSlide( slide ) {\n\n\t\tsyncBackground( slide );\n\t\tsyncFragments( slide );\n\n\t\tupdateBackground();\n\t\tupdateNotes();\n\n\t\tloadSlide( slide );\n\n\t}\n\n\t/**\n\t * Formats the fragments on the given slide so that they have\n\t * valid indices. Call this if fragments are changed in the DOM\n\t * after reveal.js has already initialized.\n\t *\n\t * @param {HTMLElement} slide\n\t */\n\tfunction syncFragments( slide ) {\n\n\t\tsortFragments( slide.querySelectorAll( '.fragment' ) );\n\n\t}\n\n\t/**\n\t * Resets all vertical slides so that only the first\n\t * is visible.\n\t */\n\tfunction resetVerticalSlides() {\n\n\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\t\thorizontalSlides.forEach( function( horizontalSlide ) {\n\n\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );\n\t\t\tverticalSlides.forEach( function( verticalSlide, y ) {\n\n\t\t\t\tif( y > 0 ) {\n\t\t\t\t\tverticalSlide.classList.remove( 'present' );\n\t\t\t\t\tverticalSlide.classList.remove( 'past' );\n\t\t\t\t\tverticalSlide.classList.add( 'future' );\n\t\t\t\t\tverticalSlide.setAttribute( 'aria-hidden', 'true' );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Sorts and formats all of fragments in the\n\t * presentation.\n\t */\n\tfunction sortAllFragments() {\n\n\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\t\thorizontalSlides.forEach( function( horizontalSlide ) {\n\n\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );\n\t\t\tverticalSlides.forEach( function( verticalSlide, y ) {\n\n\t\t\t\tsortFragments( verticalSlide.querySelectorAll( '.fragment' ) );\n\n\t\t\t} );\n\n\t\t\tif( verticalSlides.length === 0 ) sortFragments( horizontalSlide.querySelectorAll( '.fragment' ) );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Randomly shuffles all slides in the deck.\n\t */\n\tfunction shuffle() {\n\n\t\tvar slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\n\t\tslides.forEach( function( slide ) {\n\n\t\t\t// Insert this slide next to another random slide. This may\n\t\t\t// cause the slide to insert before itself but that's fine.\n\t\t\tdom.slides.insertBefore( slide, slides[ Math.floor( Math.random() * slides.length ) ] );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates one dimension of slides by showing the slide\n\t * with the specified index.\n\t *\n\t * @param {string} selector A CSS selector that will fetch\n\t * the group of slides we are working with\n\t * @param {number} index The index of the slide that should be\n\t * shown\n\t *\n\t * @return {number} The index of the slide that is now shown,\n\t * might differ from the passed in index if it was out of\n\t * bounds.\n\t */\n\tfunction updateSlides( selector, index ) {\n\n\t\t// Select all slides and convert the NodeList result to\n\t\t// an array\n\t\tvar slides = toArray( dom.wrapper.querySelectorAll( selector ) ),\n\t\t\tslidesLength = slides.length;\n\n\t\tvar printMode = isPrintingPDF();\n\n\t\tif( slidesLength ) {\n\n\t\t\t// Should the index loop?\n\t\t\tif( config.loop ) {\n\t\t\t\tindex %= slidesLength;\n\n\t\t\t\tif( index < 0 ) {\n\t\t\t\t\tindex = slidesLength + index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Enforce max and minimum index bounds\n\t\t\tindex = Math.max( Math.min( index, slidesLength - 1 ), 0 );\n\n\t\t\tfor( var i = 0; i < slidesLength; i++ ) {\n\t\t\t\tvar element = slides[i];\n\n\t\t\t\tvar reverse = config.rtl && !isVerticalSlide( element );\n\n\t\t\t\telement.classList.remove( 'past' );\n\t\t\t\telement.classList.remove( 'present' );\n\t\t\t\telement.classList.remove( 'future' );\n\n\t\t\t\t// http://www.w3.org/html/wg/drafts/html/master/editing.html#the-hidden-attribute\n\t\t\t\telement.setAttribute( 'hidden', '' );\n\t\t\t\telement.setAttribute( 'aria-hidden', 'true' );\n\n\t\t\t\t// If this element contains vertical slides\n\t\t\t\tif( element.querySelector( 'section' ) ) {\n\t\t\t\t\telement.classList.add( 'stack' );\n\t\t\t\t}\n\n\t\t\t\t// If we're printing static slides, all slides are \"present\"\n\t\t\t\tif( printMode ) {\n\t\t\t\t\telement.classList.add( 'present' );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif( i < index ) {\n\t\t\t\t\t// Any element previous to index is given the 'past' class\n\t\t\t\t\telement.classList.add( reverse ? 'future' : 'past' );\n\n\t\t\t\t\tif( config.fragments ) {\n\t\t\t\t\t\tvar pastFragments = toArray( element.querySelectorAll( '.fragment' ) );\n\n\t\t\t\t\t\t// Show all fragments on prior slides\n\t\t\t\t\t\twhile( pastFragments.length ) {\n\t\t\t\t\t\t\tvar pastFragment = pastFragments.pop();\n\t\t\t\t\t\t\tpastFragment.classList.add( 'visible' );\n\t\t\t\t\t\t\tpastFragment.classList.remove( 'current-fragment' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if( i > index ) {\n\t\t\t\t\t// Any element subsequent to index is given the 'future' class\n\t\t\t\t\telement.classList.add( reverse ? 'past' : 'future' );\n\n\t\t\t\t\tif( config.fragments ) {\n\t\t\t\t\t\tvar futureFragments = toArray( element.querySelectorAll( '.fragment.visible' ) );\n\n\t\t\t\t\t\t// No fragments in future slides should be visible ahead of time\n\t\t\t\t\t\twhile( futureFragments.length ) {\n\t\t\t\t\t\t\tvar futureFragment = futureFragments.pop();\n\t\t\t\t\t\t\tfutureFragment.classList.remove( 'visible' );\n\t\t\t\t\t\t\tfutureFragment.classList.remove( 'current-fragment' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark the current slide as present\n\t\t\tslides[index].classList.add( 'present' );\n\t\t\tslides[index].removeAttribute( 'hidden' );\n\t\t\tslides[index].removeAttribute( 'aria-hidden' );\n\n\t\t\t// If this slide has a state associated with it, add it\n\t\t\t// onto the current state of the deck\n\t\t\tvar slideState = slides[index].getAttribute( 'data-state' );\n\t\t\tif( slideState ) {\n\t\t\t\tstate = state.concat( slideState.split( ' ' ) );\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\t// Since there are no slides we can't be anywhere beyond the\n\t\t\t// zeroth index\n\t\t\tindex = 0;\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Optimization method; hide all slides that are far away\n\t * from the present slide.\n\t */\n\tfunction updateSlidesVisibility() {\n\n\t\t// Select all slides and convert the NodeList result to\n\t\t// an array\n\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ),\n\t\t\thorizontalSlidesLength = horizontalSlides.length,\n\t\t\tdistanceX,\n\t\t\tdistanceY;\n\n\t\tif( horizontalSlidesLength && typeof indexh !== 'undefined' ) {\n\n\t\t\t// The number of steps away from the present slide that will\n\t\t\t// be visible\n\t\t\tvar viewDistance = isOverview() ? 10 : config.viewDistance;\n\n\t\t\t// Limit view distance on weaker devices\n\t\t\tif( isMobileDevice ) {\n\t\t\t\tviewDistance = isOverview() ? 6 : 2;\n\t\t\t}\n\n\t\t\t// All slides need to be visible when exporting to PDF\n\t\t\tif( isPrintingPDF() ) {\n\t\t\t\tviewDistance = Number.MAX_VALUE;\n\t\t\t}\n\n\t\t\tfor( var x = 0; x < horizontalSlidesLength; x++ ) {\n\t\t\t\tvar horizontalSlide = horizontalSlides[x];\n\n\t\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) ),\n\t\t\t\t\tverticalSlidesLength = verticalSlides.length;\n\n\t\t\t\t// Determine how far away this slide is from the present\n\t\t\t\tdistanceX = Math.abs( ( indexh || 0 ) - x ) || 0;\n\n\t\t\t\t// If the presentation is looped, distance should measure\n\t\t\t\t// 1 between the first and last slides\n\t\t\t\tif( config.loop ) {\n\t\t\t\t\tdistanceX = Math.abs( ( ( indexh || 0 ) - x ) % ( horizontalSlidesLength - viewDistance ) ) || 0;\n\t\t\t\t}\n\n\t\t\t\t// Show the horizontal slide if it's within the view distance\n\t\t\t\tif( distanceX < viewDistance ) {\n\t\t\t\t\tloadSlide( horizontalSlide );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tunloadSlide( horizontalSlide );\n\t\t\t\t}\n\n\t\t\t\tif( verticalSlidesLength ) {\n\n\t\t\t\t\tvar oy = getPreviousVerticalIndex( horizontalSlide );\n\n\t\t\t\t\tfor( var y = 0; y < verticalSlidesLength; y++ ) {\n\t\t\t\t\t\tvar verticalSlide = verticalSlides[y];\n\n\t\t\t\t\t\tdistanceY = x === ( indexh || 0 ) ? Math.abs( ( indexv || 0 ) - y ) : Math.abs( y - oy );\n\n\t\t\t\t\t\tif( distanceX + distanceY < viewDistance ) {\n\t\t\t\t\t\t\tloadSlide( verticalSlide );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tunloadSlide( verticalSlide );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flag if there are ANY vertical slides, anywhere in the deck\n\t\t\tif( dom.wrapper.querySelectorAll( '.slides>section>section' ).length ) {\n\t\t\t\tdom.wrapper.classList.add( 'has-vertical-slides' );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdom.wrapper.classList.remove( 'has-vertical-slides' );\n\t\t\t}\n\n\t\t\t// Flag if there are ANY horizontal slides, anywhere in the deck\n\t\t\tif( dom.wrapper.querySelectorAll( '.slides>section' ).length > 1 ) {\n\t\t\t\tdom.wrapper.classList.add( 'has-horizontal-slides' );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdom.wrapper.classList.remove( 'has-horizontal-slides' );\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pick up notes from the current slide and display them\n\t * to the viewer.\n\t *\n\t * @see {@link config.showNotes}\n\t */\n\tfunction updateNotes() {\n\n\t\tif( config.showNotes && dom.speakerNotes && currentSlide && !isPrintingPDF() ) {\n\n\t\t\tdom.speakerNotes.innerHTML = getSlideNotes() || '<span class=\"notes-placeholder\">No notes on this slide.</span>';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the visibility of the speaker notes sidebar that\n\t * is used to share annotated slides. The notes sidebar is\n\t * only visible if showNotes is true and there are notes on\n\t * one or more slides in the deck.\n\t */\n\tfunction updateNotesVisibility() {\n\n\t\tif( config.showNotes && hasNotes() ) {\n\t\t\tdom.wrapper.classList.add( 'show-notes' );\n\t\t}\n\t\telse {\n\t\t\tdom.wrapper.classList.remove( 'show-notes' );\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if there are speaker notes for ANY slide in the\n\t * presentation.\n\t */\n\tfunction hasNotes() {\n\n\t\treturn dom.slides.querySelectorAll( '[data-notes], aside.notes' ).length > 0;\n\n\t}\n\n\t/**\n\t * Updates the progress bar to reflect the current slide.\n\t */\n\tfunction updateProgress() {\n\n\t\t// Update progress if enabled\n\t\tif( config.progress && dom.progressbar ) {\n\n\t\t\tdom.progressbar.style.width = getProgress() * dom.wrapper.offsetWidth + 'px';\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Updates the slide number div to reflect the current slide.\n\t *\n\t * The following slide number formats are available:\n\t *  \"h.v\":\thorizontal . vertical slide number (default)\n\t *  \"h/v\":\thorizontal / vertical slide number\n\t *    \"c\":\tflattened slide number\n\t *  \"c/t\":\tflattened slide number / total slides\n\t */\n\tfunction updateSlideNumber() {\n\n\t\t// Update slide number if enabled\n\t\tif( config.slideNumber && dom.slideNumber ) {\n\n\t\t\tvar value = [];\n\t\t\tvar format = 'h.v';\n\n\t\t\t// Check if a custom number format is available\n\t\t\tif( typeof config.slideNumber === 'string' ) {\n\t\t\t\tformat = config.slideNumber;\n\t\t\t}\n\n\t\t\t// If there are ONLY vertical slides in this deck, always use\n\t\t\t// a flattened slide number\n\t\t\tif( !/c/.test( format ) && dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ).length === 1 ) {\n\t\t\t\tformat = 'c';\n\t\t\t}\n\n\t\t\tswitch( format ) {\n\t\t\t\tcase 'c':\n\t\t\t\t\tvalue.push( getSlidePastCount() + 1 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c/t':\n\t\t\t\t\tvalue.push( getSlidePastCount() + 1, '/', getTotalSlides() );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h/v':\n\t\t\t\t\tvalue.push( indexh + 1 );\n\t\t\t\t\tif( isVerticalSlide() ) value.push( '/', indexv + 1 );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvalue.push( indexh + 1 );\n\t\t\t\t\tif( isVerticalSlide() ) value.push( '.', indexv + 1 );\n\t\t\t}\n\n\t\t\tdom.slideNumber.innerHTML = formatSlideNumber( value[0], value[1], value[2] );\n\t\t}\n\n\t}\n\n\t/**\n\t * Applies HTML formatting to a slide number before it's\n\t * written to the DOM.\n\t *\n\t * @param {number} a Current slide\n\t * @param {string} delimiter Character to separate slide numbers\n\t * @param {(number|*)} b Total slides\n\t * @return {string} HTML string fragment\n\t */\n\tfunction formatSlideNumber( a, delimiter, b ) {\n\n\t\tvar url = '#' + locationHash();\n\t\tif( typeof b === 'number' && !isNaN( b ) ) {\n\t\t\treturn  '<a href=\"' + url + '\">' +\n\t\t\t\t\t'<span class=\"slide-number-a\">'+ a +'</span>' +\n\t\t\t\t\t'<span class=\"slide-number-delimiter\">'+ delimiter +'</span>' +\n\t\t\t\t\t'<span class=\"slide-number-b\">'+ b +'</span>' +\n\t\t\t\t\t'</a>';\n\t\t}\n\t\telse {\n\t\t\treturn '<a href=\"' + url + '\">' +\n\t\t\t       '<span class=\"slide-number-a\">'+ a +'</span>' +\n\t\t\t       '</a>';\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the state of all control/navigation arrows.\n\t */\n\tfunction updateControls() {\n\n\t\tvar routes = availableRoutes();\n\t\tvar fragments = availableFragments();\n\n\t\t// Remove the 'enabled' class from all directions\n\t\tdom.controlsLeft.concat( dom.controlsRight )\n\t\t\t\t\t\t.concat( dom.controlsUp )\n\t\t\t\t\t\t.concat( dom.controlsDown )\n\t\t\t\t\t\t.concat( dom.controlsPrev )\n\t\t\t\t\t\t.concat( dom.controlsNext ).forEach( function( node ) {\n\t\t\tnode.classList.remove( 'enabled' );\n\t\t\tnode.classList.remove( 'fragmented' );\n\n\t\t\t// Set 'disabled' attribute on all directions\n\t\t\tnode.setAttribute( 'disabled', 'disabled' );\n\t\t} );\n\n\t\t// Add the 'enabled' class to the available routes; remove 'disabled' attribute to enable buttons\n\t\tif( routes.left ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\tif( routes.right ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\tif( routes.up ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\tif( routes.down ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\n\t\t// Prev/next buttons\n\t\tif( routes.left || routes.up ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\tif( routes.right || routes.down ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\n\t\t// Highlight fragment directions\n\t\tif( currentSlide ) {\n\n\t\t\t// Always apply fragment decorator to prev/next buttons\n\t\t\tif( fragments.prev ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\t\tif( fragments.next ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\n\t\t\t// Apply fragment decorators to directional buttons based on\n\t\t\t// what slide axis they are in\n\t\t\tif( isVerticalSlide( currentSlide ) ) {\n\t\t\t\tif( fragments.prev ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\t\t\tif( fragments.next ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif( fragments.prev ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\t\t\tif( fragments.next ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );\n\t\t\t}\n\n\t\t}\n\n\t\tif( config.controlsTutorial ) {\n\n\t\t\t// Highlight control arrows with an animation to ensure\n\t\t\t// that the viewer knows how to navigate\n\t\t\tif( !hasNavigatedDown && routes.down ) {\n\t\t\t\tdom.controlsDownArrow.classList.add( 'highlight' );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdom.controlsDownArrow.classList.remove( 'highlight' );\n\n\t\t\t\tif( !hasNavigatedRight && routes.right && indexv === 0 ) {\n\t\t\t\t\tdom.controlsRightArrow.classList.add( 'highlight' );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdom.controlsRightArrow.classList.remove( 'highlight' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the background elements to reflect the current\n\t * slide.\n\t *\n\t * @param {boolean} includeAll If true, the backgrounds of\n\t * all vertical slides (not just the present) will be updated.\n\t */\n\tfunction updateBackground( includeAll ) {\n\n\t\tvar currentBackground = null;\n\n\t\t// Reverse past/future classes when in RTL mode\n\t\tvar horizontalPast = config.rtl ? 'future' : 'past',\n\t\t\thorizontalFuture = config.rtl ? 'past' : 'future';\n\n\t\t// Update the classes of all backgrounds to match the\n\t\t// states of their slides (past/present/future)\n\t\ttoArray( dom.background.childNodes ).forEach( function( backgroundh, h ) {\n\n\t\t\tbackgroundh.classList.remove( 'past' );\n\t\t\tbackgroundh.classList.remove( 'present' );\n\t\t\tbackgroundh.classList.remove( 'future' );\n\n\t\t\tif( h < indexh ) {\n\t\t\t\tbackgroundh.classList.add( horizontalPast );\n\t\t\t}\n\t\t\telse if ( h > indexh ) {\n\t\t\t\tbackgroundh.classList.add( horizontalFuture );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbackgroundh.classList.add( 'present' );\n\n\t\t\t\t// Store a reference to the current background element\n\t\t\t\tcurrentBackground = backgroundh;\n\t\t\t}\n\n\t\t\tif( includeAll || h === indexh ) {\n\t\t\t\ttoArray( backgroundh.querySelectorAll( '.slide-background' ) ).forEach( function( backgroundv, v ) {\n\n\t\t\t\t\tbackgroundv.classList.remove( 'past' );\n\t\t\t\t\tbackgroundv.classList.remove( 'present' );\n\t\t\t\t\tbackgroundv.classList.remove( 'future' );\n\n\t\t\t\t\tif( v < indexv ) {\n\t\t\t\t\t\tbackgroundv.classList.add( 'past' );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( v > indexv ) {\n\t\t\t\t\t\tbackgroundv.classList.add( 'future' );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbackgroundv.classList.add( 'present' );\n\n\t\t\t\t\t\t// Only if this is the present horizontal and vertical slide\n\t\t\t\t\t\tif( h === indexh ) currentBackground = backgroundv;\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t}\n\n\t\t} );\n\n\t\t// Stop content inside of previous backgrounds\n\t\tif( previousBackground ) {\n\n\t\t\tstopEmbeddedContent( previousBackground );\n\n\t\t}\n\n\t\t// Start content in the current background\n\t\tif( currentBackground ) {\n\n\t\t\tstartEmbeddedContent( currentBackground );\n\n\t\t\tvar currentBackgroundContent = currentBackground.querySelector( '.slide-background-content' );\n\t\t\tif( currentBackgroundContent ) {\n\n\t\t\t\tvar backgroundImageURL = currentBackgroundContent.style.backgroundImage || '';\n\n\t\t\t\t// Restart GIFs (doesn't work in Firefox)\n\t\t\t\tif( /\\.gif/i.test( backgroundImageURL ) ) {\n\t\t\t\t\tcurrentBackgroundContent.style.backgroundImage = '';\n\t\t\t\t\twindow.getComputedStyle( currentBackgroundContent ).opacity;\n\t\t\t\t\tcurrentBackgroundContent.style.backgroundImage = backgroundImageURL;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Don't transition between identical backgrounds. This\n\t\t\t// prevents unwanted flicker.\n\t\t\tvar previousBackgroundHash = previousBackground ? previousBackground.getAttribute( 'data-background-hash' ) : null;\n\t\t\tvar currentBackgroundHash = currentBackground.getAttribute( 'data-background-hash' );\n\t\t\tif( currentBackgroundHash && currentBackgroundHash === previousBackgroundHash && currentBackground !== previousBackground ) {\n\t\t\t\tdom.background.classList.add( 'no-transition' );\n\t\t\t}\n\n\t\t\tpreviousBackground = currentBackground;\n\n\t\t}\n\n\t\t// If there's a background brightness flag for this slide,\n\t\t// bubble it to the .reveal container\n\t\tif( currentSlide ) {\n\t\t\t[ 'has-light-background', 'has-dark-background' ].forEach( function( classToBubble ) {\n\t\t\t\tif( currentSlide.classList.contains( classToBubble ) ) {\n\t\t\t\t\tdom.wrapper.classList.add( classToBubble );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdom.wrapper.classList.remove( classToBubble );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Allow the first background to apply without transition\n\t\tsetTimeout( function() {\n\t\t\tdom.background.classList.remove( 'no-transition' );\n\t\t}, 1 );\n\n\t}\n\n\t/**\n\t * Updates the position of the parallax background based\n\t * on the current slide index.\n\t */\n\tfunction updateParallax() {\n\n\t\tif( config.parallaxBackgroundImage ) {\n\n\t\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),\n\t\t\t\tverticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );\n\n\t\t\tvar backgroundSize = dom.background.style.backgroundSize.split( ' ' ),\n\t\t\t\tbackgroundWidth, backgroundHeight;\n\n\t\t\tif( backgroundSize.length === 1 ) {\n\t\t\t\tbackgroundWidth = backgroundHeight = parseInt( backgroundSize[0], 10 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbackgroundWidth = parseInt( backgroundSize[0], 10 );\n\t\t\t\tbackgroundHeight = parseInt( backgroundSize[1], 10 );\n\t\t\t}\n\n\t\t\tvar slideWidth = dom.background.offsetWidth,\n\t\t\t\thorizontalSlideCount = horizontalSlides.length,\n\t\t\t\thorizontalOffsetMultiplier,\n\t\t\t\thorizontalOffset;\n\n\t\t\tif( typeof config.parallaxBackgroundHorizontal === 'number' ) {\n\t\t\t\thorizontalOffsetMultiplier = config.parallaxBackgroundHorizontal;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thorizontalOffsetMultiplier = horizontalSlideCount > 1 ? ( backgroundWidth - slideWidth ) / ( horizontalSlideCount-1 ) : 0;\n\t\t\t}\n\n\t\t\thorizontalOffset = horizontalOffsetMultiplier * indexh * -1;\n\n\t\t\tvar slideHeight = dom.background.offsetHeight,\n\t\t\t\tverticalSlideCount = verticalSlides.length,\n\t\t\t\tverticalOffsetMultiplier,\n\t\t\t\tverticalOffset;\n\n\t\t\tif( typeof config.parallaxBackgroundVertical === 'number' ) {\n\t\t\t\tverticalOffsetMultiplier = config.parallaxBackgroundVertical;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tverticalOffsetMultiplier = ( backgroundHeight - slideHeight ) / ( verticalSlideCount-1 );\n\t\t\t}\n\n\t\t\tverticalOffset = verticalSlideCount > 0 ?  verticalOffsetMultiplier * indexv : 0;\n\n\t\t\tdom.background.style.backgroundPosition = horizontalOffset + 'px ' + -verticalOffset + 'px';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Called when the given slide is within the configured view\n\t * distance. Shows the slide element and loads any content\n\t * that is set to load lazily (data-src).\n\t *\n\t * @param {HTMLElement} slide Slide to show\n\t */\n\tfunction loadSlide( slide, options ) {\n\n\t\toptions = options || {};\n\n\t\t// Show the slide element\n\t\tslide.style.display = config.display;\n\n\t\t// Media elements with data-src attributes\n\t\ttoArray( slide.querySelectorAll( 'img[data-src], video[data-src], audio[data-src]' ) ).forEach( function( element ) {\n\t\t\telement.setAttribute( 'src', element.getAttribute( 'data-src' ) );\n\t\t\telement.setAttribute( 'data-lazy-loaded', '' );\n\t\t\telement.removeAttribute( 'data-src' );\n\t\t} );\n\n\t\t// Media elements with <source> children\n\t\ttoArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( media ) {\n\t\t\tvar sources = 0;\n\n\t\t\ttoArray( media.querySelectorAll( 'source[data-src]' ) ).forEach( function( source ) {\n\t\t\t\tsource.setAttribute( 'src', source.getAttribute( 'data-src' ) );\n\t\t\t\tsource.removeAttribute( 'data-src' );\n\t\t\t\tsource.setAttribute( 'data-lazy-loaded', '' );\n\t\t\t\tsources += 1;\n\t\t\t} );\n\n\t\t\t// If we rewrote sources for this video/audio element, we need\n\t\t\t// to manually tell it to load from its new origin\n\t\t\tif( sources > 0 ) {\n\t\t\t\tmedia.load();\n\t\t\t}\n\t\t} );\n\n\n\t\t// Show the corresponding background element\n\t\tvar background = slide.slideBackgroundElement;\n\t\tif( background ) {\n\t\t\tbackground.style.display = 'block';\n\n\t\t\tvar backgroundContent = slide.slideBackgroundContentElement;\n\n\t\t\t// If the background contains media, load it\n\t\t\tif( background.hasAttribute( 'data-loaded' ) === false ) {\n\t\t\t\tbackground.setAttribute( 'data-loaded', 'true' );\n\n\t\t\t\tvar backgroundImage = slide.getAttribute( 'data-background-image' ),\n\t\t\t\t\tbackgroundVideo = slide.getAttribute( 'data-background-video' ),\n\t\t\t\t\tbackgroundVideoLoop = slide.hasAttribute( 'data-background-video-loop' ),\n\t\t\t\t\tbackgroundVideoMuted = slide.hasAttribute( 'data-background-video-muted' ),\n\t\t\t\t\tbackgroundIframe = slide.getAttribute( 'data-background-iframe' );\n\n\t\t\t\t// Images\n\t\t\t\tif( backgroundImage ) {\n\t\t\t\t\tbackgroundContent.style.backgroundImage = 'url('+ encodeURI( backgroundImage ) +')';\n\t\t\t\t}\n\t\t\t\t// Videos\n\t\t\t\telse if ( backgroundVideo && !isSpeakerNotes() ) {\n\t\t\t\t\tvar video = document.createElement( 'video' );\n\n\t\t\t\t\tif( backgroundVideoLoop ) {\n\t\t\t\t\t\tvideo.setAttribute( 'loop', '' );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( backgroundVideoMuted ) {\n\t\t\t\t\t\tvideo.muted = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Inline video playback works (at least in Mobile Safari) as\n\t\t\t\t\t// long as the video is muted and the `playsinline` attribute is\n\t\t\t\t\t// present\n\t\t\t\t\tif( isMobileDevice ) {\n\t\t\t\t\t\tvideo.muted = true;\n\t\t\t\t\t\tvideo.autoplay = true;\n\t\t\t\t\t\tvideo.setAttribute( 'playsinline', '' );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support comma separated lists of video sources\n\t\t\t\t\tbackgroundVideo.split( ',' ).forEach( function( source ) {\n\t\t\t\t\t\tvideo.innerHTML += '<source src=\"'+ source +'\">';\n\t\t\t\t\t} );\n\n\t\t\t\t\tbackgroundContent.appendChild( video );\n\t\t\t\t}\n\t\t\t\t// Iframes\n\t\t\t\telse if( backgroundIframe && options.excludeIframes !== true ) {\n\t\t\t\t\tvar iframe = document.createElement( 'iframe' );\n\t\t\t\t\tiframe.setAttribute( 'allowfullscreen', '' );\n\t\t\t\t\tiframe.setAttribute( 'mozallowfullscreen', '' );\n\t\t\t\t\tiframe.setAttribute( 'webkitallowfullscreen', '' );\n\n\t\t\t\t\t// Only load autoplaying content when the slide is shown to\n\t\t\t\t\t// avoid having it play in the background\n\t\t\t\t\tif( /autoplay=(1|true|yes)/gi.test( backgroundIframe ) ) {\n\t\t\t\t\t\tiframe.setAttribute( 'data-src', backgroundIframe );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tiframe.setAttribute( 'src', backgroundIframe );\n\t\t\t\t\t}\n\n\t\t\t\t\tiframe.style.width  = '100%';\n\t\t\t\t\tiframe.style.height = '100%';\n\t\t\t\t\tiframe.style.maxHeight = '100%';\n\t\t\t\t\tiframe.style.maxWidth = '100%';\n\n\t\t\t\t\tbackgroundContent.appendChild( iframe );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Unloads and hides the given slide. This is called when the\n\t * slide is moved outside of the configured view distance.\n\t *\n\t * @param {HTMLElement} slide\n\t */\n\tfunction unloadSlide( slide ) {\n\n\t\t// Hide the slide element\n\t\tslide.style.display = 'none';\n\n\t\t// Hide the corresponding background element\n\t\tvar background = getSlideBackground( slide );\n\t\tif( background ) {\n\t\t\tbackground.style.display = 'none';\n\t\t}\n\n\t\t// Reset lazy-loaded media elements with src attributes\n\t\ttoArray( slide.querySelectorAll( 'video[data-lazy-loaded][src], audio[data-lazy-loaded][src]' ) ).forEach( function( element ) {\n\t\t\telement.setAttribute( 'data-src', element.getAttribute( 'src' ) );\n\t\t\telement.removeAttribute( 'src' );\n\t\t} );\n\n\t\t// Reset lazy-loaded media elements with <source> children\n\t\ttoArray( slide.querySelectorAll( 'video[data-lazy-loaded] source[src], audio source[src]' ) ).forEach( function( source ) {\n\t\t\tsource.setAttribute( 'data-src', source.getAttribute( 'src' ) );\n\t\t\tsource.removeAttribute( 'src' );\n\t\t} );\n\n\t}\n\n\t/**\n\t * Determine what available routes there are for navigation.\n\t *\n\t * @return {{left: boolean, right: boolean, up: boolean, down: boolean}}\n\t */\n\tfunction availableRoutes() {\n\n\t\tvar horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),\n\t\t\tverticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );\n\n\t\tvar routes = {\n\t\t\tleft: indexh > 0,\n\t\t\tright: indexh < horizontalSlides.length - 1,\n\t\t\tup: indexv > 0,\n\t\t\tdown: indexv < verticalSlides.length - 1\n\t\t};\n\n\t\t// Looped presentations can always be navigated as long as\n\t\t// there are slides available\n\t\tif( config.loop ) {\n\t\t\tif( horizontalSlides.length > 1 ) {\n\t\t\t\troutes.left = true;\n\t\t\t\troutes.right = true;\n\t\t\t}\n\n\t\t\tif( verticalSlides.length > 1 ) {\n\t\t\t\troutes.up = true;\n\t\t\t\troutes.down = true;\n\t\t\t}\n\t\t}\n\n\t\t// Reverse horizontal controls for rtl\n\t\tif( config.rtl ) {\n\t\t\tvar left = routes.left;\n\t\t\troutes.left = routes.right;\n\t\t\troutes.right = left;\n\t\t}\n\n\t\treturn routes;\n\n\t}\n\n\t/**\n\t * Returns an object describing the available fragment\n\t * directions.\n\t *\n\t * @return {{prev: boolean, next: boolean}}\n\t */\n\tfunction availableFragments() {\n\n\t\tif( currentSlide && config.fragments ) {\n\t\t\tvar fragments = currentSlide.querySelectorAll( '.fragment' );\n\t\t\tvar hiddenFragments = currentSlide.querySelectorAll( '.fragment:not(.visible)' );\n\n\t\t\treturn {\n\t\t\t\tprev: fragments.length - hiddenFragments.length > 0,\n\t\t\t\tnext: !!hiddenFragments.length\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\treturn { prev: false, next: false };\n\t\t}\n\n\t}\n\n\t/**\n\t * Enforces origin-specific format rules for embedded media.\n\t */\n\tfunction formatEmbeddedContent() {\n\n\t\tvar _appendParamToIframeSource = function( sourceAttribute, sourceURL, param ) {\n\t\t\ttoArray( dom.slides.querySelectorAll( 'iframe['+ sourceAttribute +'*=\"'+ sourceURL +'\"]' ) ).forEach( function( el ) {\n\t\t\t\tvar src = el.getAttribute( sourceAttribute );\n\t\t\t\tif( src && src.indexOf( param ) === -1 ) {\n\t\t\t\t\tel.setAttribute( sourceAttribute, src + ( !/\\?/.test( src ) ? '?' : '&' ) + param );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// YouTube frames must include \"?enablejsapi=1\"\n\t\t_appendParamToIframeSource( 'src', 'youtube.com/embed/', 'enablejsapi=1' );\n\t\t_appendParamToIframeSource( 'data-src', 'youtube.com/embed/', 'enablejsapi=1' );\n\n\t\t// Vimeo frames must include \"?api=1\"\n\t\t_appendParamToIframeSource( 'src', 'player.vimeo.com/', 'api=1' );\n\t\t_appendParamToIframeSource( 'data-src', 'player.vimeo.com/', 'api=1' );\n\n\t\t// Always show media controls on mobile devices\n\t\tif( isMobileDevice ) {\n\t\t\ttoArray( dom.slides.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {\n\t\t\t\tel.controls = true;\n\t\t\t} );\n\t\t}\n\n\t}\n\n\t/**\n\t * Start playback of any embedded content inside of\n\t * the given element.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tfunction startEmbeddedContent( element ) {\n\n\t\tif( element && !isSpeakerNotes() ) {\n\n\t\t\t// Restart GIFs\n\t\t\ttoArray( element.querySelectorAll( 'img[src$=\".gif\"]' ) ).forEach( function( el ) {\n\t\t\t\t// Setting the same unchanged source like this was confirmed\n\t\t\t\t// to work in Chrome, FF & Safari\n\t\t\t\tel.setAttribute( 'src', el.getAttribute( 'src' ) );\n\t\t\t} );\n\n\t\t\t// HTML5 media elements\n\t\t\ttoArray( element.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {\n\t\t\t\tif( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Prefer an explicit global autoplay setting\n\t\t\t\tvar autoplay = config.autoPlayMedia;\n\n\t\t\t\t// If no global setting is available, fall back on the element's\n\t\t\t\t// own autoplay setting\n\t\t\t\tif( typeof autoplay !== 'boolean' ) {\n\t\t\t\t\tautoplay = el.hasAttribute( 'data-autoplay' ) || !!closestParent( el, '.slide-background' );\n\t\t\t\t}\n\n\t\t\t\tif( autoplay && typeof el.play === 'function' ) {\n\n\t\t\t\t\t// If the media is ready, start playback\n\t\t\t\t\tif( el.readyState > 1 ) {\n\t\t\t\t\t\tstartEmbeddedMedia( { target: el } );\n\t\t\t\t\t}\n\t\t\t\t\t// Mobile devices never fire a loaded event so instead\n\t\t\t\t\t// of waiting, we initiate playback\n\t\t\t\t\telse if( isMobileDevice ) {\n\t\t\t\t\t\tel.play();\n\t\t\t\t\t}\n\t\t\t\t\t// If the media isn't loaded, wait before playing\n\t\t\t\t\telse {\n\t\t\t\t\t\tel.removeEventListener( 'loadeddata', startEmbeddedMedia ); // remove first to avoid dupes\n\t\t\t\t\t\tel.addEventListener( 'loadeddata', startEmbeddedMedia );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Normal iframes\n\t\t\ttoArray( element.querySelectorAll( 'iframe[src]' ) ).forEach( function( el ) {\n\t\t\t\tif( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tstartEmbeddedIframe( { target: el } );\n\t\t\t} );\n\n\t\t\t// Lazy loading iframes\n\t\t\ttoArray( element.querySelectorAll( 'iframe[data-src]' ) ).forEach( function( el ) {\n\t\t\t\tif( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif( el.getAttribute( 'src' ) !== el.getAttribute( 'data-src' ) ) {\n\t\t\t\t\tel.removeEventListener( 'load', startEmbeddedIframe ); // remove first to avoid dupes\n\t\t\t\t\tel.addEventListener( 'load', startEmbeddedIframe );\n\t\t\t\t\tel.setAttribute( 'src', el.getAttribute( 'data-src' ) );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Starts playing an embedded video/audio element after\n\t * it has finished loading.\n\t *\n\t * @param {object} event\n\t */\n\tfunction startEmbeddedMedia( event ) {\n\n\t\tvar isAttachedToDOM = !!closestParent( event.target, 'html' ),\n\t\t\tisVisible  \t\t= !!closestParent( event.target, '.present' );\n\n\t\tif( isAttachedToDOM && isVisible ) {\n\t\t\tevent.target.currentTime = 0;\n\t\t\tevent.target.play();\n\t\t}\n\n\t\tevent.target.removeEventListener( 'loadeddata', startEmbeddedMedia );\n\n\t}\n\n\t/**\n\t * \"Starts\" the content of an embedded iframe using the\n\t * postMessage API.\n\t *\n\t * @param {object} event\n\t */\n\tfunction startEmbeddedIframe( event ) {\n\n\t\tvar iframe = event.target;\n\n\t\tif( iframe && iframe.contentWindow ) {\n\n\t\t\tvar isAttachedToDOM = !!closestParent( event.target, 'html' ),\n\t\t\t\tisVisible  \t\t= !!closestParent( event.target, '.present' );\n\n\t\t\tif( isAttachedToDOM && isVisible ) {\n\n\t\t\t\t// Prefer an explicit global autoplay setting\n\t\t\t\tvar autoplay = config.autoPlayMedia;\n\n\t\t\t\t// If no global setting is available, fall back on the element's\n\t\t\t\t// own autoplay setting\n\t\t\t\tif( typeof autoplay !== 'boolean' ) {\n\t\t\t\t\tautoplay = iframe.hasAttribute( 'data-autoplay' ) || !!closestParent( iframe, '.slide-background' );\n\t\t\t\t}\n\n\t\t\t\t// YouTube postMessage API\n\t\t\t\tif( /youtube\\.com\\/embed\\//.test( iframe.getAttribute( 'src' ) ) && autoplay ) {\n\t\t\t\t\tiframe.contentWindow.postMessage( '{\"event\":\"command\",\"func\":\"playVideo\",\"args\":\"\"}', '*' );\n\t\t\t\t}\n\t\t\t\t// Vimeo postMessage API\n\t\t\t\telse if( /player\\.vimeo\\.com\\//.test( iframe.getAttribute( 'src' ) ) && autoplay ) {\n\t\t\t\t\tiframe.contentWindow.postMessage( '{\"method\":\"play\"}', '*' );\n\t\t\t\t}\n\t\t\t\t// Generic postMessage API\n\t\t\t\telse {\n\t\t\t\t\tiframe.contentWindow.postMessage( 'slide:start', '*' );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Stop playback of any embedded content inside of\n\t * the targeted slide.\n\t *\n\t * @param {HTMLElement} element\n\t */\n\tfunction stopEmbeddedContent( element, options ) {\n\n\t\toptions = extend( {\n\t\t\t// Defaults\n\t\t\tunloadIframes: true\n\t\t}, options || {} );\n\n\t\tif( element && element.parentNode ) {\n\t\t\t// HTML5 media elements\n\t\t\ttoArray( element.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {\n\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) && typeof el.pause === 'function' ) {\n\t\t\t\t\tel.setAttribute('data-paused-by-reveal', '');\n\t\t\t\t\tel.pause();\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Generic postMessage API for non-lazy loaded iframes\n\t\t\ttoArray( element.querySelectorAll( 'iframe' ) ).forEach( function( el ) {\n\t\t\t\tif( el.contentWindow ) el.contentWindow.postMessage( 'slide:stop', '*' );\n\t\t\t\tel.removeEventListener( 'load', startEmbeddedIframe );\n\t\t\t});\n\n\t\t\t// YouTube postMessage API\n\t\t\ttoArray( element.querySelectorAll( 'iframe[src*=\"youtube.com/embed/\"]' ) ).forEach( function( el ) {\n\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) && el.contentWindow && typeof el.contentWindow.postMessage === 'function' ) {\n\t\t\t\t\tel.contentWindow.postMessage( '{\"event\":\"command\",\"func\":\"pauseVideo\",\"args\":\"\"}', '*' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Vimeo postMessage API\n\t\t\ttoArray( element.querySelectorAll( 'iframe[src*=\"player.vimeo.com/\"]' ) ).forEach( function( el ) {\n\t\t\t\tif( !el.hasAttribute( 'data-ignore' ) && el.contentWindow && typeof el.contentWindow.postMessage === 'function' ) {\n\t\t\t\t\tel.contentWindow.postMessage( '{\"method\":\"pause\"}', '*' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif( options.unloadIframes === true ) {\n\t\t\t\t// Unload lazy-loaded iframes\n\t\t\t\ttoArray( element.querySelectorAll( 'iframe[data-src]' ) ).forEach( function( el ) {\n\t\t\t\t\t// Only removing the src doesn't actually unload the frame\n\t\t\t\t\t// in all browsers (Firefox) so we set it to blank first\n\t\t\t\t\tel.setAttribute( 'src', 'about:blank' );\n\t\t\t\t\tel.removeAttribute( 'src' );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the number of past slides. This can be used as a global\n\t * flattened index for slides.\n\t *\n\t * @return {number} Past slide count\n\t */\n\tfunction getSlidePastCount() {\n\n\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\n\t\t// The number of past slides\n\t\tvar pastCount = 0;\n\n\t\t// Step through all slides and count the past ones\n\t\tmainLoop: for( var i = 0; i < horizontalSlides.length; i++ ) {\n\n\t\t\tvar horizontalSlide = horizontalSlides[i];\n\t\t\tvar verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );\n\n\t\t\tfor( var j = 0; j < verticalSlides.length; j++ ) {\n\n\t\t\t\t// Stop as soon as we arrive at the present\n\t\t\t\tif( verticalSlides[j].classList.contains( 'present' ) ) {\n\t\t\t\t\tbreak mainLoop;\n\t\t\t\t}\n\n\t\t\t\tpastCount++;\n\n\t\t\t}\n\n\t\t\t// Stop as soon as we arrive at the present\n\t\t\tif( horizontalSlide.classList.contains( 'present' ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Don't count the wrapping section for vertical slides\n\t\t\tif( horizontalSlide.classList.contains( 'stack' ) === false ) {\n\t\t\t\tpastCount++;\n\t\t\t}\n\n\t\t}\n\n\t\treturn pastCount;\n\n\t}\n\n\t/**\n\t * Returns a value ranging from 0-1 that represents\n\t * how far into the presentation we have navigated.\n\t *\n\t * @return {number}\n\t */\n\tfunction getProgress() {\n\n\t\t// The number of past and total slides\n\t\tvar totalCount = getTotalSlides();\n\t\tvar pastCount = getSlidePastCount();\n\n\t\tif( currentSlide ) {\n\n\t\t\tvar allFragments = currentSlide.querySelectorAll( '.fragment' );\n\n\t\t\t// If there are fragments in the current slide those should be\n\t\t\t// accounted for in the progress.\n\t\t\tif( allFragments.length > 0 ) {\n\t\t\t\tvar visibleFragments = currentSlide.querySelectorAll( '.fragment.visible' );\n\n\t\t\t\t// This value represents how big a portion of the slide progress\n\t\t\t\t// that is made up by its fragments (0-1)\n\t\t\t\tvar fragmentWeight = 0.9;\n\n\t\t\t\t// Add fragment progress to the past slide count\n\t\t\t\tpastCount += ( visibleFragments.length / allFragments.length ) * fragmentWeight;\n\t\t\t}\n\n\t\t}\n\n\t\treturn pastCount / ( totalCount - 1 );\n\n\t}\n\n\t/**\n\t * Checks if this presentation is running inside of the\n\t * speaker notes window.\n\t *\n\t * @return {boolean}\n\t */\n\tfunction isSpeakerNotes() {\n\n\t\treturn !!window.location.search.match( /receiver/gi );\n\n\t}\n\n\t/**\n\t * Reads the current URL (hash) and navigates accordingly.\n\t */\n\tfunction readURL() {\n\n\t\tvar hash = window.location.hash;\n\n\t\t// Attempt to parse the hash as either an index or name\n\t\tvar bits = hash.slice( 2 ).split( '/' ),\n\t\t\tname = hash.replace( /#|\\//gi, '' );\n\n\t\t// If the first bit is invalid and there is a name we can\n\t\t// assume that this is a named link\n\t\tif( isNaN( parseInt( bits[0], 10 ) ) && name.length ) {\n\t\t\tvar element;\n\n\t\t\t// Ensure the named link is a valid HTML ID attribute\n\t\t\ttry {\n\t\t\t\telement = document.getElementById( decodeURIComponent( name ) );\n\t\t\t}\n\t\t\tcatch ( error ) { }\n\n\t\t\t// Ensure that we're not already on a slide with the same name\n\t\t\tvar isSameNameAsCurrentSlide = currentSlide ? currentSlide.getAttribute( 'id' ) === name : false;\n\n\t\t\tif( element && !isSameNameAsCurrentSlide ) {\n\t\t\t\t// Find the position of the named slide and navigate to it\n\t\t\t\tvar indices = Reveal.getIndices( element );\n\t\t\t\tslide( indices.h, indices.v );\n\t\t\t}\n\t\t\t// If the slide doesn't exist, navigate to the current slide\n\t\t\telse {\n\t\t\t\tslide( indexh || 0, indexv || 0 );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvar hashIndexBase = config.hashOneBasedIndex ? 1 : 0;\n\n\t\t\t// Read the index components of the hash\n\t\t\tvar h = ( parseInt( bits[0], 10 ) - hashIndexBase ) || 0,\n\t\t\t\tv = ( parseInt( bits[1], 10 ) - hashIndexBase ) || 0,\n\t\t\t\tf;\n\n\t\t\tif( config.fragmentInURL ) {\n\t\t\t\tf = parseInt( bits[2], 10 );\n\t\t\t\tif( isNaN( f ) ) {\n\t\t\t\t\tf = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( h !== indexh || v !== indexv || f !== undefined ) {\n\t\t\t\tslide( h, v, f );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the page URL (hash) to reflect the current\n\t * state.\n\t *\n\t * @param {number} delay The time in ms to wait before\n\t * writing the hash\n\t */\n\tfunction writeURL( delay ) {\n\n\t\tif( config.history ) {\n\n\t\t\t// Make sure there's never more than one timeout running\n\t\t\tclearTimeout( writeURLTimeout );\n\n\t\t\t// If a delay is specified, timeout this call\n\t\t\tif( typeof delay === 'number' ) {\n\t\t\t\twriteURLTimeout = setTimeout( writeURL, delay );\n\t\t\t}\n\t\t\telse if( currentSlide ) {\n\t\t\t\twindow.location.hash = locationHash();\n\t\t\t}\n\t\t}\n\n\t}\n\t/**\n\t * Retrieves the h/v location and fragment of the current,\n\t * or specified, slide.\n\t *\n\t * @param {HTMLElement} [slide] If specified, the returned\n\t * index will be for this slide rather than the currently\n\t * active one\n\t *\n\t * @return {{h: number, v: number, f: number}}\n\t */\n\tfunction getIndices( slide ) {\n\n\t\t// By default, return the current indices\n\t\tvar h = indexh,\n\t\t\tv = indexv,\n\t\t\tf;\n\n\t\t// If a slide is specified, return the indices of that slide\n\t\tif( slide ) {\n\t\t\tvar isVertical = isVerticalSlide( slide );\n\t\t\tvar slideh = isVertical ? slide.parentNode : slide;\n\n\t\t\t// Select all horizontal slides\n\t\t\tvar horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\n\t\t\t// Now that we know which the horizontal slide is, get its index\n\t\t\th = Math.max( horizontalSlides.indexOf( slideh ), 0 );\n\n\t\t\t// Assume we're not vertical\n\t\t\tv = undefined;\n\n\t\t\t// If this is a vertical slide, grab the vertical index\n\t\t\tif( isVertical ) {\n\t\t\t\tv = Math.max( toArray( slide.parentNode.querySelectorAll( 'section' ) ).indexOf( slide ), 0 );\n\t\t\t}\n\t\t}\n\n\t\tif( !slide && currentSlide ) {\n\t\t\tvar hasFragments = currentSlide.querySelectorAll( '.fragment' ).length > 0;\n\t\t\tif( hasFragments ) {\n\t\t\t\tvar currentFragment = currentSlide.querySelector( '.current-fragment' );\n\t\t\t\tif( currentFragment && currentFragment.hasAttribute( 'data-fragment-index' ) ) {\n\t\t\t\t\tf = parseInt( currentFragment.getAttribute( 'data-fragment-index' ), 10 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tf = currentSlide.querySelectorAll( '.fragment.visible' ).length - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { h: h, v: v, f: f };\n\n\t}\n\n\t/**\n\t * Retrieves all slides in this presentation.\n\t */\n\tfunction getSlides() {\n\n\t\treturn toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ':not(.stack)' ));\n\n\t}\n\n\t/**\n\t * Retrieves the total number of slides in this presentation.\n\t *\n\t * @return {number}\n\t */\n\tfunction getTotalSlides() {\n\n\t\treturn getSlides().length;\n\n\t}\n\n\t/**\n\t * Returns the slide element matching the specified index.\n\t *\n\t * @return {HTMLElement}\n\t */\n\tfunction getSlide( x, y ) {\n\n\t\tvar horizontalSlide = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR )[ x ];\n\t\tvar verticalSlides = horizontalSlide && horizontalSlide.querySelectorAll( 'section' );\n\n\t\tif( verticalSlides && verticalSlides.length && typeof y === 'number' ) {\n\t\t\treturn verticalSlides ? verticalSlides[ y ] : undefined;\n\t\t}\n\n\t\treturn horizontalSlide;\n\n\t}\n\n\t/**\n\t * Returns the background element for the given slide.\n\t * All slides, even the ones with no background properties\n\t * defined, have a background element so as long as the\n\t * index is valid an element will be returned.\n\t *\n\t * @param {mixed} x Horizontal background index OR a slide\n\t * HTML element\n\t * @param {number} y Vertical background index\n\t * @return {(HTMLElement[]|*)}\n\t */\n\tfunction getSlideBackground( x, y ) {\n\n\t\tvar slide = typeof x === 'number' ? getSlide( x, y ) : x;\n\t\tif( slide ) {\n\t\t\treturn slide.slideBackgroundElement;\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\t/**\n\t * Retrieves the speaker notes from a slide. Notes can be\n\t * defined in two ways:\n\t * 1. As a data-notes attribute on the slide <section>\n\t * 2. As an <aside class=\"notes\"> inside of the slide\n\t *\n\t * @param {HTMLElement} [slide=currentSlide]\n\t * @return {(string|null)}\n\t */\n\tfunction getSlideNotes( slide ) {\n\n\t\t// Default to the current slide\n\t\tslide = slide || currentSlide;\n\n\t\t// Notes can be specified via the data-notes attribute...\n\t\tif( slide.hasAttribute( 'data-notes' ) ) {\n\t\t\treturn slide.getAttribute( 'data-notes' );\n\t\t}\n\n\t\t// ... or using an <aside class=\"notes\"> element\n\t\tvar notesElement = slide.querySelector( 'aside.notes' );\n\t\tif( notesElement ) {\n\t\t\treturn notesElement.innerHTML;\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Retrieves the current state of the presentation as\n\t * an object. This state can then be restored at any\n\t * time.\n\t *\n\t * @return {{indexh: number, indexv: number, indexf: number, paused: boolean, overview: boolean}}\n\t */\n\tfunction getState() {\n\n\t\tvar indices = getIndices();\n\n\t\treturn {\n\t\t\tindexh: indices.h,\n\t\t\tindexv: indices.v,\n\t\t\tindexf: indices.f,\n\t\t\tpaused: isPaused(),\n\t\t\toverview: isOverview()\n\t\t};\n\n\t}\n\n\t/**\n\t * Restores the presentation to the given state.\n\t *\n\t * @param {object} state As generated by getState()\n\t * @see {@link getState} generates the parameter `state`\n\t */\n\tfunction setState( state ) {\n\n\t\tif( typeof state === 'object' ) {\n\t\t\tslide( deserialize( state.indexh ), deserialize( state.indexv ), deserialize( state.indexf ) );\n\n\t\t\tvar pausedFlag = deserialize( state.paused ),\n\t\t\t\toverviewFlag = deserialize( state.overview );\n\n\t\t\tif( typeof pausedFlag === 'boolean' && pausedFlag !== isPaused() ) {\n\t\t\t\ttogglePause( pausedFlag );\n\t\t\t}\n\n\t\t\tif( typeof overviewFlag === 'boolean' && overviewFlag !== isOverview() ) {\n\t\t\t\ttoggleOverview( overviewFlag );\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Return a sorted fragments list, ordered by an increasing\n\t * \"data-fragment-index\" attribute.\n\t *\n\t * Fragments will be revealed in the order that they are returned by\n\t * this function, so you can use the index attributes to control the\n\t * order of fragment appearance.\n\t *\n\t * To maintain a sensible default fragment order, fragments are presumed\n\t * to be passed in document order. This function adds a \"fragment-index\"\n\t * attribute to each node if such an attribute is not already present,\n\t * and sets that attribute to an integer value which is the position of\n\t * the fragment within the fragments list.\n\t *\n\t * @param {object[]|*} fragments\n\t * @param {boolean} grouped If true the returned array will contain\n\t * nested arrays for all fragments with the same index\n\t * @return {object[]} sorted Sorted array of fragments\n\t */\n\tfunction sortFragments( fragments, grouped ) {\n\n\t\tfragments = toArray( fragments );\n\n\t\tvar ordered = [],\n\t\t\tunordered = [],\n\t\t\tsorted = [];\n\n\t\t// Group ordered and unordered elements\n\t\tfragments.forEach( function( fragment, i ) {\n\t\t\tif( fragment.hasAttribute( 'data-fragment-index' ) ) {\n\t\t\t\tvar index = parseInt( fragment.getAttribute( 'data-fragment-index' ), 10 );\n\n\t\t\t\tif( !ordered[index] ) {\n\t\t\t\t\tordered[index] = [];\n\t\t\t\t}\n\n\t\t\t\tordered[index].push( fragment );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunordered.push( [ fragment ] );\n\t\t\t}\n\t\t} );\n\n\t\t// Append fragments without explicit indices in their\n\t\t// DOM order\n\t\tordered = ordered.concat( unordered );\n\n\t\t// Manually count the index up per group to ensure there\n\t\t// are no gaps\n\t\tvar index = 0;\n\n\t\t// Push all fragments in their sorted order to an array,\n\t\t// this flattens the groups\n\t\tordered.forEach( function( group ) {\n\t\t\tgroup.forEach( function( fragment ) {\n\t\t\t\tsorted.push( fragment );\n\t\t\t\tfragment.setAttribute( 'data-fragment-index', index );\n\t\t\t} );\n\n\t\t\tindex ++;\n\t\t} );\n\n\t\treturn grouped === true ? ordered : sorted;\n\n\t}\n\n\t/**\n\t * Navigate to the specified slide fragment.\n\t *\n\t * @param {?number} index The index of the fragment that\n\t * should be shown, -1 means all are invisible\n\t * @param {number} offset Integer offset to apply to the\n\t * fragment index\n\t *\n\t * @return {boolean} true if a change was made in any\n\t * fragments visibility as part of this call\n\t */\n\tfunction navigateFragment( index, offset ) {\n\n\t\tif( currentSlide && config.fragments ) {\n\n\t\t\tvar fragments = sortFragments( currentSlide.querySelectorAll( '.fragment' ) );\n\t\t\tif( fragments.length ) {\n\n\t\t\t\t// If no index is specified, find the current\n\t\t\t\tif( typeof index !== 'number' ) {\n\t\t\t\t\tvar lastVisibleFragment = sortFragments( currentSlide.querySelectorAll( '.fragment.visible' ) ).pop();\n\n\t\t\t\t\tif( lastVisibleFragment ) {\n\t\t\t\t\t\tindex = parseInt( lastVisibleFragment.getAttribute( 'data-fragment-index' ) || 0, 10 );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If an offset is specified, apply it to the index\n\t\t\t\tif( typeof offset === 'number' ) {\n\t\t\t\t\tindex += offset;\n\t\t\t\t}\n\n\t\t\t\tvar fragmentsShown = [],\n\t\t\t\t\tfragmentsHidden = [];\n\n\t\t\t\ttoArray( fragments ).forEach( function( element, i ) {\n\n\t\t\t\t\tif( element.hasAttribute( 'data-fragment-index' ) ) {\n\t\t\t\t\t\ti = parseInt( element.getAttribute( 'data-fragment-index' ), 10 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Visible fragments\n\t\t\t\t\tif( i <= index ) {\n\t\t\t\t\t\tif( !element.classList.contains( 'visible' ) ) fragmentsShown.push( element );\n\t\t\t\t\t\telement.classList.add( 'visible' );\n\t\t\t\t\t\telement.classList.remove( 'current-fragment' );\n\n\t\t\t\t\t\t// Announce the fragments one by one to the Screen Reader\n\t\t\t\t\t\tdom.statusDiv.textContent = getStatusText( element );\n\n\t\t\t\t\t\tif( i === index ) {\n\t\t\t\t\t\t\telement.classList.add( 'current-fragment' );\n\t\t\t\t\t\t\tstartEmbeddedContent( element );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Hidden fragments\n\t\t\t\t\telse {\n\t\t\t\t\t\tif( element.classList.contains( 'visible' ) ) fragmentsHidden.push( element );\n\t\t\t\t\t\telement.classList.remove( 'visible' );\n\t\t\t\t\t\telement.classList.remove( 'current-fragment' );\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif( fragmentsHidden.length ) {\n\t\t\t\t\tdispatchEvent( 'fragmenthidden', { fragment: fragmentsHidden[0], fragments: fragmentsHidden } );\n\t\t\t\t}\n\n\t\t\t\tif( fragmentsShown.length ) {\n\t\t\t\t\tdispatchEvent( 'fragmentshown', { fragment: fragmentsShown[0], fragments: fragmentsShown } );\n\t\t\t\t}\n\n\t\t\t\tupdateControls();\n\t\t\t\tupdateProgress();\n\t\t\t\tif( config.fragmentInURL ) {\n\t\t\t\t\twriteURL();\n\t\t\t\t}\n\n\t\t\t\treturn !!( fragmentsShown.length || fragmentsHidden.length );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Navigate to the next slide fragment.\n\t *\n\t * @return {boolean} true if there was a next fragment,\n\t * false otherwise\n\t */\n\tfunction nextFragment() {\n\n\t\treturn navigateFragment( null, 1 );\n\n\t}\n\n\t/**\n\t * Navigate to the previous slide fragment.\n\t *\n\t * @return {boolean} true if there was a previous fragment,\n\t * false otherwise\n\t */\n\tfunction previousFragment() {\n\n\t\treturn navigateFragment( null, -1 );\n\n\t}\n\n\t/**\n\t * Cues a new automated slide if enabled in the config.\n\t */\n\tfunction cueAutoSlide() {\n\n\t\tcancelAutoSlide();\n\n\t\tif( currentSlide && config.autoSlide !== false ) {\n\n\t\t\tvar fragment = currentSlide.querySelector( '.current-fragment' );\n\n\t\t\t// When the slide first appears there is no \"current\" fragment so\n\t\t\t// we look for a data-autoslide timing on the first fragment\n\t\t\tif( !fragment ) fragment = currentSlide.querySelector( '.fragment' );\n\n\t\t\tvar fragmentAutoSlide = fragment ? fragment.getAttribute( 'data-autoslide' ) : null;\n\t\t\tvar parentAutoSlide = currentSlide.parentNode ? currentSlide.parentNode.getAttribute( 'data-autoslide' ) : null;\n\t\t\tvar slideAutoSlide = currentSlide.getAttribute( 'data-autoslide' );\n\n\t\t\t// Pick value in the following priority order:\n\t\t\t// 1. Current fragment's data-autoslide\n\t\t\t// 2. Current slide's data-autoslide\n\t\t\t// 3. Parent slide's data-autoslide\n\t\t\t// 4. Global autoSlide setting\n\t\t\tif( fragmentAutoSlide ) {\n\t\t\t\tautoSlide = parseInt( fragmentAutoSlide, 10 );\n\t\t\t}\n\t\t\telse if( slideAutoSlide ) {\n\t\t\t\tautoSlide = parseInt( slideAutoSlide, 10 );\n\t\t\t}\n\t\t\telse if( parentAutoSlide ) {\n\t\t\t\tautoSlide = parseInt( parentAutoSlide, 10 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tautoSlide = config.autoSlide;\n\t\t\t}\n\n\t\t\t// If there are media elements with data-autoplay,\n\t\t\t// automatically set the autoSlide duration to the\n\t\t\t// length of that media. Not applicable if the slide\n\t\t\t// is divided up into fragments.\n\t\t\t// playbackRate is accounted for in the duration.\n\t\t\tif( currentSlide.querySelectorAll( '.fragment' ).length === 0 ) {\n\t\t\t\ttoArray( currentSlide.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {\n\t\t\t\t\tif( el.hasAttribute( 'data-autoplay' ) ) {\n\t\t\t\t\t\tif( autoSlide && (el.duration * 1000 / el.playbackRate ) > autoSlide ) {\n\t\t\t\t\t\t\tautoSlide = ( el.duration * 1000 / el.playbackRate ) + 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Cue the next auto-slide if:\n\t\t\t// - There is an autoSlide value\n\t\t\t// - Auto-sliding isn't paused by the user\n\t\t\t// - The presentation isn't paused\n\t\t\t// - The overview isn't active\n\t\t\t// - The presentation isn't over\n\t\t\tif( autoSlide && !autoSlidePaused && !isPaused() && !isOverview() && ( !Reveal.isLastSlide() || availableFragments().next || config.loop === true ) ) {\n\t\t\t\tautoSlideTimeout = setTimeout( function() {\n\t\t\t\t\ttypeof config.autoSlideMethod === 'function' ? config.autoSlideMethod() : navigateNext();\n\t\t\t\t\tcueAutoSlide();\n\t\t\t\t}, autoSlide );\n\t\t\t\tautoSlideStartTime = Date.now();\n\t\t\t}\n\n\t\t\tif( autoSlidePlayer ) {\n\t\t\t\tautoSlidePlayer.setPlaying( autoSlideTimeout !== -1 );\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Cancels any ongoing request to auto-slide.\n\t */\n\tfunction cancelAutoSlide() {\n\n\t\tclearTimeout( autoSlideTimeout );\n\t\tautoSlideTimeout = -1;\n\n\t}\n\n\tfunction pauseAutoSlide() {\n\n\t\tif( autoSlide && !autoSlidePaused ) {\n\t\t\tautoSlidePaused = true;\n\t\t\tdispatchEvent( 'autoslidepaused' );\n\t\t\tclearTimeout( autoSlideTimeout );\n\n\t\t\tif( autoSlidePlayer ) {\n\t\t\t\tautoSlidePlayer.setPlaying( false );\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfunction resumeAutoSlide() {\n\n\t\tif( autoSlide && autoSlidePaused ) {\n\t\t\tautoSlidePaused = false;\n\t\t\tdispatchEvent( 'autoslideresumed' );\n\t\t\tcueAutoSlide();\n\t\t}\n\n\t}\n\n\tfunction navigateLeft() {\n\n\t\t// Reverse for RTL\n\t\tif( config.rtl ) {\n\t\t\tif( ( isOverview() || nextFragment() === false ) && availableRoutes().left ) {\n\t\t\t\tslide( indexh + 1 );\n\t\t\t}\n\t\t}\n\t\t// Normal navigation\n\t\telse if( ( isOverview() || previousFragment() === false ) && availableRoutes().left ) {\n\t\t\tslide( indexh - 1 );\n\t\t}\n\n\t}\n\n\tfunction navigateRight() {\n\n\t\thasNavigatedRight = true;\n\n\t\t// Reverse for RTL\n\t\tif( config.rtl ) {\n\t\t\tif( ( isOverview() || previousFragment() === false ) && availableRoutes().right ) {\n\t\t\t\tslide( indexh - 1 );\n\t\t\t}\n\t\t}\n\t\t// Normal navigation\n\t\telse if( ( isOverview() || nextFragment() === false ) && availableRoutes().right ) {\n\t\t\tslide( indexh + 1 );\n\t\t}\n\n\t}\n\n\tfunction navigateUp() {\n\n\t\t// Prioritize hiding fragments\n\t\tif( ( isOverview() || previousFragment() === false ) && availableRoutes().up ) {\n\t\t\tslide( indexh, indexv - 1 );\n\t\t}\n\n\t}\n\n\tfunction navigateDown() {\n\n\t\thasNavigatedDown = true;\n\n\t\t// Prioritize revealing fragments\n\t\tif( ( isOverview() || nextFragment() === false ) && availableRoutes().down ) {\n\t\t\tslide( indexh, indexv + 1 );\n\t\t}\n\n\t}\n\n\t/**\n\t * Navigates backwards, prioritized in the following order:\n\t * 1) Previous fragment\n\t * 2) Previous vertical slide\n\t * 3) Previous horizontal slide\n\t */\n\tfunction navigatePrev() {\n\n\t\t// Prioritize revealing fragments\n\t\tif( previousFragment() === false ) {\n\t\t\tif( availableRoutes().up ) {\n\t\t\t\tnavigateUp();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fetch the previous horizontal slide, if there is one\n\t\t\t\tvar previousSlide;\n\n\t\t\t\tif( config.rtl ) {\n\t\t\t\t\tpreviousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.future' ) ).pop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpreviousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.past' ) ).pop();\n\t\t\t\t}\n\n\t\t\t\tif( previousSlide ) {\n\t\t\t\t\tvar v = ( previousSlide.querySelectorAll( 'section' ).length - 1 ) || undefined;\n\t\t\t\t\tvar h = indexh - 1;\n\t\t\t\t\tslide( h, v );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * The reverse of #navigatePrev().\n\t */\n\tfunction navigateNext() {\n\n\t\thasNavigatedRight = true;\n\t\thasNavigatedDown = true;\n\n\t\t// Prioritize revealing fragments\n\t\tif( nextFragment() === false ) {\n\n\t\t\tvar routes = availableRoutes();\n\n\t\t\t// When looping is enabled `routes.down` is always available\n\t\t\t// so we need a separate check for when we've reached the\n\t\t\t// end of a stack and should move horizontally\n\t\t\tif( routes.down && routes.right && config.loop && Reveal.isLastVerticalSlide( currentSlide ) ) {\n\t\t\t\troutes.down = false;\n\t\t\t}\n\n\t\t\tif( routes.down ) {\n\t\t\t\tnavigateDown();\n\t\t\t}\n\t\t\telse if( config.rtl ) {\n\t\t\t\tnavigateLeft();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnavigateRight();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the target element prevents the triggering of\n\t * swipe navigation.\n\t */\n\tfunction isSwipePrevented( target ) {\n\n\t\twhile( target && typeof target.hasAttribute === 'function' ) {\n\t\t\tif( target.hasAttribute( 'data-prevent-swipe' ) ) return true;\n\t\t\ttarget = target.parentNode;\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\t// --------------------------------------------------------------------//\n\t// ----------------------------- EVENTS -------------------------------//\n\t// --------------------------------------------------------------------//\n\n\t/**\n\t * Called by all event handlers that are based on user\n\t * input.\n\t *\n\t * @param {object} [event]\n\t */\n\tfunction onUserInput( event ) {\n\n\t\tif( config.autoSlideStoppable ) {\n\t\t\tpauseAutoSlide();\n\t\t}\n\n\t}\n\n\t/**\n\t * Handler for the document level 'keypress' event.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onDocumentKeyPress( event ) {\n\n\t\t// Check if the pressed key is question mark\n\t\tif( event.shiftKey && event.charCode === 63 ) {\n\t\t\ttoggleHelp();\n\t\t}\n\n\t}\n\n\t/**\n\t * Handler for the document level 'keydown' event.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onDocumentKeyDown( event ) {\n\n\t\t// If there's a condition specified and it returns false,\n\t\t// ignore this event\n\t\tif( typeof config.keyboardCondition === 'function' && config.keyboardCondition(event) === false ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Remember if auto-sliding was paused so we can toggle it\n\t\tvar autoSlideWasPaused = autoSlidePaused;\n\n\t\tonUserInput( event );\n\n\t\t// Check if there's a focused element that could be using\n\t\t// the keyboard\n\t\tvar activeElementIsCE = document.activeElement && document.activeElement.contentEditable !== 'inherit';\n\t\tvar activeElementIsInput = document.activeElement && document.activeElement.tagName && /input|textarea/i.test( document.activeElement.tagName );\n\t\tvar activeElementIsNotes = document.activeElement && document.activeElement.className && /speaker-notes/i.test( document.activeElement.className);\n\n\t\t// Disregard the event if there's a focused element or a\n\t\t// keyboard modifier key is present\n\t\tif( activeElementIsCE || activeElementIsInput || activeElementIsNotes || (event.shiftKey && event.keyCode !== 32) || event.altKey || event.ctrlKey || event.metaKey ) return;\n\n\t\t// While paused only allow resume keyboard events; 'b', 'v', '.'\n\t\tvar resumeKeyCodes = [66,86,190,191];\n\t\tvar key;\n\n\t\t// Custom key bindings for togglePause should be able to resume\n\t\tif( typeof config.keyboard === 'object' ) {\n\t\t\tfor( key in config.keyboard ) {\n\t\t\t\tif( config.keyboard[key] === 'togglePause' ) {\n\t\t\t\t\tresumeKeyCodes.push( parseInt( key, 10 ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( isPaused() && resumeKeyCodes.indexOf( event.keyCode ) === -1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar triggered = false;\n\n\t\t// 1. User defined key bindings\n\t\tif( typeof config.keyboard === 'object' ) {\n\n\t\t\tfor( key in config.keyboard ) {\n\n\t\t\t\t// Check if this binding matches the pressed key\n\t\t\t\tif( parseInt( key, 10 ) === event.keyCode ) {\n\n\t\t\t\t\tvar value = config.keyboard[ key ];\n\n\t\t\t\t\t// Callback function\n\t\t\t\t\tif( typeof value === 'function' ) {\n\t\t\t\t\t\tvalue.apply( null, [ event ] );\n\t\t\t\t\t}\n\t\t\t\t\t// String shortcuts to reveal.js API\n\t\t\t\t\telse if( typeof value === 'string' && typeof Reveal[ value ] === 'function' ) {\n\t\t\t\t\t\tReveal[ value ].call();\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggered = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 2. Registered custom key bindings\n\t\tif( triggered === false ) {\n\n\t\t\tfor( key in registeredKeyBindings ) {\n\n\t\t\t\t// Check if this binding matches the pressed key\n\t\t\t\tif( parseInt( key, 10 ) === event.keyCode ) {\n\n\t\t\t\t\tvar action = registeredKeyBindings[ key ].callback;\n\n\t\t\t\t\t// Callback function\n\t\t\t\t\tif( typeof action === 'function' ) {\n\t\t\t\t\t\taction.apply( null, [ event ] );\n\t\t\t\t\t}\n\t\t\t\t\t// String shortcuts to reveal.js API\n\t\t\t\t\telse if( typeof action === 'string' && typeof Reveal[ action ] === 'function' ) {\n\t\t\t\t\t\tReveal[ action ].call();\n\t\t\t\t\t}\n\n\t\t\t\t\ttriggered = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 3. System defined key bindings\n\t\tif( triggered === false ) {\n\n\t\t\t// Assume true and try to prove false\n\t\t\ttriggered = true;\n\n\t\t\tswitch( event.keyCode ) {\n\t\t\t\t// p, page up\n\t\t\t\tcase 80: case 33: navigatePrev(); break;\n\t\t\t\t// n, page down\n\t\t\t\tcase 78: case 34: navigateNext(); break;\n\t\t\t\t// h, left\n\t\t\t\tcase 72: case 37: navigateLeft(); break;\n\t\t\t\t// l, right\n\t\t\t\tcase 76: case 39: navigateRight(); break;\n\t\t\t\t// k, up\n\t\t\t\tcase 75: case 38: navigateUp(); break;\n\t\t\t\t// j, down\n\t\t\t\tcase 74: case 40: navigateDown(); break;\n\t\t\t\t// home\n\t\t\t\tcase 36: slide( 0 ); break;\n\t\t\t\t// end\n\t\t\t\tcase 35: slide( Number.MAX_VALUE ); break;\n\t\t\t\t// space\n\t\t\t\tcase 32: isOverview() ? deactivateOverview() : event.shiftKey ? navigatePrev() : navigateNext(); break;\n\t\t\t\t// return\n\t\t\t\tcase 13: isOverview() ? deactivateOverview() : triggered = false; break;\n\t\t\t\t// two-spot, semicolon, b, v, period, Logitech presenter tools \"black screen\" button\n\t\t\t\tcase 58: case 59: case 66: case 86: case 190: case 191: togglePause(); break;\n\t\t\t\t// f\n\t\t\t\tcase 70: enterFullscreen(); break;\n\t\t\t\t// a\n\t\t\t\tcase 65: if ( config.autoSlideStoppable ) toggleAutoSlide( autoSlideWasPaused ); break;\n\t\t\t\tdefault:\n\t\t\t\t\ttriggered = false;\n\t\t\t}\n\n\t\t}\n\n\t\t// If the input resulted in a triggered action we should prevent\n\t\t// the browsers default behavior\n\t\tif( triggered ) {\n\t\t\tevent.preventDefault && event.preventDefault();\n\t\t}\n\t\t// ESC or O key\n\t\telse if ( ( event.keyCode === 27 || event.keyCode === 79 ) && features.transforms3d ) {\n\t\t\tif( dom.overlay ) {\n\t\t\t\tcloseOverlay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoggleOverview();\n\t\t\t}\n\n\t\t\tevent.preventDefault && event.preventDefault();\n\t\t}\n\n\t\t// If auto-sliding is enabled we need to cue up\n\t\t// another timeout\n\t\tcueAutoSlide();\n\n\t}\n\n\t/**\n\t * Handler for the 'touchstart' event, enables support for\n\t * swipe and pinch gestures.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onTouchStart( event ) {\n\n\t\tif( isSwipePrevented( event.target ) ) return true;\n\n\t\ttouch.startX = event.touches[0].clientX;\n\t\ttouch.startY = event.touches[0].clientY;\n\t\ttouch.startCount = event.touches.length;\n\n\t\t// If there's two touches we need to memorize the distance\n\t\t// between those two points to detect pinching\n\t\tif( event.touches.length === 2 && config.overview ) {\n\t\t\ttouch.startSpan = distanceBetween( {\n\t\t\t\tx: event.touches[1].clientX,\n\t\t\t\ty: event.touches[1].clientY\n\t\t\t}, {\n\t\t\t\tx: touch.startX,\n\t\t\t\ty: touch.startY\n\t\t\t} );\n\t\t}\n\n\t}\n\n\t/**\n\t * Handler for the 'touchmove' event.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onTouchMove( event ) {\n\n\t\tif( isSwipePrevented( event.target ) ) return true;\n\n\t\t// Each touch should only trigger one action\n\t\tif( !touch.captured ) {\n\t\t\tonUserInput( event );\n\n\t\t\tvar currentX = event.touches[0].clientX;\n\t\t\tvar currentY = event.touches[0].clientY;\n\n\t\t\t// If the touch started with two points and still has\n\t\t\t// two active touches; test for the pinch gesture\n\t\t\tif( event.touches.length === 2 && touch.startCount === 2 && config.overview ) {\n\n\t\t\t\t// The current distance in pixels between the two touch points\n\t\t\t\tvar currentSpan = distanceBetween( {\n\t\t\t\t\tx: event.touches[1].clientX,\n\t\t\t\t\ty: event.touches[1].clientY\n\t\t\t\t}, {\n\t\t\t\t\tx: touch.startX,\n\t\t\t\t\ty: touch.startY\n\t\t\t\t} );\n\n\t\t\t\t// If the span is larger than the desire amount we've got\n\t\t\t\t// ourselves a pinch\n\t\t\t\tif( Math.abs( touch.startSpan - currentSpan ) > touch.threshold ) {\n\t\t\t\t\ttouch.captured = true;\n\n\t\t\t\t\tif( currentSpan < touch.startSpan ) {\n\t\t\t\t\t\tactivateOverview();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdeactivateOverview();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t}\n\t\t\t// There was only one touch point, look for a swipe\n\t\t\telse if( event.touches.length === 1 && touch.startCount !== 2 ) {\n\n\t\t\t\tvar deltaX = currentX - touch.startX,\n\t\t\t\t\tdeltaY = currentY - touch.startY;\n\n\t\t\t\tif( deltaX > touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {\n\t\t\t\t\ttouch.captured = true;\n\t\t\t\t\tnavigateLeft();\n\t\t\t\t}\n\t\t\t\telse if( deltaX < -touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {\n\t\t\t\t\ttouch.captured = true;\n\t\t\t\t\tnavigateRight();\n\t\t\t\t}\n\t\t\t\telse if( deltaY > touch.threshold ) {\n\t\t\t\t\ttouch.captured = true;\n\t\t\t\t\tnavigateUp();\n\t\t\t\t}\n\t\t\t\telse if( deltaY < -touch.threshold ) {\n\t\t\t\t\ttouch.captured = true;\n\t\t\t\t\tnavigateDown();\n\t\t\t\t}\n\n\t\t\t\t// If we're embedded, only block touch events if they have\n\t\t\t\t// triggered an action\n\t\t\t\tif( config.embedded ) {\n\t\t\t\t\tif( touch.captured || isVerticalSlide( currentSlide ) ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Not embedded? Block them all to avoid needless tossing\n\t\t\t\t// around of the viewport in iOS\n\t\t\t\telse {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t// There's a bug with swiping on some Android devices unless\n\t\t// the default action is always prevented\n\t\telse if( UA.match( /android/gi ) ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t}\n\n\t/**\n\t * Handler for the 'touchend' event.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onTouchEnd( event ) {\n\n\t\ttouch.captured = false;\n\n\t}\n\n\t/**\n\t * Convert pointer down to touch start.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onPointerDown( event ) {\n\n\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" ) {\n\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];\n\t\t\tonTouchStart( event );\n\t\t}\n\n\t}\n\n\t/**\n\t * Convert pointer move to touch move.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onPointerMove( event ) {\n\n\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" )  {\n\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];\n\t\t\tonTouchMove( event );\n\t\t}\n\n\t}\n\n\t/**\n\t * Convert pointer up to touch end.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onPointerUp( event ) {\n\n\t\tif( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === \"touch\" )  {\n\t\t\tevent.touches = [{ clientX: event.clientX, clientY: event.clientY }];\n\t\t\tonTouchEnd( event );\n\t\t}\n\n\t}\n\n\t/**\n\t * Handles mouse wheel scrolling, throttled to avoid skipping\n\t * multiple slides.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onDocumentMouseScroll( event ) {\n\n\t\tif( Date.now() - lastMouseWheelStep > 600 ) {\n\n\t\t\tlastMouseWheelStep = Date.now();\n\n\t\t\tvar delta = event.detail || -event.wheelDelta;\n\t\t\tif( delta > 0 ) {\n\t\t\t\tnavigateNext();\n\t\t\t}\n\t\t\telse if( delta < 0 ) {\n\t\t\t\tnavigatePrev();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Clicking on the progress bar results in a navigation to the\n\t * closest approximate horizontal slide using this equation:\n\t *\n\t * ( clickX / presentationWidth ) * numberOfSlides\n\t *\n\t * @param {object} event\n\t */\n\tfunction onProgressClicked( event ) {\n\n\t\tonUserInput( event );\n\n\t\tevent.preventDefault();\n\n\t\tvar slidesTotal = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).length;\n\t\tvar slideIndex = Math.floor( ( event.clientX / dom.wrapper.offsetWidth ) * slidesTotal );\n\n\t\tif( config.rtl ) {\n\t\t\tslideIndex = slidesTotal - slideIndex;\n\t\t}\n\n\t\tslide( slideIndex );\n\n\t}\n\n\t/**\n\t * Event handler for navigation control buttons.\n\t */\n\tfunction onNavigateLeftClicked( event ) { event.preventDefault(); onUserInput(); navigateLeft(); }\n\tfunction onNavigateRightClicked( event ) { event.preventDefault(); onUserInput(); navigateRight(); }\n\tfunction onNavigateUpClicked( event ) { event.preventDefault(); onUserInput(); navigateUp(); }\n\tfunction onNavigateDownClicked( event ) { event.preventDefault(); onUserInput(); navigateDown(); }\n\tfunction onNavigatePrevClicked( event ) { event.preventDefault(); onUserInput(); navigatePrev(); }\n\tfunction onNavigateNextClicked( event ) { event.preventDefault(); onUserInput(); navigateNext(); }\n\n\t/**\n\t * Handler for the window level 'hashchange' event.\n\t *\n\t * @param {object} [event]\n\t */\n\tfunction onWindowHashChange( event ) {\n\n\t\treadURL();\n\n\t}\n\n\t/**\n\t * Handler for the window level 'resize' event.\n\t *\n\t * @param {object} [event]\n\t */\n\tfunction onWindowResize( event ) {\n\n\t\tlayout();\n\n\t}\n\n\t/**\n\t * Handle for the window level 'visibilitychange' event.\n\t *\n\t * @param {object} [event]\n\t */\n\tfunction onPageVisibilityChange( event ) {\n\n\t\tvar isHidden =  document.webkitHidden ||\n\t\t\t\t\t\tdocument.msHidden ||\n\t\t\t\t\t\tdocument.hidden;\n\n\t\t// If, after clicking a link or similar and we're coming back,\n\t\t// focus the document.body to ensure we can use keyboard shortcuts\n\t\tif( isHidden === false && document.activeElement !== document.body ) {\n\t\t\t// Not all elements support .blur() - SVGs among them.\n\t\t\tif( typeof document.activeElement.blur === 'function' ) {\n\t\t\t\tdocument.activeElement.blur();\n\t\t\t}\n\t\t\tdocument.body.focus();\n\t\t}\n\n\t}\n\n\t/**\n\t * Invoked when a slide is and we're in the overview.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onOverviewSlideClicked( event ) {\n\n\t\t// TODO There's a bug here where the event listeners are not\n\t\t// removed after deactivating the overview.\n\t\tif( eventsAreBound && isOverview() ) {\n\t\t\tevent.preventDefault();\n\n\t\t\tvar element = event.target;\n\n\t\t\twhile( element && !element.nodeName.match( /section/gi ) ) {\n\t\t\t\telement = element.parentNode;\n\t\t\t}\n\n\t\t\tif( element && !element.classList.contains( 'disabled' ) ) {\n\n\t\t\t\tdeactivateOverview();\n\n\t\t\t\tif( element.nodeName.match( /section/gi ) ) {\n\t\t\t\t\tvar h = parseInt( element.getAttribute( 'data-index-h' ), 10 ),\n\t\t\t\t\t\tv = parseInt( element.getAttribute( 'data-index-v' ), 10 );\n\n\t\t\t\t\tslide( h, v );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Handles clicks on links that are set to preview in the\n\t * iframe overlay.\n\t *\n\t * @param {object} event\n\t */\n\tfunction onPreviewLinkClicked( event ) {\n\n\t\tif( event.currentTarget && event.currentTarget.hasAttribute( 'href' ) ) {\n\t\t\tvar url = event.currentTarget.getAttribute( 'href' );\n\t\t\tif( url ) {\n\t\t\t\tshowPreview( url );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Handles click on the auto-sliding controls element.\n\t *\n\t * @param {object} [event]\n\t */\n\tfunction onAutoSlidePlayerClick( event ) {\n\n\t\t// Replay\n\t\tif( Reveal.isLastSlide() && config.loop === false ) {\n\t\t\tslide( 0, 0 );\n\t\t\tresumeAutoSlide();\n\t\t}\n\t\t// Resume\n\t\telse if( autoSlidePaused ) {\n\t\t\tresumeAutoSlide();\n\t\t}\n\t\t// Pause\n\t\telse {\n\t\t\tpauseAutoSlide();\n\t\t}\n\n\t}\n\n\n\t// --------------------------------------------------------------------//\n\t// ------------------------ PLAYBACK COMPONENT ------------------------//\n\t// --------------------------------------------------------------------//\n\n\n\t/**\n\t * Constructor for the playback component, which displays\n\t * play/pause/progress controls.\n\t *\n\t * @param {HTMLElement} container The component will append\n\t * itself to this\n\t * @param {function} progressCheck A method which will be\n\t * called frequently to get the current progress on a range\n\t * of 0-1\n\t */\n\tfunction Playback( container, progressCheck ) {\n\n\t\t// Cosmetics\n\t\tthis.diameter = 100;\n\t\tthis.diameter2 = this.diameter/2;\n\t\tthis.thickness = 6;\n\n\t\t// Flags if we are currently playing\n\t\tthis.playing = false;\n\n\t\t// Current progress on a 0-1 range\n\t\tthis.progress = 0;\n\n\t\t// Used to loop the animation smoothly\n\t\tthis.progressOffset = 1;\n\n\t\tthis.container = container;\n\t\tthis.progressCheck = progressCheck;\n\n\t\tthis.canvas = document.createElement( 'canvas' );\n\t\tthis.canvas.className = 'playback';\n\t\tthis.canvas.width = this.diameter;\n\t\tthis.canvas.height = this.diameter;\n\t\tthis.canvas.style.width = this.diameter2 + 'px';\n\t\tthis.canvas.style.height = this.diameter2 + 'px';\n\t\tthis.context = this.canvas.getContext( '2d' );\n\n\t\tthis.container.appendChild( this.canvas );\n\n\t\tthis.render();\n\n\t}\n\n\t/**\n\t * @param value\n\t */\n\tPlayback.prototype.setPlaying = function( value ) {\n\n\t\tvar wasPlaying = this.playing;\n\n\t\tthis.playing = value;\n\n\t\t// Start repainting if we weren't already\n\t\tif( !wasPlaying && this.playing ) {\n\t\t\tthis.animate();\n\t\t}\n\t\telse {\n\t\t\tthis.render();\n\t\t}\n\n\t};\n\n\tPlayback.prototype.animate = function() {\n\n\t\tvar progressBefore = this.progress;\n\n\t\tthis.progress = this.progressCheck();\n\n\t\t// When we loop, offset the progress so that it eases\n\t\t// smoothly rather than immediately resetting\n\t\tif( progressBefore > 0.8 && this.progress < 0.2 ) {\n\t\t\tthis.progressOffset = this.progress;\n\t\t}\n\n\t\tthis.render();\n\n\t\tif( this.playing ) {\n\t\t\tfeatures.requestAnimationFrameMethod.call( window, this.animate.bind( this ) );\n\t\t}\n\n\t};\n\n\t/**\n\t * Renders the current progress and playback state.\n\t */\n\tPlayback.prototype.render = function() {\n\n\t\tvar progress = this.playing ? this.progress : 0,\n\t\t\tradius = ( this.diameter2 ) - this.thickness,\n\t\t\tx = this.diameter2,\n\t\t\ty = this.diameter2,\n\t\t\ticonSize = 28;\n\n\t\t// Ease towards 1\n\t\tthis.progressOffset += ( 1 - this.progressOffset ) * 0.1;\n\n\t\tvar endAngle = ( - Math.PI / 2 ) + ( progress * ( Math.PI * 2 ) );\n\t\tvar startAngle = ( - Math.PI / 2 ) + ( this.progressOffset * ( Math.PI * 2 ) );\n\n\t\tthis.context.save();\n\t\tthis.context.clearRect( 0, 0, this.diameter, this.diameter );\n\n\t\t// Solid background color\n\t\tthis.context.beginPath();\n\t\tthis.context.arc( x, y, radius + 4, 0, Math.PI * 2, false );\n\t\tthis.context.fillStyle = 'rgba( 0, 0, 0, 0.4 )';\n\t\tthis.context.fill();\n\n\t\t// Draw progress track\n\t\tthis.context.beginPath();\n\t\tthis.context.arc( x, y, radius, 0, Math.PI * 2, false );\n\t\tthis.context.lineWidth = this.thickness;\n\t\tthis.context.strokeStyle = 'rgba( 255, 255, 255, 0.2 )';\n\t\tthis.context.stroke();\n\n\t\tif( this.playing ) {\n\t\t\t// Draw progress on top of track\n\t\t\tthis.context.beginPath();\n\t\t\tthis.context.arc( x, y, radius, startAngle, endAngle, false );\n\t\t\tthis.context.lineWidth = this.thickness;\n\t\t\tthis.context.strokeStyle = '#fff';\n\t\t\tthis.context.stroke();\n\t\t}\n\n\t\tthis.context.translate( x - ( iconSize / 2 ), y - ( iconSize / 2 ) );\n\n\t\t// Draw play/pause icons\n\t\tif( this.playing ) {\n\t\t\tthis.context.fillStyle = '#fff';\n\t\t\tthis.context.fillRect( 0, 0, iconSize / 2 - 4, iconSize );\n\t\t\tthis.context.fillRect( iconSize / 2 + 4, 0, iconSize / 2 - 4, iconSize );\n\t\t}\n\t\telse {\n\t\t\tthis.context.beginPath();\n\t\t\tthis.context.translate( 4, 0 );\n\t\t\tthis.context.moveTo( 0, 0 );\n\t\t\tthis.context.lineTo( iconSize - 4, iconSize / 2 );\n\t\t\tthis.context.lineTo( 0, iconSize );\n\t\t\tthis.context.fillStyle = '#fff';\n\t\t\tthis.context.fill();\n\t\t}\n\n\t\tthis.context.restore();\n\n\t};\n\n\tPlayback.prototype.on = function( type, listener ) {\n\t\tthis.canvas.addEventListener( type, listener, false );\n\t};\n\n\tPlayback.prototype.off = function( type, listener ) {\n\t\tthis.canvas.removeEventListener( type, listener, false );\n\t};\n\n\tPlayback.prototype.destroy = function() {\n\n\t\tthis.playing = false;\n\n\t\tif( this.canvas.parentNode ) {\n\t\t\tthis.container.removeChild( this.canvas );\n\t\t}\n\n\t};\n\n\n\t// --------------------------------------------------------------------//\n\t// ------------------------------- API --------------------------------//\n\t// --------------------------------------------------------------------//\n\n\n\tReveal = {\n\t\tVERSION: VERSION,\n\n\t\tinitialize: initialize,\n\t\tconfigure: configure,\n\n\t\tsync: sync,\n\t\tsyncSlide: syncSlide,\n\t\tsyncFragments: syncFragments,\n\n\t\t// Navigation methods\n\t\tslide: slide,\n\t\tleft: navigateLeft,\n\t\tright: navigateRight,\n\t\tup: navigateUp,\n\t\tdown: navigateDown,\n\t\tprev: navigatePrev,\n\t\tnext: navigateNext,\n\n\t\t// Fragment methods\n\t\tnavigateFragment: navigateFragment,\n\t\tprevFragment: previousFragment,\n\t\tnextFragment: nextFragment,\n\n\t\t// Deprecated aliases\n\t\tnavigateTo: slide,\n\t\tnavigateLeft: navigateLeft,\n\t\tnavigateRight: navigateRight,\n\t\tnavigateUp: navigateUp,\n\t\tnavigateDown: navigateDown,\n\t\tnavigatePrev: navigatePrev,\n\t\tnavigateNext: navigateNext,\n\n\t\t// Forces an update in slide layout\n\t\tlayout: layout,\n\n\t\t// Randomizes the order of slides\n\t\tshuffle: shuffle,\n\n\t\t// Returns an object with the available routes as booleans (left/right/top/bottom)\n\t\tavailableRoutes: availableRoutes,\n\n\t\t// Returns an object with the available fragments as booleans (prev/next)\n\t\tavailableFragments: availableFragments,\n\n\t\t// Toggles a help overlay with keyboard shortcuts\n\t\ttoggleHelp: toggleHelp,\n\n\t\t// Toggles the overview mode on/off\n\t\ttoggleOverview: toggleOverview,\n\n\t\t// Toggles the \"black screen\" mode on/off\n\t\ttogglePause: togglePause,\n\n\t\t// Toggles the auto slide mode on/off\n\t\ttoggleAutoSlide: toggleAutoSlide,\n\n\t\t// State checks\n\t\tisOverview: isOverview,\n\t\tisPaused: isPaused,\n\t\tisAutoSliding: isAutoSliding,\n\t\tisSpeakerNotes: isSpeakerNotes,\n\n\t\t// Slide preloading\n\t\tloadSlide: loadSlide,\n\t\tunloadSlide: unloadSlide,\n\n\t\t// Adds or removes all internal event listeners (such as keyboard)\n\t\taddEventListeners: addEventListeners,\n\t\tremoveEventListeners: removeEventListeners,\n\n\t\t// Facility for persisting and restoring the presentation state\n\t\tgetState: getState,\n\t\tsetState: setState,\n\n\t\t// Presentation progress\n\t\tgetSlidePastCount: getSlidePastCount,\n\n\t\t// Presentation progress on range of 0-1\n\t\tgetProgress: getProgress,\n\n\t\t// Returns the indices of the current, or specified, slide\n\t\tgetIndices: getIndices,\n\n\t\t// Returns an Array of all slides\n\t\tgetSlides: getSlides,\n\n\t\t// Returns the total number of slides\n\t\tgetTotalSlides: getTotalSlides,\n\n\t\t// Returns the slide element at the specified index\n\t\tgetSlide: getSlide,\n\n\t\t// Returns the slide background element at the specified index\n\t\tgetSlideBackground: getSlideBackground,\n\n\t\t// Returns the speaker notes string for a slide, or null\n\t\tgetSlideNotes: getSlideNotes,\n\n\t\t// Returns the previous slide element, may be null\n\t\tgetPreviousSlide: function() {\n\t\t\treturn previousSlide;\n\t\t},\n\n\t\t// Returns the current slide element\n\t\tgetCurrentSlide: function() {\n\t\t\treturn currentSlide;\n\t\t},\n\n\t\t// Returns the current scale of the presentation content\n\t\tgetScale: function() {\n\t\t\treturn scale;\n\t\t},\n\n\t\t// Returns the current configuration object\n\t\tgetConfig: function() {\n\t\t\treturn config;\n\t\t},\n\n\t\t// Helper method, retrieves query string as a key/value hash\n\t\tgetQueryHash: function() {\n\t\t\tvar query = {};\n\n\t\t\tlocation.search.replace( /[A-Z0-9]+?=([\\w\\.%-]*)/gi, function(a) {\n\t\t\t\tquery[ a.split( '=' ).shift() ] = a.split( '=' ).pop();\n\t\t\t} );\n\n\t\t\t// Basic deserialization\n\t\t\tfor( var i in query ) {\n\t\t\t\tvar value = query[ i ];\n\n\t\t\t\tquery[ i ] = deserialize( unescape( value ) );\n\t\t\t}\n\n\t\t\treturn query;\n\t\t},\n\n\t\t// Returns true if we're currently on the first slide\n\t\tisFirstSlide: function() {\n\t\t\treturn ( indexh === 0 && indexv === 0 );\n\t\t},\n\n\t\t// Returns true if we're currently on the last slide\n\t\tisLastSlide: function() {\n\t\t\tif( currentSlide ) {\n\t\t\t\t// Does this slide have a next sibling?\n\t\t\t\tif( currentSlide.nextElementSibling ) return false;\n\n\t\t\t\t// If it's vertical, does its parent have a next sibling?\n\t\t\t\tif( isVerticalSlide( currentSlide ) && currentSlide.parentNode.nextElementSibling ) return false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// Returns true if we're on the last slide in the current\n\t\t// vertical stack\n\t\tisLastVerticalSlide: function() {\n\t\t\tif( currentSlide && isVerticalSlide( currentSlide ) ) {\n\t\t\t\t// Does this slide have a next sibling?\n\t\t\t\tif( currentSlide.nextElementSibling ) return false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// Checks if reveal.js has been loaded and is ready for use\n\t\tisReady: function() {\n\t\t\treturn loaded;\n\t\t},\n\n\t\t// Forward event binding to the reveal DOM element\n\t\taddEventListener: function( type, listener, useCapture ) {\n\t\t\tif( 'addEventListener' in window ) {\n\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).addEventListener( type, listener, useCapture );\n\t\t\t}\n\t\t},\n\t\tremoveEventListener: function( type, listener, useCapture ) {\n\t\t\tif( 'addEventListener' in window ) {\n\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).removeEventListener( type, listener, useCapture );\n\t\t\t}\n\t\t},\n\n\t\t// Adds a custom key binding\n\t\taddKeyBinding: addKeyBinding,\n\n\t\t// Removes a custom key binding\n\t\tremoveKeyBinding: removeKeyBinding,\n\n\t\t// Programatically triggers a keyboard event\n\t\ttriggerKey: function( keyCode ) {\n\t\t\tonDocumentKeyDown( { keyCode: keyCode } );\n\t\t},\n\n\t\t// Registers a new shortcut to include in the help overlay\n\t\tregisterKeyboardShortcut: function( key, value ) {\n\t\t\tkeyboardShortcuts[key] = value;\n\t\t}\n\t};\n\n\treturn Reveal;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmV2ZWFsLmpzL2pzL3JldmVhbC5qcz81ZWYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQTBDO0FBQy9DO0FBQ0EsRUFBRSxtQ0FBUTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQUEsb0dBQUU7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7O0FBRWhEO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwwQ0FBMEMsY0FBYzs7QUFFbkY7QUFDQSx3RkFBd0YsOEJBQThCLGdDQUFnQzs7QUFFdEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELDBDQUEwQztBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLHFCQUFxQixlQUFlOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFdBQVc7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHFEQUFxRDtBQUNyRCw4REFBOEQsK0JBQStCLGtDQUFrQyxFQUFFO0FBQ2pJLGdFQUFnRSwrQkFBK0Isa0NBQWtDLEVBQUU7QUFDbkksMERBQTBELCtCQUErQixrQ0FBa0MsRUFBRTtBQUM3SCw4REFBOEQsK0JBQStCLGtDQUFrQyxFQUFFOztBQUVqSTtBQUNBLDJFQUEyRSwrQkFBK0Isa0NBQWtDLEVBQUU7QUFDOUksOEVBQThFLCtCQUErQixrQ0FBa0MsRUFBRTs7QUFFako7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSw2Q0FBNkMsa0NBQWtDLEVBQUU7QUFDbkosa0VBQWtFLDZDQUE2QyxrQ0FBa0MsRUFBRTs7QUFFbko7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDZDQUE2QyxrQ0FBa0MsRUFBRTtBQUNsSixtRUFBbUUsNkNBQTZDLGtDQUFrQyxFQUFFO0FBQ3BKO0FBQ0E7QUFDQSxtRUFBbUUsNkNBQTZDLGtDQUFrQyxFQUFFO0FBQ3BKLG9FQUFvRSw2Q0FBNkMsa0NBQWtDLEVBQUU7QUFDcko7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFVBQVUsZUFBZTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQSx1Q0FBdUMsMkRBQTJEO0FBQ2xHOztBQUVBO0FBQ0Esc0NBQXNDLHlEQUF5RDtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0IsZUFBZSxnQkFBZ0I7QUFDakcsMkNBQTJDLHdCQUF3QixlQUFlLGlCQUFpQjtBQUNuRyx3Q0FBd0Msd0JBQXdCLGVBQWUsY0FBYztBQUM3RiwwQ0FBMEMsd0JBQXdCLGVBQWUsZ0JBQWdCO0FBQ2pHLDBDQUEwQyx3QkFBd0IsZUFBZSxnQkFBZ0I7QUFDakcsMENBQTBDLHdCQUF3QixlQUFlLGdCQUFnQjs7QUFFakc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcmV2ZWFsLmpzXG4gKiBodHRwOi8vcmV2ZWFsanMuY29tXG4gKiBNSVQgbGljZW5zZWRcbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggSGFraW0gRWwgSGF0dGFiLCBodHRwOi8vaGFraW0uc2VcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXHRpZiggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cm9vdC5SZXZlYWwgPSBmYWN0b3J5KCk7XG5cdFx0XHRyZXR1cm4gcm9vdC5SZXZlYWw7XG5cdFx0fSApO1xuXHR9IGVsc2UgaWYoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFscy5cblx0XHRyb290LlJldmVhbCA9IGZhY3RvcnkoKTtcblx0fVxufSggdGhpcywgZnVuY3Rpb24oKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBSZXZlYWw7XG5cblx0Ly8gVGhlIHJldmVhbC5qcyB2ZXJzaW9uXG5cdHZhciBWRVJTSU9OID0gJzMuNy4wJztcblxuXHR2YXIgU0xJREVTX1NFTEVDVE9SID0gJy5zbGlkZXMgc2VjdGlvbicsXG5cdFx0SE9SSVpPTlRBTF9TTElERVNfU0VMRUNUT1IgPSAnLnNsaWRlcz5zZWN0aW9uJyxcblx0XHRWRVJUSUNBTF9TTElERVNfU0VMRUNUT1IgPSAnLnNsaWRlcz5zZWN0aW9uLnByZXNlbnQ+c2VjdGlvbicsXG5cdFx0SE9NRV9TTElERV9TRUxFQ1RPUiA9ICcuc2xpZGVzPnNlY3Rpb246Zmlyc3Qtb2YtdHlwZScsXG5cdFx0VUEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXG5cdFx0Ly8gQ29uZmlndXJhdGlvbiBkZWZhdWx0cywgY2FuIGJlIG92ZXJyaWRkZW4gYXQgaW5pdGlhbGl6YXRpb24gdGltZVxuXHRcdGNvbmZpZyA9IHtcblxuXHRcdFx0Ly8gVGhlIFwibm9ybWFsXCIgc2l6ZSBvZiB0aGUgcHJlc2VudGF0aW9uLCBhc3BlY3QgcmF0aW8gd2lsbCBiZSBwcmVzZXJ2ZWRcblx0XHRcdC8vIHdoZW4gdGhlIHByZXNlbnRhdGlvbiBpcyBzY2FsZWQgdG8gZml0IGRpZmZlcmVudCByZXNvbHV0aW9uc1xuXHRcdFx0d2lkdGg6IDk2MCxcblx0XHRcdGhlaWdodDogNzAwLFxuXG5cdFx0XHQvLyBGYWN0b3Igb2YgdGhlIGRpc3BsYXkgc2l6ZSB0aGF0IHNob3VsZCByZW1haW4gZW1wdHkgYXJvdW5kIHRoZSBjb250ZW50XG5cdFx0XHRtYXJnaW46IDAuMDQsXG5cblx0XHRcdC8vIEJvdW5kcyBmb3Igc21hbGxlc3QvbGFyZ2VzdCBwb3NzaWJsZSBzY2FsZSB0byBhcHBseSB0byBjb250ZW50XG5cdFx0XHRtaW5TY2FsZTogMC4yLFxuXHRcdFx0bWF4U2NhbGU6IDIuMCxcblxuXHRcdFx0Ly8gRGlzcGxheSBwcmVzZW50YXRpb24gY29udHJvbCBhcnJvd3Ncblx0XHRcdGNvbnRyb2xzOiB0cnVlLFxuXG5cdFx0XHQvLyBIZWxwIHRoZSB1c2VyIGxlYXJuIHRoZSBjb250cm9scyBieSBwcm92aWRpbmcgaGludHMsIGZvciBleGFtcGxlIGJ5XG5cdFx0XHQvLyBib3VuY2luZyB0aGUgZG93biBhcnJvdyB3aGVuIHRoZXkgZmlyc3QgZW5jb3VudGVyIGEgdmVydGljYWwgc2xpZGVcblx0XHRcdGNvbnRyb2xzVHV0b3JpYWw6IHRydWUsXG5cblx0XHRcdC8vIERldGVybWluZXMgd2hlcmUgY29udHJvbHMgYXBwZWFyLCBcImVkZ2VzXCIgb3IgXCJib3R0b20tcmlnaHRcIlxuXHRcdFx0Y29udHJvbHNMYXlvdXQ6ICdib3R0b20tcmlnaHQnLFxuXG5cdFx0XHQvLyBWaXNpYmlsaXR5IHJ1bGUgZm9yIGJhY2t3YXJkcyBuYXZpZ2F0aW9uIGFycm93czsgXCJmYWRlZFwiLCBcImhpZGRlblwiXG5cdFx0XHQvLyBvciBcInZpc2libGVcIlxuXHRcdFx0Y29udHJvbHNCYWNrQXJyb3dzOiAnZmFkZWQnLFxuXG5cdFx0XHQvLyBEaXNwbGF5IGEgcHJlc2VudGF0aW9uIHByb2dyZXNzIGJhclxuXHRcdFx0cHJvZ3Jlc3M6IHRydWUsXG5cblx0XHRcdC8vIERpc3BsYXkgdGhlIHBhZ2UgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHNsaWRlXG5cdFx0XHRzbGlkZU51bWJlcjogZmFsc2UsXG5cblx0XHRcdC8vIFVzZSAxIGJhc2VkIGluZGV4aW5nIGZvciAjIGxpbmtzIHRvIG1hdGNoIHNsaWRlIG51bWJlciAoZGVmYXVsdCBpcyB6ZXJvXG5cdFx0XHQvLyBiYXNlZClcblx0XHRcdGhhc2hPbmVCYXNlZEluZGV4OiBmYWxzZSxcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXlzIHRvIHNob3cgdGhlIHNsaWRlIG51bWJlciBvblxuXHRcdFx0c2hvd1NsaWRlTnVtYmVyOiAnYWxsJyxcblxuXHRcdFx0Ly8gUHVzaCBlYWNoIHNsaWRlIGNoYW5nZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5XG5cdFx0XHRoaXN0b3J5OiBmYWxzZSxcblxuXHRcdFx0Ly8gRW5hYmxlIGtleWJvYXJkIHNob3J0Y3V0cyBmb3IgbmF2aWdhdGlvblxuXHRcdFx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0XHRcdC8vIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgYmxvY2tzIGtleWJvYXJkIGV2ZW50cyB3aGVuIHJldHVuaW5nIGZhbHNlXG5cdFx0XHRrZXlib2FyZENvbmRpdGlvbjogbnVsbCxcblxuXHRcdFx0Ly8gRW5hYmxlIHRoZSBzbGlkZSBvdmVydmlldyBtb2RlXG5cdFx0XHRvdmVydmlldzogdHJ1ZSxcblxuXHRcdFx0Ly8gRGlzYWJsZXMgdGhlIGRlZmF1bHQgcmV2ZWFsLmpzIHNsaWRlIGxheW91dCBzbyB0aGF0IHlvdSBjYW4gdXNlXG5cdFx0XHQvLyBjdXN0b20gQ1NTIGxheW91dFxuXHRcdFx0ZGlzYWJsZUxheW91dDogZmFsc2UsXG5cblx0XHRcdC8vIFZlcnRpY2FsIGNlbnRlcmluZyBvZiBzbGlkZXNcblx0XHRcdGNlbnRlcjogdHJ1ZSxcblxuXHRcdFx0Ly8gRW5hYmxlcyB0b3VjaCBuYXZpZ2F0aW9uIG9uIGRldmljZXMgd2l0aCB0b3VjaCBpbnB1dFxuXHRcdFx0dG91Y2g6IHRydWUsXG5cblx0XHRcdC8vIExvb3AgdGhlIHByZXNlbnRhdGlvblxuXHRcdFx0bG9vcDogZmFsc2UsXG5cblx0XHRcdC8vIENoYW5nZSB0aGUgcHJlc2VudGF0aW9uIGRpcmVjdGlvbiB0byBiZSBSVExcblx0XHRcdHJ0bDogZmFsc2UsXG5cblx0XHRcdC8vIFJhbmRvbWl6ZXMgdGhlIG9yZGVyIG9mIHNsaWRlcyBlYWNoIHRpbWUgdGhlIHByZXNlbnRhdGlvbiBsb2Fkc1xuXHRcdFx0c2h1ZmZsZTogZmFsc2UsXG5cblx0XHRcdC8vIFR1cm5zIGZyYWdtZW50cyBvbiBhbmQgb2ZmIGdsb2JhbGx5XG5cdFx0XHRmcmFnbWVudHM6IHRydWUsXG5cblx0XHRcdC8vIEZsYWdzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgY3VycmVudCBmcmFnbWVudCBpbiB0aGUgVVJMLFxuXHRcdFx0Ly8gc28gdGhhdCByZWxvYWRpbmcgYnJpbmdzIHlvdSB0byB0aGUgc2FtZSBmcmFnbWVudCBwb3NpdGlvblxuXHRcdFx0ZnJhZ21lbnRJblVSTDogZmFsc2UsXG5cblx0XHRcdC8vIEZsYWdzIGlmIHRoZSBwcmVzZW50YXRpb24gaXMgcnVubmluZyBpbiBhbiBlbWJlZGRlZCBtb2RlLFxuXHRcdFx0Ly8gaS5lLiBjb250YWluZWQgd2l0aGluIGEgbGltaXRlZCBwb3J0aW9uIG9mIHRoZSBzY3JlZW5cblx0XHRcdGVtYmVkZGVkOiBmYWxzZSxcblxuXHRcdFx0Ly8gRmxhZ3MgaWYgd2Ugc2hvdWxkIHNob3cgYSBoZWxwIG92ZXJsYXkgd2hlbiB0aGUgcXVlc3Rpb24tbWFya1xuXHRcdFx0Ly8ga2V5IGlzIHByZXNzZWRcblx0XHRcdGhlbHA6IHRydWUsXG5cblx0XHRcdC8vIEZsYWdzIGlmIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBwYXVzZSB0aGUgcHJlc2VudGF0aW9uIChibGFja291dClcblx0XHRcdHBhdXNlOiB0cnVlLFxuXG5cdFx0XHQvLyBGbGFncyBpZiBzcGVha2VyIG5vdGVzIHNob3VsZCBiZSB2aXNpYmxlIHRvIGFsbCB2aWV3ZXJzXG5cdFx0XHRzaG93Tm90ZXM6IGZhbHNlLFxuXG5cdFx0XHQvLyBHbG9iYWwgb3ZlcnJpZGUgZm9yIGF1dG9sYXlpbmcgZW1iZWRkZWQgbWVkaWEgKHZpZGVvL2F1ZGlvL2lmcmFtZSlcblx0XHRcdC8vIC0gbnVsbDogICBNZWRpYSB3aWxsIG9ubHkgYXV0b3BsYXkgaWYgZGF0YS1hdXRvcGxheSBpcyBwcmVzZW50XG5cdFx0XHQvLyAtIHRydWU6ICAgQWxsIG1lZGlhIHdpbGwgYXV0b3BsYXksIHJlZ2FyZGxlc3Mgb2YgaW5kaXZpZHVhbCBzZXR0aW5nXG5cdFx0XHQvLyAtIGZhbHNlOiAgTm8gbWVkaWEgd2lsbCBhdXRvcGxheSwgcmVnYXJkbGVzcyBvZiBpbmRpdmlkdWFsIHNldHRpbmdcblx0XHRcdGF1dG9QbGF5TWVkaWE6IG51bGwsXG5cblx0XHRcdC8vIENvbnRyb2xzIGF1dG9tYXRpYyBwcm9ncmVzc2lvbiB0byB0aGUgbmV4dCBzbGlkZVxuXHRcdFx0Ly8gLSAwOiAgICAgIEF1dG8tc2xpZGluZyBvbmx5IGhhcHBlbnMgaWYgdGhlIGRhdGEtYXV0b3NsaWRlIEhUTUwgYXR0cmlidXRlXG5cdFx0XHQvLyAgICAgICAgICAgaXMgcHJlc2VudCBvbiB0aGUgY3VycmVudCBzbGlkZSBvciBmcmFnbWVudFxuXHRcdFx0Ly8gLSAxKzogICAgIEFsbCBzbGlkZXMgd2lsbCBwcm9ncmVzcyBhdXRvbWF0aWNhbGx5IGF0IHRoZSBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0Ly8gLSBmYWxzZTogIE5vIGF1dG8tc2xpZGluZywgZXZlbiBpZiBkYXRhLWF1dG9zbGlkZSBpcyBwcmVzZW50XG5cdFx0XHRhdXRvU2xpZGU6IDAsXG5cblx0XHRcdC8vIFN0b3AgYXV0by1zbGlkaW5nIGFmdGVyIHVzZXIgaW5wdXRcblx0XHRcdGF1dG9TbGlkZVN0b3BwYWJsZTogdHJ1ZSxcblxuXHRcdFx0Ly8gVXNlIHRoaXMgbWV0aG9kIGZvciBuYXZpZ2F0aW9uIHdoZW4gYXV0by1zbGlkaW5nIChkZWZhdWx0cyB0byBuYXZpZ2F0ZU5leHQpXG5cdFx0XHRhdXRvU2xpZGVNZXRob2Q6IG51bGwsXG5cblx0XHRcdC8vIFNwZWNpZnkgdGhlIGF2ZXJhZ2UgdGltZSBpbiBzZWNvbmRzIHRoYXQgeW91IHRoaW5rIHlvdSB3aWxsIHNwZW5kXG5cdFx0XHQvLyBwcmVzZW50aW5nIGVhY2ggc2xpZGUuIFRoaXMgaXMgdXNlZCB0byBzaG93IGEgcGFjaW5nIHRpbWVyIGluIHRoZVxuXHRcdFx0Ly8gc3BlYWtlciB2aWV3XG5cdFx0XHRkZWZhdWx0VGltaW5nOiBudWxsLFxuXG5cdFx0XHQvLyBFbmFibGUgc2xpZGUgbmF2aWdhdGlvbiB2aWEgbW91c2Ugd2hlZWxcblx0XHRcdG1vdXNlV2hlZWw6IGZhbHNlLFxuXG5cdFx0XHQvLyBBcHBseSBhIDNEIHJvbGwgdG8gbGlua3Mgb24gaG92ZXJcblx0XHRcdHJvbGxpbmdMaW5rczogZmFsc2UsXG5cblx0XHRcdC8vIEhpZGVzIHRoZSBhZGRyZXNzIGJhciBvbiBtb2JpbGUgZGV2aWNlc1xuXHRcdFx0aGlkZUFkZHJlc3NCYXI6IHRydWUsXG5cblx0XHRcdC8vIE9wZW5zIGxpbmtzIGluIGFuIGlmcmFtZSBwcmV2aWV3IG92ZXJsYXlcblx0XHRcdC8vIEFkZCBgZGF0YS1wcmV2aWV3LWxpbmtgIGFuZCBgZGF0YS1wcmV2aWV3LWxpbms9XCJmYWxzZVwiYCB0byBjdXN0b21pc2UgZWFjaCBsaW5rXG5cdFx0XHQvLyBpbmRpdmlkdWFsbHlcblx0XHRcdHByZXZpZXdMaW5rczogZmFsc2UsXG5cblx0XHRcdC8vIEV4cG9zZXMgdGhlIHJldmVhbC5qcyBBUEkgdGhyb3VnaCB3aW5kb3cucG9zdE1lc3NhZ2Vcblx0XHRcdHBvc3RNZXNzYWdlOiB0cnVlLFxuXG5cdFx0XHQvLyBEaXNwYXRjaGVzIGFsbCByZXZlYWwuanMgZXZlbnRzIHRvIHRoZSBwYXJlbnQgd2luZG93IHRocm91Z2ggcG9zdE1lc3NhZ2Vcblx0XHRcdHBvc3RNZXNzYWdlRXZlbnRzOiBmYWxzZSxcblxuXHRcdFx0Ly8gRm9jdXNlcyBib2R5IHdoZW4gcGFnZSBjaGFuZ2VzIHZpc2liaWxpdHkgdG8gZW5zdXJlIGtleWJvYXJkIHNob3J0Y3V0cyB3b3JrXG5cdFx0XHRmb2N1c0JvZHlPblBhZ2VWaXNpYmlsaXR5Q2hhbmdlOiB0cnVlLFxuXG5cdFx0XHQvLyBUcmFuc2l0aW9uIHN0eWxlXG5cdFx0XHR0cmFuc2l0aW9uOiAnc2xpZGUnLCAvLyBub25lL2ZhZGUvc2xpZGUvY29udmV4L2NvbmNhdmUvem9vbVxuXG5cdFx0XHQvLyBUcmFuc2l0aW9uIHNwZWVkXG5cdFx0XHR0cmFuc2l0aW9uU3BlZWQ6ICdkZWZhdWx0JywgLy8gZGVmYXVsdC9mYXN0L3Nsb3dcblxuXHRcdFx0Ly8gVHJhbnNpdGlvbiBzdHlsZSBmb3IgZnVsbCBwYWdlIHNsaWRlIGJhY2tncm91bmRzXG5cdFx0XHRiYWNrZ3JvdW5kVHJhbnNpdGlvbjogJ2ZhZGUnLCAvLyBub25lL2ZhZGUvc2xpZGUvY29udmV4L2NvbmNhdmUvem9vbVxuXG5cdFx0XHQvLyBQYXJhbGxheCBiYWNrZ3JvdW5kIGltYWdlXG5cdFx0XHRwYXJhbGxheEJhY2tncm91bmRJbWFnZTogJycsIC8vIENTUyBzeW50YXgsIGUuZy4gXCJhLmpwZ1wiXG5cblx0XHRcdC8vIFBhcmFsbGF4IGJhY2tncm91bmQgc2l6ZVxuXHRcdFx0cGFyYWxsYXhCYWNrZ3JvdW5kU2l6ZTogJycsIC8vIENTUyBzeW50YXgsIGUuZy4gXCIzMDAwcHggMjAwMHB4XCJcblxuXHRcdFx0Ly8gUGFyYWxsYXggYmFja2dyb3VuZCByZXBlYXRcblx0XHRcdHBhcmFsbGF4QmFja2dyb3VuZFJlcGVhdDogJycsIC8vIHJlcGVhdC9yZXBlYXQteC9yZXBlYXQteS9uby1yZXBlYXQvaW5pdGlhbC9pbmhlcml0XG5cblx0XHRcdC8vIFBhcmFsbGF4IGJhY2tncm91bmQgcG9zaXRpb25cblx0XHRcdHBhcmFsbGF4QmFja2dyb3VuZFBvc2l0aW9uOiAnJywgLy8gQ1NTIHN5bnRheCwgZS5nLiBcInRvcCBsZWZ0XCJcblxuXHRcdFx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBtb3ZlIHRoZSBwYXJhbGxheCBiYWNrZ3JvdW5kIHBlciBzbGlkZSBzdGVwXG5cdFx0XHRwYXJhbGxheEJhY2tncm91bmRIb3Jpem9udGFsOiBudWxsLFxuXHRcdFx0cGFyYWxsYXhCYWNrZ3JvdW5kVmVydGljYWw6IG51bGwsXG5cblx0XHRcdC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwYWdlcyBhIHNpbmdsZSBzbGlkZSBjYW4gZXhwYW5kIG9udG8gd2hlbiBwcmludGluZ1xuXHRcdFx0Ly8gdG8gUERGLCB1bmxpbWl0ZWQgYnkgZGVmYXVsdFxuXHRcdFx0cGRmTWF4UGFnZXNQZXJTbGlkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXG5cdFx0XHQvLyBQcmludHMgZWFjaCBmcmFnbWVudCBvbiBhIHNlcGFyYXRlIHNsaWRlXG5cdFx0XHRwZGZTZXBhcmF0ZUZyYWdtZW50czogdHJ1ZSxcblxuXHRcdFx0Ly8gT2Zmc2V0IHVzZWQgdG8gcmVkdWNlIHRoZSBoZWlnaHQgb2YgY29udGVudCB3aXRoaW4gZXhwb3J0ZWQgUERGIHBhZ2VzLlxuXHRcdFx0Ly8gVGhpcyBleGlzdHMgdG8gYWNjb3VudCBmb3IgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMgYmFzZWQgb24gaG93IHlvdVxuXHRcdFx0Ly8gcHJpbnQgdG8gUERGLiBDTEkgcHJpbnRpbmcgb3B0aW9ucywgbGlrZSBwaGFudG9tanMgYW5kIHdrcGRmLCBjYW4gZW5kXG5cdFx0XHQvLyBvbiBwcmVjaXNlbHkgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQgd2hlcmVhcyBpbi1icm93c2VyXG5cdFx0XHQvLyBwcmludGluZyBoYXMgdG8gZW5kIG9uZSBwaXhlbCBiZWZvcmUuXG5cdFx0XHRwZGZQYWdlSGVpZ2h0T2Zmc2V0OiAtMSxcblxuXHRcdFx0Ly8gTnVtYmVyIG9mIHNsaWRlcyBhd2F5IGZyb20gdGhlIGN1cnJlbnQgdGhhdCBhcmUgdmlzaWJsZVxuXHRcdFx0dmlld0Rpc3RhbmNlOiAzLFxuXG5cdFx0XHQvLyBUaGUgZGlzcGxheSBtb2RlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNob3cgc2xpZGVzXG5cdFx0XHRkaXNwbGF5OiAnYmxvY2snLFxuXG5cdFx0XHQvLyBTY3JpcHQgZGVwZW5kZW5jaWVzIHRvIGxvYWRcblx0XHRcdGRlcGVuZGVuY2llczogW11cblxuXHRcdH0sXG5cblx0XHQvLyBGbGFncyBpZiBSZXZlYWwuaW5pdGlhbGl6ZSgpIGhhcyBiZWVuIGNhbGxlZFxuXHRcdGluaXRpYWxpemVkID0gZmFsc2UsXG5cblx0XHQvLyBGbGFncyBpZiByZXZlYWwuanMgaXMgbG9hZGVkIChoYXMgZGlzcGF0Y2hlZCB0aGUgJ3JlYWR5JyBldmVudClcblx0XHRsb2FkZWQgPSBmYWxzZSxcblxuXHRcdC8vIEZsYWdzIGlmIHRoZSBvdmVydmlldyBtb2RlIGlzIGN1cnJlbnRseSBhY3RpdmVcblx0XHRvdmVydmlldyA9IGZhbHNlLFxuXG5cdFx0Ly8gSG9sZHMgdGhlIGRpbWVuc2lvbnMgb2Ygb3VyIG92ZXJ2aWV3IHNsaWRlcywgaW5jbHVkaW5nIG1hcmdpbnNcblx0XHRvdmVydmlld1NsaWRlV2lkdGggPSBudWxsLFxuXHRcdG92ZXJ2aWV3U2xpZGVIZWlnaHQgPSBudWxsLFxuXG5cdFx0Ly8gVGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNsaWRlXG5cdFx0aW5kZXhoLFxuXHRcdGluZGV4dixcblxuXHRcdC8vIFRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBzbGlkZSBIVE1MIGVsZW1lbnRzXG5cdFx0cHJldmlvdXNTbGlkZSxcblx0XHRjdXJyZW50U2xpZGUsXG5cblx0XHRwcmV2aW91c0JhY2tncm91bmQsXG5cblx0XHQvLyBSZW1lbWJlciB3aGljaCBkaXJlY3Rpb25zIHRoYXQgdGhlIHVzZXIgaGFzIG5hdmlnYXRlZCB0b3dhcmRzXG5cdFx0aGFzTmF2aWdhdGVkUmlnaHQgPSBmYWxzZSxcblx0XHRoYXNOYXZpZ2F0ZWREb3duID0gZmFsc2UsXG5cblx0XHQvLyBTbGlkZXMgbWF5IGhvbGQgYSBkYXRhLXN0YXRlIGF0dHJpYnV0ZSB3aGljaCB3ZSBwaWNrIHVwIGFuZCBhcHBseVxuXHRcdC8vIGFzIGEgY2xhc3MgdG8gdGhlIGJvZHkuIFRoaXMgbGlzdCBjb250YWlucyB0aGUgY29tYmluZWQgc3RhdGUgb2Zcblx0XHQvLyBhbGwgY3VycmVudCBzbGlkZXMuXG5cdFx0c3RhdGUgPSBbXSxcblxuXHRcdC8vIFRoZSBjdXJyZW50IHNjYWxlIG9mIHRoZSBwcmVzZW50YXRpb24gKHNlZSB3aWR0aC9oZWlnaHQgY29uZmlnKVxuXHRcdHNjYWxlID0gMSxcblxuXHRcdC8vIENTUyB0cmFuc2Zvcm0gdGhhdCBpcyBjdXJyZW50bHkgYXBwbGllZCB0byB0aGUgc2xpZGVzIGNvbnRhaW5lcixcblx0XHQvLyBzcGxpdCBpbnRvIHR3byBncm91cHNcblx0XHRzbGlkZXNUcmFuc2Zvcm0gPSB7IGxheW91dDogJycsIG92ZXJ2aWV3OiAnJyB9LFxuXG5cdFx0Ly8gQ2FjaGVkIHJlZmVyZW5jZXMgdG8gRE9NIGVsZW1lbnRzXG5cdFx0ZG9tID0ge30sXG5cblx0XHQvLyBGZWF0dXJlcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHNlZSAjY2hlY2tDYXBhYmlsaXRpZXMoKVxuXHRcdGZlYXR1cmVzID0ge30sXG5cblx0XHQvLyBDbGllbnQgaXMgYSBtb2JpbGUgZGV2aWNlLCBzZWUgI2NoZWNrQ2FwYWJpbGl0aWVzKClcblx0XHRpc01vYmlsZURldmljZSxcblxuXHRcdC8vIENsaWVudCBpcyBhIGRlc2t0b3AgQ2hyb21lLCBzZWUgI2NoZWNrQ2FwYWJpbGl0aWVzKClcblx0XHRpc0Nocm9tZSxcblxuXHRcdC8vIFRocm90dGxlcyBtb3VzZSB3aGVlbCBuYXZpZ2F0aW9uXG5cdFx0bGFzdE1vdXNlV2hlZWxTdGVwID0gMCxcblxuXHRcdC8vIERlbGF5cyB1cGRhdGVzIHRvIHRoZSBVUkwgZHVlIHRvIGEgQ2hyb21lIHRodW1ibmFpbGVyIGJ1Z1xuXHRcdHdyaXRlVVJMVGltZW91dCA9IDAsXG5cblx0XHQvLyBGbGFncyBpZiB0aGUgaW50ZXJhY3Rpb24gZXZlbnQgbGlzdGVuZXJzIGFyZSBib3VuZFxuXHRcdGV2ZW50c0FyZUJvdW5kID0gZmFsc2UsXG5cblx0XHQvLyBUaGUgY3VycmVudCBhdXRvLXNsaWRlIGR1cmF0aW9uXG5cdFx0YXV0b1NsaWRlID0gMCxcblxuXHRcdC8vIEF1dG8gc2xpZGUgcHJvcGVydGllc1xuXHRcdGF1dG9TbGlkZVBsYXllcixcblx0XHRhdXRvU2xpZGVUaW1lb3V0ID0gMCxcblx0XHRhdXRvU2xpZGVTdGFydFRpbWUgPSAtMSxcblx0XHRhdXRvU2xpZGVQYXVzZWQgPSBmYWxzZSxcblxuXHRcdC8vIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgb25nb2luZyB0b3VjaCBpbnB1dFxuXHRcdHRvdWNoID0ge1xuXHRcdFx0c3RhcnRYOiAwLFxuXHRcdFx0c3RhcnRZOiAwLFxuXHRcdFx0c3RhcnRTcGFuOiAwLFxuXHRcdFx0c3RhcnRDb3VudDogMCxcblx0XHRcdGNhcHR1cmVkOiBmYWxzZSxcblx0XHRcdHRocmVzaG9sZDogNDBcblx0XHR9LFxuXG5cdFx0Ly8gSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGtleWJvYXJkIHNob3J0Y3V0c1xuXHRcdGtleWJvYXJkU2hvcnRjdXRzID0ge1xuXHRcdFx0J04gICwgIFNQQUNFJzpcdFx0XHQnTmV4dCBzbGlkZScsXG5cdFx0XHQnUCc6XHRcdFx0XHRcdCdQcmV2aW91cyBzbGlkZScsXG5cdFx0XHQnJiM4NTkyOyAgLCAgSCc6XHRcdCdOYXZpZ2F0ZSBsZWZ0Jyxcblx0XHRcdCcmIzg1OTQ7ICAsICBMJzpcdFx0J05hdmlnYXRlIHJpZ2h0Jyxcblx0XHRcdCcmIzg1OTM7ICAsICBLJzpcdFx0J05hdmlnYXRlIHVwJyxcblx0XHRcdCcmIzg1OTU7ICAsICBKJzpcdFx0J05hdmlnYXRlIGRvd24nLFxuXHRcdFx0J0hvbWUnOlx0XHRcdFx0XHQnRmlyc3Qgc2xpZGUnLFxuXHRcdFx0J0VuZCc6XHRcdFx0XHRcdCdMYXN0IHNsaWRlJyxcblx0XHRcdCdCICAsICAuJzpcdFx0XHRcdCdQYXVzZScsXG5cdFx0XHQnRic6XHRcdFx0XHRcdCdGdWxsc2NyZWVuJyxcblx0XHRcdCdFU0MsIE8nOlx0XHRcdFx0J1NsaWRlIG92ZXJ2aWV3J1xuXHRcdH0sXG5cblx0XHQvLyBIb2xkcyBjdXN0b20ga2V5IGNvZGUgbWFwcGluZ3Ncblx0XHRyZWdpc3RlcmVkS2V5QmluZGluZ3MgPSB7fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHVwIHRoZSBwcmVzZW50YXRpb24gaWYgdGhlIGNsaWVudCBpcyBjYXBhYmxlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdGlhbGl6ZSggb3B0aW9ucyApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGluaXRpYWxpemUgb25jZVxuXHRcdGlmKCBpbml0aWFsaXplZCA9PT0gdHJ1ZSApIHJldHVybjtcblxuXHRcdGluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdGNoZWNrQ2FwYWJpbGl0aWVzKCk7XG5cblx0XHRpZiggIWZlYXR1cmVzLnRyYW5zZm9ybXMyZCAmJiAhZmVhdHVyZXMudHJhbnNmb3JtczNkICkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoICdjbGFzcycsICduby10cmFuc2Zvcm1zJyApO1xuXG5cdFx0XHQvLyBTaW5jZSBKUyB3b24ndCBiZSBydW5uaW5nIGFueSBmdXJ0aGVyLCB3ZSBsb2FkIGFsbCBsYXp5XG5cdFx0XHQvLyBsb2FkaW5nIGVsZW1lbnRzIHVwZnJvbnRcblx0XHRcdHZhciBpbWFnZXMgPSB0b0FycmF5KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2ltZycgKSApLFxuXHRcdFx0XHRpZnJhbWVzID0gdG9BcnJheSggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdpZnJhbWUnICkgKTtcblxuXHRcdFx0dmFyIGxhenlMb2FkYWJsZSA9IGltYWdlcy5jb25jYXQoIGlmcmFtZXMgKTtcblxuXHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGxhenlMb2FkYWJsZS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBsYXp5TG9hZGFibGVbaV07XG5cdFx0XHRcdGlmKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJyApICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnc3JjJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdkYXRhLXNyYycgKSApO1xuXHRcdFx0XHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS1zcmMnICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNvcmUgZmVhdHVyZXMgd2Ugd29uJ3QgYmVcblx0XHRcdC8vIHVzaW5nIEphdmFTY3JpcHQgdG8gY29udHJvbCB0aGUgcHJlc2VudGF0aW9uXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgcmVmZXJlbmNlcyB0byBrZXkgRE9NIGVsZW1lbnRzXG5cdFx0ZG9tLndyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLnJldmVhbCcgKTtcblx0XHRkb20uc2xpZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJy5yZXZlYWwgLnNsaWRlcycgKTtcblxuXHRcdC8vIEZvcmNlIGEgbGF5b3V0IHdoZW4gdGhlIHdob2xlIHBhZ2UsIGluY2wgZm9udHMsIGhhcyBsb2FkZWRcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsYXlvdXQsIGZhbHNlICk7XG5cblx0XHR2YXIgcXVlcnkgPSBSZXZlYWwuZ2V0UXVlcnlIYXNoKCk7XG5cblx0XHQvLyBEbyBub3QgYWNjZXB0IG5ldyBkZXBlbmRlbmNpZXMgdmlhIHF1ZXJ5IGNvbmZpZyB0byBhdm9pZFxuXHRcdC8vIHRoZSBwb3RlbnRpYWwgb2YgbWFsaWNpb3VzIHNjcmlwdCBpbmplY3Rpb25cblx0XHRpZiggdHlwZW9mIHF1ZXJ5WydkZXBlbmRlbmNpZXMnXSAhPT0gJ3VuZGVmaW5lZCcgKSBkZWxldGUgcXVlcnlbJ2RlcGVuZGVuY2llcyddO1xuXG5cdFx0Ly8gQ29weSBvcHRpb25zIG92ZXIgdG8gb3VyIGNvbmZpZyBvYmplY3Rcblx0XHRleHRlbmQoIGNvbmZpZywgb3B0aW9ucyApO1xuXHRcdGV4dGVuZCggY29uZmlnLCBxdWVyeSApO1xuXG5cdFx0Ly8gSGlkZSB0aGUgYWRkcmVzcyBiYXIgaW4gbW9iaWxlIGJyb3dzZXJzXG5cdFx0aGlkZUFkZHJlc3NCYXIoKTtcblxuXHRcdC8vIExvYWRzIHRoZSBkZXBlbmRlbmNpZXMgYW5kIGNvbnRpbnVlcyB0byAjc3RhcnQoKSBvbmNlIGRvbmVcblx0XHRsb2FkKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnNwZWN0IHRoZSBjbGllbnQgdG8gc2VlIHdoYXQgaXQncyBjYXBhYmxlIG9mLCB0aGlzXG5cdCAqIHNob3VsZCBvbmx5IGhhcHBlbnMgb25jZSBwZXIgcnVudGltZS5cblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrQ2FwYWJpbGl0aWVzKCkge1xuXG5cdFx0aXNNb2JpbGVEZXZpY2UgPSAvKGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZCkvZ2kudGVzdCggVUEgKTtcblx0XHRpc0Nocm9tZSA9IC9jaHJvbWUvaS50ZXN0KCBVQSApICYmICEvZWRnZS9pLnRlc3QoIFVBICk7XG5cblx0XHR2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG5cdFx0ZmVhdHVyZXMudHJhbnNmb3JtczNkID0gJ1dlYmtpdFBlcnNwZWN0aXZlJyBpbiB0ZXN0RWxlbWVudC5zdHlsZSB8fFxuXHRcdFx0XHRcdFx0XHRcdCdNb3pQZXJzcGVjdGl2ZScgaW4gdGVzdEVsZW1lbnQuc3R5bGUgfHxcblx0XHRcdFx0XHRcdFx0XHQnbXNQZXJzcGVjdGl2ZScgaW4gdGVzdEVsZW1lbnQuc3R5bGUgfHxcblx0XHRcdFx0XHRcdFx0XHQnT1BlcnNwZWN0aXZlJyBpbiB0ZXN0RWxlbWVudC5zdHlsZSB8fFxuXHRcdFx0XHRcdFx0XHRcdCdwZXJzcGVjdGl2ZScgaW4gdGVzdEVsZW1lbnQuc3R5bGU7XG5cblx0XHRmZWF0dXJlcy50cmFuc2Zvcm1zMmQgPSAnV2Via2l0VHJhbnNmb3JtJyBpbiB0ZXN0RWxlbWVudC5zdHlsZSB8fFxuXHRcdFx0XHRcdFx0XHRcdCdNb3pUcmFuc2Zvcm0nIGluIHRlc3RFbGVtZW50LnN0eWxlIHx8XG5cdFx0XHRcdFx0XHRcdFx0J21zVHJhbnNmb3JtJyBpbiB0ZXN0RWxlbWVudC5zdHlsZSB8fFxuXHRcdFx0XHRcdFx0XHRcdCdPVHJhbnNmb3JtJyBpbiB0ZXN0RWxlbWVudC5zdHlsZSB8fFxuXHRcdFx0XHRcdFx0XHRcdCd0cmFuc2Zvcm0nIGluIHRlc3RFbGVtZW50LnN0eWxlO1xuXG5cdFx0ZmVhdHVyZXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lTWV0aG9kID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0ZmVhdHVyZXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdHlwZW9mIGZlYXR1cmVzLnJlcXVlc3RBbmltYXRpb25GcmFtZU1ldGhvZCA9PT0gJ2Z1bmN0aW9uJztcblxuXHRcdGZlYXR1cmVzLmNhbnZhcyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKS5nZXRDb250ZXh0O1xuXG5cdFx0Ly8gVHJhbnNpdGlvbnMgaW4gdGhlIG92ZXJ2aWV3IGFyZSBkaXNhYmxlZCBpbiBkZXNrdG9wIGFuZFxuXHRcdC8vIFNhZmFyaSBkdWUgdG8gbGFnXG5cdFx0ZmVhdHVyZXMub3ZlcnZpZXdUcmFuc2l0aW9ucyA9ICEvVmVyc2lvblxcL1tcXGRcXC5dKy4qU2FmYXJpLy50ZXN0KCBVQSApO1xuXG5cdFx0Ly8gRmxhZ3MgaWYgd2Ugc2hvdWxkIHVzZSB6b29tIGluc3RlYWQgb2YgdHJhbnNmb3JtIHRvIHNjYWxlXG5cdFx0Ly8gdXAgc2xpZGVzLiBab29tIHByb2R1Y2VzIGNyaXNwZXIgcmVzdWx0cyBidXQgaGFzIGEgbG90IG9mXG5cdFx0Ly8geGJyb3dzZXIgcXVpcmtzIHNvIHdlIG9ubHkgdXNlIGl0IGluIHdoaXRlbHNpdGVkIGJyb3dzZXJzLlxuXHRcdGZlYXR1cmVzLnpvb20gPSAnem9vbScgaW4gdGVzdEVsZW1lbnQuc3R5bGUgJiYgIWlzTW9iaWxlRGV2aWNlICYmXG5cdFx0XHRcdFx0XHQoIGlzQ2hyb21lIHx8IC9WZXJzaW9uXFwvW1xcZFxcLl0rLipTYWZhcmkvLnRlc3QoIFVBICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBkZXBlbmRlbmNpZXMgb2YgcmV2ZWFsLmpzLiBEZXBlbmRlbmNpZXMgYXJlXG5cdCAqIGRlZmluZWQgdmlhIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiAnZGVwZW5kZW5jaWVzJ1xuXHQgKiBhbmQgd2lsbCBiZSBsb2FkZWQgcHJpb3IgdG8gc3RhcnRpbmcvYmluZGluZyByZXZlYWwuanMuXG5cdCAqIFNvbWUgZGVwZW5kZW5jaWVzIG1heSBoYXZlIGFuICdhc3luYycgZmxhZywgaWYgc28gdGhleVxuXHQgKiB3aWxsIGxvYWQgYWZ0ZXIgcmV2ZWFsLmpzIGhhcyBiZWVuIHN0YXJ0ZWQgdXAuXG5cdCAqL1xuXHRmdW5jdGlvbiBsb2FkKCkge1xuXG5cdFx0dmFyIHNjcmlwdHMgPSBbXSxcblx0XHRcdHNjcmlwdHNBc3luYyA9IFtdLFxuXHRcdFx0c2NyaXB0c1RvUHJlbG9hZCA9IDA7XG5cblx0XHQvLyBDYWxsZWQgb25jZSBzeW5jaHJvbm91cyBzY3JpcHRzIGZpbmlzaCBsb2FkaW5nXG5cdFx0ZnVuY3Rpb24gcHJvY2VlZCgpIHtcblx0XHRcdGlmKCBzY3JpcHRzQXN5bmMubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBMb2FkIGFzeW5jaHJvbm91cyBzY3JpcHRzXG5cdFx0XHRcdGhlYWQuanMuYXBwbHkoIG51bGwsIHNjcmlwdHNBc3luYyApO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFydCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxvYWRTY3JpcHQoIHMgKSB7XG5cdFx0XHRoZWFkLnJlYWR5KCBzLnNyYy5tYXRjaCggLyhbXFx3XFxkX1xcLV0qKVxcLj9qcyhcXD9bXFx3XFxkLj0mXSopPyR8W15cXFxcXFwvXSokL2kgKVswXSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEV4dGVuc2lvbiBtYXkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcblx0XHRcdFx0aWYoIHR5cGVvZiBzLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHMuY2FsbGJhY2suYXBwbHkoIHRoaXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAtLXNjcmlwdHNUb1ByZWxvYWQgPT09IDAgKSB7XG5cdFx0XHRcdFx0cHJvY2VlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmb3IoIHZhciBpID0gMCwgbGVuID0gY29uZmlnLmRlcGVuZGVuY2llcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHZhciBzID0gY29uZmlnLmRlcGVuZGVuY2llc1tpXTtcblxuXHRcdFx0Ly8gTG9hZCBpZiB0aGVyZSdzIG5vIGNvbmRpdGlvbiBvciB0aGUgY29uZGl0aW9uIGlzIHRydXRoeVxuXHRcdFx0aWYoICFzLmNvbmRpdGlvbiB8fCBzLmNvbmRpdGlvbigpICkge1xuXHRcdFx0XHRpZiggcy5hc3luYyApIHtcblx0XHRcdFx0XHRzY3JpcHRzQXN5bmMucHVzaCggcy5zcmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIHMuc3JjICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb2FkU2NyaXB0KCBzICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdFx0c2NyaXB0c1RvUHJlbG9hZCA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBMb2FkIHN5bmNocm9ub3VzIHNjcmlwdHNcblx0XHRcdGhlYWQuanMuYXBwbHkoIG51bGwsIHNjcmlwdHMgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwcm9jZWVkKCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIHVwIHJldmVhbC5qcyBieSBiaW5kaW5nIGlucHV0IGV2ZW50cyBhbmQgbmF2aWdhdGluZ1xuXHQgKiB0byB0aGUgY3VycmVudCBVUkwgZGVlcGxpbmsgaWYgdGhlcmUgaXMgb25lLlxuXHQgKi9cblx0ZnVuY3Rpb24gc3RhcnQoKSB7XG5cblx0XHRsb2FkZWQgPSB0cnVlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlJ3ZlIGdvdCBhbGwgdGhlIERPTSBlbGVtZW50cyB3ZSBuZWVkXG5cdFx0c2V0dXBET00oKTtcblxuXHRcdC8vIExpc3RlbiB0byBtZXNzYWdlcyBwb3N0ZWQgdG8gdGhpcyB3aW5kb3dcblx0XHRzZXR1cFBvc3RNZXNzYWdlKCk7XG5cblx0XHQvLyBQcmV2ZW50IHRoZSBzbGlkZXMgZnJvbSBiZWluZyBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuXHRcdHNldHVwU2Nyb2xsUHJldmVudGlvbigpO1xuXG5cdFx0Ly8gUmVzZXRzIGFsbCB2ZXJ0aWNhbCBzbGlkZXMgc28gdGhhdCBvbmx5IHRoZSBmaXJzdCBpcyB2aXNpYmxlXG5cdFx0cmVzZXRWZXJ0aWNhbFNsaWRlcygpO1xuXG5cdFx0Ly8gVXBkYXRlcyB0aGUgcHJlc2VudGF0aW9uIHRvIG1hdGNoIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gdmFsdWVzXG5cdFx0Y29uZmlndXJlKCk7XG5cblx0XHQvLyBSZWFkIHRoZSBpbml0aWFsIGhhc2hcblx0XHRyZWFkVVJMKCk7XG5cblx0XHQvLyBVcGRhdGUgYWxsIGJhY2tncm91bmRzXG5cdFx0dXBkYXRlQmFja2dyb3VuZCggdHJ1ZSApO1xuXG5cdFx0Ly8gTm90aWZ5IGxpc3RlbmVycyB0aGF0IHRoZSBwcmVzZW50YXRpb24gaXMgcmVhZHkgYnV0IHVzZSBhIDFtc1xuXHRcdC8vIHRpbWVvdXQgdG8gZW5zdXJlIGl0J3Mgbm90IGZpcmVkIHN5bmNocm9ub3VzbHkgYWZ0ZXIgI2luaXRpYWxpemUoKVxuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRW5hYmxlIHRyYW5zaXRpb25zIG5vdyB0aGF0IHdlJ3JlIGxvYWRlZFxuXHRcdFx0ZG9tLnNsaWRlcy5jbGFzc0xpc3QucmVtb3ZlKCAnbm8tdHJhbnNpdGlvbicgKTtcblxuXHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LmFkZCggJ3JlYWR5JyApO1xuXG5cdFx0XHRkaXNwYXRjaEV2ZW50KCAncmVhZHknLCB7XG5cdFx0XHRcdCdpbmRleGgnOiBpbmRleGgsXG5cdFx0XHRcdCdpbmRleHYnOiBpbmRleHYsXG5cdFx0XHRcdCdjdXJyZW50U2xpZGUnOiBjdXJyZW50U2xpZGVcblx0XHRcdH0gKTtcblx0XHR9LCAxICk7XG5cblx0XHQvLyBTcGVjaWFsIHNldHVwIGFuZCBjb25maWcgaXMgcmVxdWlyZWQgd2hlbiBwcmludGluZyB0byBQREZcblx0XHRpZiggaXNQcmludGluZ1BERigpICkge1xuXHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblxuXHRcdFx0Ly8gVGhlIGRvY3VtZW50IG5lZWRzIHRvIGhhdmUgbG9hZGVkIGZvciB0aGUgUERGIGxheW91dFxuXHRcdFx0Ly8gbWVhc3VyZW1lbnRzIHRvIGJlIGFjY3VyYXRlXG5cdFx0XHRpZiggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyApIHtcblx0XHRcdFx0c2V0dXBQREYoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBzZXR1cFBERiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIGFuZCBzdG9yZXMgcmVmZXJlbmNlcyB0byBET00gZWxlbWVudHMgd2hpY2ggYXJlXG5cdCAqIHJlcXVpcmVkIGJ5IHRoZSBwcmVzZW50YXRpb24uIElmIGEgcmVxdWlyZWQgZWxlbWVudCBpc1xuXHQgKiBub3QgZm91bmQsIGl0IGlzIGNyZWF0ZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXR1cERPTSgpIHtcblxuXHRcdC8vIFByZXZlbnQgdHJhbnNpdGlvbnMgd2hpbGUgd2UncmUgbG9hZGluZ1xuXHRcdGRvbS5zbGlkZXMuY2xhc3NMaXN0LmFkZCggJ25vLXRyYW5zaXRpb24nICk7XG5cblx0XHRpZiggaXNNb2JpbGVEZXZpY2UgKSB7XG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnbm8taG92ZXInICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSggJ25vLWhvdmVyJyApO1xuXHRcdH1cblxuXHRcdGlmKCAvaXBob25lL2dpLnRlc3QoIFVBICkgKSB7XG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAndWEtaXBob25lJyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoICd1YS1pcGhvbmUnICk7XG5cdFx0fVxuXG5cdFx0Ly8gQmFja2dyb3VuZCBlbGVtZW50XG5cdFx0ZG9tLmJhY2tncm91bmQgPSBjcmVhdGVTaW5nbGV0b25Ob2RlKCBkb20ud3JhcHBlciwgJ2RpdicsICdiYWNrZ3JvdW5kcycsIG51bGwgKTtcblxuXHRcdC8vIFByb2dyZXNzIGJhclxuXHRcdGRvbS5wcm9ncmVzcyA9IGNyZWF0ZVNpbmdsZXRvbk5vZGUoIGRvbS53cmFwcGVyLCAnZGl2JywgJ3Byb2dyZXNzJywgJzxzcGFuPjwvc3Bhbj4nICk7XG5cdFx0ZG9tLnByb2dyZXNzYmFyID0gZG9tLnByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoICdzcGFuJyApO1xuXG5cdFx0Ly8gQXJyb3cgY29udHJvbHNcblx0XHRkb20uY29udHJvbHMgPSBjcmVhdGVTaW5nbGV0b25Ob2RlKCBkb20ud3JhcHBlciwgJ2FzaWRlJywgJ2NvbnRyb2xzJyxcblx0XHRcdCc8YnV0dG9uIGNsYXNzPVwibmF2aWdhdGUtbGVmdFwiIGFyaWEtbGFiZWw9XCJwcmV2aW91cyBzbGlkZVwiPjxkaXYgY2xhc3M9XCJjb250cm9scy1hcnJvd1wiPjwvZGl2PjwvYnV0dG9uPicgK1xuXHRcdFx0JzxidXR0b24gY2xhc3M9XCJuYXZpZ2F0ZS1yaWdodFwiIGFyaWEtbGFiZWw9XCJuZXh0IHNsaWRlXCI+PGRpdiBjbGFzcz1cImNvbnRyb2xzLWFycm93XCI+PC9kaXY+PC9idXR0b24+JyArXG5cdFx0XHQnPGJ1dHRvbiBjbGFzcz1cIm5hdmlnYXRlLXVwXCIgYXJpYS1sYWJlbD1cImFib3ZlIHNsaWRlXCI+PGRpdiBjbGFzcz1cImNvbnRyb2xzLWFycm93XCI+PC9kaXY+PC9idXR0b24+JyArXG5cdFx0XHQnPGJ1dHRvbiBjbGFzcz1cIm5hdmlnYXRlLWRvd25cIiBhcmlhLWxhYmVsPVwiYmVsb3cgc2xpZGVcIj48ZGl2IGNsYXNzPVwiY29udHJvbHMtYXJyb3dcIj48L2Rpdj48L2J1dHRvbj4nICk7XG5cblx0XHQvLyBTbGlkZSBudW1iZXJcblx0XHRkb20uc2xpZGVOdW1iZXIgPSBjcmVhdGVTaW5nbGV0b25Ob2RlKCBkb20ud3JhcHBlciwgJ2RpdicsICdzbGlkZS1udW1iZXInLCAnJyApO1xuXG5cdFx0Ly8gRWxlbWVudCBjb250YWluaW5nIG5vdGVzIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIGF1ZGllbmNlXG5cdFx0ZG9tLnNwZWFrZXJOb3RlcyA9IGNyZWF0ZVNpbmdsZXRvbk5vZGUoIGRvbS53cmFwcGVyLCAnZGl2JywgJ3NwZWFrZXItbm90ZXMnLCBudWxsICk7XG5cdFx0ZG9tLnNwZWFrZXJOb3Rlcy5zZXRBdHRyaWJ1dGUoICdkYXRhLXByZXZlbnQtc3dpcGUnLCAnJyApO1xuXHRcdGRvbS5zcGVha2VyTm90ZXMuc2V0QXR0cmlidXRlKCAndGFiaW5kZXgnLCAnMCcgKTtcblxuXHRcdC8vIE92ZXJsYXkgZ3JhcGhpYyB3aGljaCBpcyBkaXNwbGF5ZWQgZHVyaW5nIHRoZSBwYXVzZWQgbW9kZVxuXHRcdGRvbS5wYXVzZU92ZXJsYXkgPSBjcmVhdGVTaW5nbGV0b25Ob2RlKCBkb20ud3JhcHBlciwgJ2RpdicsICdwYXVzZS1vdmVybGF5JywgJzxidXR0b24gY2xhc3M9XCJyZXN1bWUtYnV0dG9uXCI+UmVzdW1lIHByZXNlbnRhdGlvbjwvYnV0dG9uPicgKTtcblx0XHRkb20ucmVzdW1lQnV0dG9uID0gZG9tLnBhdXNlT3ZlcmxheS5xdWVyeVNlbGVjdG9yKCAnLnJlc3VtZS1idXR0b24nICk7XG5cblx0XHRkb20ud3JhcHBlci5zZXRBdHRyaWJ1dGUoICdyb2xlJywgJ2FwcGxpY2F0aW9uJyApO1xuXG5cdFx0Ly8gVGhlcmUgY2FuIGJlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBjb250cm9scyB0aHJvdWdob3V0IHRoZSBwYWdlXG5cdFx0ZG9tLmNvbnRyb2xzTGVmdCA9IHRvQXJyYXkoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcubmF2aWdhdGUtbGVmdCcgKSApO1xuXHRcdGRvbS5jb250cm9sc1JpZ2h0ID0gdG9BcnJheSggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJy5uYXZpZ2F0ZS1yaWdodCcgKSApO1xuXHRcdGRvbS5jb250cm9sc1VwID0gdG9BcnJheSggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJy5uYXZpZ2F0ZS11cCcgKSApO1xuXHRcdGRvbS5jb250cm9sc0Rvd24gPSB0b0FycmF5KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnLm5hdmlnYXRlLWRvd24nICkgKTtcblx0XHRkb20uY29udHJvbHNQcmV2ID0gdG9BcnJheSggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJy5uYXZpZ2F0ZS1wcmV2JyApICk7XG5cdFx0ZG9tLmNvbnRyb2xzTmV4dCA9IHRvQXJyYXkoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcubmF2aWdhdGUtbmV4dCcgKSApO1xuXG5cdFx0Ly8gVGhlIHJpZ2h0IGFuZCBkb3duIGFycm93cyBpbiB0aGUgc3RhbmRhcmQgcmV2ZWFsLmpzIGNvbnRyb2xzXG5cdFx0ZG9tLmNvbnRyb2xzUmlnaHRBcnJvdyA9IGRvbS5jb250cm9scy5xdWVyeVNlbGVjdG9yKCAnLm5hdmlnYXRlLXJpZ2h0JyApO1xuXHRcdGRvbS5jb250cm9sc0Rvd25BcnJvdyA9IGRvbS5jb250cm9scy5xdWVyeVNlbGVjdG9yKCAnLm5hdmlnYXRlLWRvd24nICk7XG5cblx0XHRkb20uc3RhdHVzRGl2ID0gY3JlYXRlU3RhdHVzRGl2KCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGhpZGRlbiBkaXYgd2l0aCByb2xlIGFyaWEtbGl2ZSB0byBhbm5vdW5jZSB0aGVcblx0ICogY3VycmVudCBzbGlkZSBjb250ZW50LiBIaWRlIHRoZSBkaXYgb2ZmLXNjcmVlbiB0byBtYWtlIGl0XG5cdCAqIGF2YWlsYWJsZSBvbmx5IHRvIEFzc2lzdGl2ZSBUZWNobm9sb2dpZXMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlU3RhdHVzRGl2KCkge1xuXG5cdFx0dmFyIHN0YXR1c0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnYXJpYS1zdGF0dXMtZGl2JyApO1xuXHRcdGlmKCAhc3RhdHVzRGl2ICkge1xuXHRcdFx0c3RhdHVzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHRcdHN0YXR1c0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRzdGF0dXNEaXYuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG5cdFx0XHRzdGF0dXNEaXYuc3R5bGUud2lkdGggPSAnMXB4Jztcblx0XHRcdHN0YXR1c0Rpdi5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXHRcdFx0c3RhdHVzRGl2LnN0eWxlLmNsaXAgPSAncmVjdCggMXB4LCAxcHgsIDFweCwgMXB4ICknO1xuXHRcdFx0c3RhdHVzRGl2LnNldEF0dHJpYnV0ZSggJ2lkJywgJ2FyaWEtc3RhdHVzLWRpdicgKTtcblx0XHRcdHN0YXR1c0Rpdi5zZXRBdHRyaWJ1dGUoICdhcmlhLWxpdmUnLCAncG9saXRlJyApO1xuXHRcdFx0c3RhdHVzRGl2LnNldEF0dHJpYnV0ZSggJ2FyaWEtYXRvbWljJywndHJ1ZScgKTtcblx0XHRcdGRvbS53cmFwcGVyLmFwcGVuZENoaWxkKCBzdGF0dXNEaXYgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0YXR1c0RpdjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBIVE1MIGVsZW1lbnQgaW50byBhIHN0cmluZyBvZiB0ZXh0XG5cdCAqIHRoYXQgY2FuIGJlIGFubm91bmNlZCB0byBhIHNjcmVlbiByZWFkZXIuIEhpZGRlblxuXHQgKiBlbGVtZW50cyBhcmUgZXhjbHVkZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTdGF0dXNUZXh0KCBub2RlICkge1xuXG5cdFx0dmFyIHRleHQgPSAnJztcblxuXHRcdC8vIFRleHQgbm9kZVxuXHRcdGlmKCBub2RlLm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0dGV4dCArPSBub2RlLnRleHRDb250ZW50O1xuXHRcdH1cblx0XHQvLyBFbGVtZW50IG5vZGVcblx0XHRlbHNlIGlmKCBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHR2YXIgaXNBcmlhSGlkZGVuID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdhcmlhLWhpZGRlbicgKTtcblx0XHRcdHZhciBpc0Rpc3BsYXlIaWRkZW4gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbm9kZSApWydkaXNwbGF5J10gPT09ICdub25lJztcblx0XHRcdGlmKCBpc0FyaWFIaWRkZW4gIT09ICd0cnVlJyAmJiAhaXNEaXNwbGF5SGlkZGVuICkge1xuXG5cdFx0XHRcdHRvQXJyYXkoIG5vZGUuY2hpbGROb2RlcyApLmZvckVhY2goIGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0XHR0ZXh0ICs9IGdldFN0YXR1c1RleHQoIGNoaWxkICk7XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmVzIHRoZSBwcmVzZW50YXRpb24gZm9yIHByaW50aW5nIHRvIGEgc3RhdGljXG5cdCAqIFBERi5cblx0ICovXG5cdGZ1bmN0aW9uIHNldHVwUERGKCkge1xuXG5cdFx0dmFyIHNsaWRlU2l6ZSA9IGdldENvbXB1dGVkU2xpZGVTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XG5cblx0XHQvLyBEaW1lbnNpb25zIG9mIHRoZSBQREYgcGFnZXNcblx0XHR2YXIgcGFnZVdpZHRoID0gTWF0aC5mbG9vciggc2xpZGVTaXplLndpZHRoICogKCAxICsgY29uZmlnLm1hcmdpbiApICksXG5cdFx0XHRwYWdlSGVpZ2h0ID0gTWF0aC5mbG9vciggc2xpZGVTaXplLmhlaWdodCAqICggMSArIGNvbmZpZy5tYXJnaW4gKSApO1xuXG5cdFx0Ly8gRGltZW5zaW9ucyBvZiBzbGlkZXMgd2l0aGluIHRoZSBwYWdlc1xuXHRcdHZhciBzbGlkZVdpZHRoID0gc2xpZGVTaXplLndpZHRoLFxuXHRcdFx0c2xpZGVIZWlnaHQgPSBzbGlkZVNpemUuaGVpZ2h0O1xuXG5cdFx0Ly8gTGV0IHRoZSBicm93c2VyIGtub3cgd2hhdCBwYWdlIHNpemUgd2Ugd2FudCB0byBwcmludFxuXHRcdGluamVjdFN0eWxlU2hlZXQoICdAcGFnZXtzaXplOicrIHBhZ2VXaWR0aCArJ3B4ICcrIHBhZ2VIZWlnaHQgKydweDsgbWFyZ2luOiAwcHg7fScgKTtcblxuXHRcdC8vIExpbWl0IHRoZSBzaXplIG9mIGNlcnRhaW4gZWxlbWVudHMgdG8gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlXG5cdFx0aW5qZWN0U3R5bGVTaGVldCggJy5yZXZlYWwgc2VjdGlvbj5pbWcsIC5yZXZlYWwgc2VjdGlvbj52aWRlbywgLnJldmVhbCBzZWN0aW9uPmlmcmFtZXttYXgtd2lkdGg6ICcrIHNsaWRlV2lkdGggKydweDsgbWF4LWhlaWdodDonKyBzbGlkZUhlaWdodCArJ3B4fScgKTtcblxuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCggJ3ByaW50LXBkZicgKTtcblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLndpZHRoID0gcGFnZVdpZHRoICsgJ3B4Jztcblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9IHBhZ2VIZWlnaHQgKyAncHgnO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHN0cmV0Y2ggZWxlbWVudHMgZml0IG9uIHNsaWRlXG5cdFx0bGF5b3V0U2xpZGVDb250ZW50cyggc2xpZGVXaWR0aCwgc2xpZGVIZWlnaHQgKTtcblxuXHRcdC8vIEFkZCBlYWNoIHNsaWRlJ3MgaW5kZXggYXMgYXR0cmlidXRlcyBvbiBpdHNlbGYsIHdlIG5lZWQgdGhlc2Vcblx0XHQvLyBpbmRpY2VzIHRvIGdlbmVyYXRlIHNsaWRlIG51bWJlcnMgYmVsb3dcblx0XHR0b0FycmF5KCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApICkuZm9yRWFjaCggZnVuY3Rpb24oIGhzbGlkZSwgaCApIHtcblx0XHRcdGhzbGlkZS5zZXRBdHRyaWJ1dGUoICdkYXRhLWluZGV4LWgnLCBoICk7XG5cblx0XHRcdGlmKCBoc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCAnc3RhY2snICkgKSB7XG5cdFx0XHRcdHRvQXJyYXkoIGhzbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKSApLmZvckVhY2goIGZ1bmN0aW9uKCB2c2xpZGUsIHYgKSB7XG5cdFx0XHRcdFx0dnNsaWRlLnNldEF0dHJpYnV0ZSggJ2RhdGEtaW5kZXgtaCcsIGggKTtcblx0XHRcdFx0XHR2c2xpZGUuc2V0QXR0cmlidXRlKCAnZGF0YS1pbmRleC12JywgdiApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gU2xpZGUgYW5kIHNsaWRlIGJhY2tncm91bmQgbGF5b3V0XG5cdFx0dG9BcnJheSggZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggU0xJREVTX1NFTEVDVE9SICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggc2xpZGUgKSB7XG5cblx0XHRcdC8vIFZlcnRpY2FsIHN0YWNrcyBhcmUgbm90IGNlbnRyZWQgc2luY2UgdGhlaXIgc2VjdGlvblxuXHRcdFx0Ly8gY2hpbGRyZW4gd2lsbCBiZVxuXHRcdFx0aWYoIHNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ3N0YWNrJyApID09PSBmYWxzZSApIHtcblx0XHRcdFx0Ly8gQ2VudGVyIHRoZSBzbGlkZSBpbnNpZGUgb2YgdGhlIHBhZ2UsIGdpdmluZyB0aGUgc2xpZGUgc29tZSBtYXJnaW5cblx0XHRcdFx0dmFyIGxlZnQgPSAoIHBhZ2VXaWR0aCAtIHNsaWRlV2lkdGggKSAvIDIsXG5cdFx0XHRcdFx0dG9wID0gKCBwYWdlSGVpZ2h0IC0gc2xpZGVIZWlnaHQgKSAvIDI7XG5cblx0XHRcdFx0dmFyIGNvbnRlbnRIZWlnaHQgPSBzbGlkZS5zY3JvbGxIZWlnaHQ7XG5cdFx0XHRcdHZhciBudW1iZXJPZlBhZ2VzID0gTWF0aC5tYXgoIE1hdGguY2VpbCggY29udGVudEhlaWdodCAvIHBhZ2VIZWlnaHQgKSwgMSApO1xuXG5cdFx0XHRcdC8vIEFkaGVyZSB0byBjb25maWd1cmVkIHBhZ2VzIHBlciBzbGlkZSBsaW1pdFxuXHRcdFx0XHRudW1iZXJPZlBhZ2VzID0gTWF0aC5taW4oIG51bWJlck9mUGFnZXMsIGNvbmZpZy5wZGZNYXhQYWdlc1BlclNsaWRlICk7XG5cblx0XHRcdFx0Ly8gQ2VudGVyIHNsaWRlcyB2ZXJ0aWNhbGx5XG5cdFx0XHRcdGlmKCBudW1iZXJPZlBhZ2VzID09PSAxICYmIGNvbmZpZy5jZW50ZXIgfHwgc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCAnY2VudGVyJyApICkge1xuXHRcdFx0XHRcdHRvcCA9IE1hdGgubWF4KCAoIHBhZ2VIZWlnaHQgLSBjb250ZW50SGVpZ2h0ICkgLyAyLCAwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXcmFwIHRoZSBzbGlkZSBpbiBhIHBhZ2UgZWxlbWVudCBhbmQgaGlkZSBpdHMgb3ZlcmZsb3dcblx0XHRcdFx0Ly8gc28gdGhhdCBubyBwYWdlIGV2ZXIgZmxvd3Mgb250byBhbm90aGVyXG5cdFx0XHRcdHZhciBwYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHRcdFx0cGFnZS5jbGFzc05hbWUgPSAncGRmLXBhZ2UnO1xuXHRcdFx0XHRwYWdlLnN0eWxlLmhlaWdodCA9ICggKCBwYWdlSGVpZ2h0ICsgY29uZmlnLnBkZlBhZ2VIZWlnaHRPZmZzZXQgKSAqIG51bWJlck9mUGFnZXMgKSArICdweCc7XG5cdFx0XHRcdHNsaWRlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBwYWdlLCBzbGlkZSApO1xuXHRcdFx0XHRwYWdlLmFwcGVuZENoaWxkKCBzbGlkZSApO1xuXG5cdFx0XHRcdC8vIFBvc2l0aW9uIHRoZSBzbGlkZSBpbnNpZGUgb2YgdGhlIHBhZ2Vcblx0XHRcdFx0c2xpZGUuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuXHRcdFx0XHRzbGlkZS5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuXHRcdFx0XHRzbGlkZS5zdHlsZS53aWR0aCA9IHNsaWRlV2lkdGggKyAncHgnO1xuXG5cdFx0XHRcdGlmKCBzbGlkZS5zbGlkZUJhY2tncm91bmRFbGVtZW50ICkge1xuXHRcdFx0XHRcdHBhZ2UuaW5zZXJ0QmVmb3JlKCBzbGlkZS5zbGlkZUJhY2tncm91bmRFbGVtZW50LCBzbGlkZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSW5qZWN0IG5vdGVzIGlmIGBzaG93Tm90ZXNgIGlzIGVuYWJsZWRcblx0XHRcdFx0aWYoIGNvbmZpZy5zaG93Tm90ZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBBcmUgdGhlcmUgbm90ZXMgZm9yIHRoaXMgc2xpZGU/XG5cdFx0XHRcdFx0dmFyIG5vdGVzID0gZ2V0U2xpZGVOb3Rlcyggc2xpZGUgKTtcblx0XHRcdFx0XHRpZiggbm90ZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBub3Rlc1NwYWNpbmcgPSA4O1xuXHRcdFx0XHRcdFx0dmFyIG5vdGVzTGF5b3V0ID0gdHlwZW9mIGNvbmZpZy5zaG93Tm90ZXMgPT09ICdzdHJpbmcnID8gY29uZmlnLnNob3dOb3RlcyA6ICdpbmxpbmUnO1xuXHRcdFx0XHRcdFx0dmFyIG5vdGVzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRcdFx0XHRub3Rlc0VsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3NwZWFrZXItbm90ZXMnICk7XG5cdFx0XHRcdFx0XHRub3Rlc0VsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3NwZWFrZXItbm90ZXMtcGRmJyApO1xuXHRcdFx0XHRcdFx0bm90ZXNFbGVtZW50LnNldEF0dHJpYnV0ZSggJ2RhdGEtbGF5b3V0Jywgbm90ZXNMYXlvdXQgKTtcblx0XHRcdFx0XHRcdG5vdGVzRWxlbWVudC5pbm5lckhUTUwgPSBub3RlcztcblxuXHRcdFx0XHRcdFx0aWYoIG5vdGVzTGF5b3V0ID09PSAnc2VwYXJhdGUtcGFnZScgKSB7XG5cdFx0XHRcdFx0XHRcdHBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIG5vdGVzRWxlbWVudCwgcGFnZS5uZXh0U2libGluZyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5vdGVzRWxlbWVudC5zdHlsZS5sZWZ0ID0gbm90ZXNTcGFjaW5nICsgJ3B4Jztcblx0XHRcdFx0XHRcdFx0bm90ZXNFbGVtZW50LnN0eWxlLmJvdHRvbSA9IG5vdGVzU3BhY2luZyArICdweCc7XG5cdFx0XHRcdFx0XHRcdG5vdGVzRWxlbWVudC5zdHlsZS53aWR0aCA9ICggcGFnZVdpZHRoIC0gbm90ZXNTcGFjaW5nKjIgKSArICdweCc7XG5cdFx0XHRcdFx0XHRcdHBhZ2UuYXBwZW5kQ2hpbGQoIG5vdGVzRWxlbWVudCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJbmplY3Qgc2xpZGUgbnVtYmVycyBpZiBgc2xpZGVOdW1iZXJzYCBhcmUgZW5hYmxlZFxuXHRcdFx0XHRpZiggY29uZmlnLnNsaWRlTnVtYmVyICYmIC9hbGx8cHJpbnQvaS50ZXN0KCBjb25maWcuc2hvd1NsaWRlTnVtYmVyICkgKSB7XG5cdFx0XHRcdFx0dmFyIHNsaWRlTnVtYmVySCA9IHBhcnNlSW50KCBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWluZGV4LWgnICksIDEwICkgKyAxLFxuXHRcdFx0XHRcdFx0c2xpZGVOdW1iZXJWID0gcGFyc2VJbnQoIHNsaWRlLmdldEF0dHJpYnV0ZSggJ2RhdGEtaW5kZXgtdicgKSwgMTAgKSArIDE7XG5cblx0XHRcdFx0XHR2YXIgbnVtYmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRcdFx0bnVtYmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnc2xpZGUtbnVtYmVyJyApO1xuXHRcdFx0XHRcdG51bWJlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3NsaWRlLW51bWJlci1wZGYnICk7XG5cdFx0XHRcdFx0bnVtYmVyRWxlbWVudC5pbm5lckhUTUwgPSBmb3JtYXRTbGlkZU51bWJlciggc2xpZGVOdW1iZXJILCAnLicsIHNsaWRlTnVtYmVyViApO1xuXHRcdFx0XHRcdHBhZ2UuYXBwZW5kQ2hpbGQoIG51bWJlckVsZW1lbnQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvcHkgcGFnZSBhbmQgc2hvdyBmcmFnbWVudHMgb25lIGFmdGVyIGFub3RoZXJcblx0XHRcdFx0aWYoIGNvbmZpZy5wZGZTZXBhcmF0ZUZyYWdtZW50cyApIHtcblxuXHRcdFx0XHRcdC8vIEVhY2ggZnJhZ21lbnQgJ2dyb3VwJyBpcyBhbiBhcnJheSBjb250YWluaW5nIG9uZSBvciBtb3JlXG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnRzLiBNdWx0aXBsZSBmcmFnbWVudHMgdGhhdCBhcHBlYXIgYXQgdGhlIHNhbWUgdGltZVxuXHRcdFx0XHRcdC8vIGFyZSBwYXJ0IG9mIHRoZSBzYW1lIGdyb3VwLlxuXHRcdFx0XHRcdHZhciBmcmFnbWVudEdyb3VwcyA9IHNvcnRGcmFnbWVudHMoIHBhZ2UucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudCcgKSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0dmFyIHByZXZpb3VzRnJhZ21lbnRTdGVwO1xuXHRcdFx0XHRcdHZhciBwcmV2aW91c1BhZ2U7XG5cblx0XHRcdFx0XHRmcmFnbWVudEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbiggZnJhZ21lbnRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgJ2N1cnJlbnQtZnJhZ21lbnQnIGZyb20gdGhlIHByZXZpb3VzIGdyb3VwXG5cdFx0XHRcdFx0XHRpZiggcHJldmlvdXNGcmFnbWVudFN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdHByZXZpb3VzRnJhZ21lbnRTdGVwLmZvckVhY2goIGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdFx0XHRmcmFnbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAnY3VycmVudC1mcmFnbWVudCcgKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTaG93IHRoZSBmcmFnbWVudHMgZm9yIHRoZSBjdXJyZW50IGluZGV4XG5cdFx0XHRcdFx0XHRmcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0XHRmcmFnbWVudC5jbGFzc0xpc3QuYWRkKCAndmlzaWJsZScsICdjdXJyZW50LWZyYWdtZW50JyApO1xuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBwYWdlIGZvciB0aGUgY3VycmVudCBmcmFnbWVudCBzdGF0ZVxuXHRcdFx0XHRcdFx0dmFyIGNsb25lZFBhZ2UgPSBwYWdlLmNsb25lTm9kZSggdHJ1ZSApO1xuXHRcdFx0XHRcdFx0cGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggY2xvbmVkUGFnZSwgKCBwcmV2aW91c1BhZ2UgfHwgcGFnZSApLm5leHRTaWJsaW5nICk7XG5cblx0XHRcdFx0XHRcdHByZXZpb3VzRnJhZ21lbnRTdGVwID0gZnJhZ21lbnRzO1xuXHRcdFx0XHRcdFx0cHJldmlvdXNQYWdlID0gY2xvbmVkUGFnZTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBmaXJzdC9vcmlnaW5hbCBwYWdlIHNvIHRoYXQgYWxsIGZyYWdtZW50cyBhcmUgaGlkZGVuXG5cdFx0XHRcdFx0ZnJhZ21lbnRHcm91cHMuZm9yRWFjaCggZnVuY3Rpb24oIGZyYWdtZW50cyApIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50LmNsYXNzTGlzdC5yZW1vdmUoICd2aXNpYmxlJywgJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU2hvdyBhbGwgZnJhZ21lbnRzXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRvQXJyYXkoIHBhZ2UucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudDpub3QoLmZhZGUtb3V0KScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50LmNsYXNzTGlzdC5hZGQoICd2aXNpYmxlJyApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHQvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCB0aGUgUERGIGxheW91dCBpcyBnb29kIHRvIGdvXG5cdFx0ZGlzcGF0Y2hFdmVudCggJ3BkZi1yZWFkeScgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgaXMgYW4gdW5mb3J0dW5hdGUgbmVjZXNzaXR5LiBTb21lIGFjdGlvbnMg4oCTIHN1Y2ggYXNcblx0ICogYW4gaW5wdXQgZmllbGQgYmVpbmcgZm9jdXNlZCBpbiBhbiBpZnJhbWUgb3IgdXNpbmcgdGhlXG5cdCAqIGtleWJvYXJkIHRvIGV4cGFuZCB0ZXh0IHNlbGVjdGlvbiBiZXlvbmQgdGhlIGJvdW5kcyBvZlxuXHQgKiBhIHNsaWRlIOKAkyBjYW4gdHJpZ2dlciBvdXIgY29udGVudCB0byBiZSBwdXNoZWQgb3V0IG9mIHZpZXcuXG5cdCAqIFRoaXMgc2Nyb2xsaW5nIGNhbiBub3QgYmUgcHJldmVudGVkIGJ5IGhpZGluZyBvdmVyZmxvdyBpblxuXHQgKiBDU1MgKHdlIGFscmVhZHkgZG8pIHNvIHdlIGhhdmUgdG8gcmVzb3J0IHRvIHJlcGVhdGVkbHlcblx0ICogY2hlY2tpbmcgaWYgdGhlIHNsaWRlcyBoYXZlIGJlZW4gb2Zmc2V0IDooXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXR1cFNjcm9sbFByZXZlbnRpb24oKSB7XG5cblx0XHRzZXRJbnRlcnZhbCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiggZG9tLndyYXBwZXIuc2Nyb2xsVG9wICE9PSAwIHx8IGRvbS53cmFwcGVyLnNjcm9sbExlZnQgIT09IDAgKSB7XG5cdFx0XHRcdGRvbS53cmFwcGVyLnNjcm9sbFRvcCA9IDA7XG5cdFx0XHRcdGRvbS53cmFwcGVyLnNjcm9sbExlZnQgPSAwO1xuXHRcdFx0fVxuXHRcdH0sIDEwMDAgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0LlxuXHQgKiBJZiB0aGUgZWxlbWVudCBhbHJlYWR5IGV4aXN0cyB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugd2lsbFxuXHQgKiBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWduYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc25hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlubmVySFRNTFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbk5vZGUoIGNvbnRhaW5lciwgdGFnbmFtZSwgY2xhc3NuYW1lLCBpbm5lckhUTUwgKSB7XG5cblx0XHQvLyBGaW5kIGFsbCBub2RlcyBtYXRjaGluZyB0aGUgZGVzY3JpcHRpb25cblx0XHR2YXIgbm9kZXMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCggJy4nICsgY2xhc3NuYW1lICk7XG5cblx0XHQvLyBDaGVjayBhbGwgbWF0Y2hlcyB0byBmaW5kIG9uZSB3aGljaCBpcyBhIGRpcmVjdCBjaGlsZCBvZlxuXHRcdC8vIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdHZhciB0ZXN0Tm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYoIHRlc3ROb2RlLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lciApIHtcblx0XHRcdFx0cmV0dXJuIHRlc3ROb2RlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIG5vIG5vZGUgd2FzIGZvdW5kLCBjcmVhdGUgaXQgbm93XG5cdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0YWduYW1lICk7XG5cdFx0bm9kZS5jbGFzc05hbWUgPSBjbGFzc25hbWU7XG5cdFx0aWYoIHR5cGVvZiBpbm5lckhUTUwgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG5cdFx0fVxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggbm9kZSApO1xuXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBzbGlkZSBiYWNrZ3JvdW5kIGVsZW1lbnRzIGFuZCBhcHBlbmRzIHRoZW1cblx0ICogdG8gdGhlIGJhY2tncm91bmQgY29udGFpbmVyLiBPbmUgZWxlbWVudCBpcyBjcmVhdGVkIHBlclxuXHQgKiBzbGlkZSBubyBtYXR0ZXIgaWYgdGhlIGdpdmVuIHNsaWRlIGhhcyB2aXNpYmxlIGJhY2tncm91bmQuXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVCYWNrZ3JvdW5kcygpIHtcblxuXHRcdHZhciBwcmludE1vZGUgPSBpc1ByaW50aW5nUERGKCk7XG5cblx0XHQvLyBDbGVhciBwcmlvciBiYWNrZ3JvdW5kc1xuXHRcdGRvbS5iYWNrZ3JvdW5kLmlubmVySFRNTCA9ICcnO1xuXHRcdGRvbS5iYWNrZ3JvdW5kLmNsYXNzTGlzdC5hZGQoICduby10cmFuc2l0aW9uJyApO1xuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBob3Jpem9udGFsIHNsaWRlc1xuXHRcdHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggc2xpZGVoICkge1xuXG5cdFx0XHR2YXIgYmFja2dyb3VuZFN0YWNrID0gY3JlYXRlQmFja2dyb3VuZCggc2xpZGVoLCBkb20uYmFja2dyb3VuZCApO1xuXG5cdFx0XHQvLyBJdGVyYXRlIG92ZXIgYWxsIHZlcnRpY2FsIHNsaWRlc1xuXHRcdFx0dG9BcnJheSggc2xpZGVoLnF1ZXJ5U2VsZWN0b3JBbGwoICdzZWN0aW9uJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIHNsaWRldiApIHtcblxuXHRcdFx0XHRjcmVhdGVCYWNrZ3JvdW5kKCBzbGlkZXYsIGJhY2tncm91bmRTdGFjayApO1xuXG5cdFx0XHRcdGJhY2tncm91bmRTdGFjay5jbGFzc0xpc3QuYWRkKCAnc3RhY2snICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHRcdC8vIEFkZCBwYXJhbGxheCBiYWNrZ3JvdW5kIGlmIHNwZWNpZmllZFxuXHRcdGlmKCBjb25maWcucGFyYWxsYXhCYWNrZ3JvdW5kSW1hZ2UgKSB7XG5cblx0XHRcdGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInICsgY29uZmlnLnBhcmFsbGF4QmFja2dyb3VuZEltYWdlICsgJ1wiKSc7XG5cdFx0XHRkb20uYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNvbmZpZy5wYXJhbGxheEJhY2tncm91bmRTaXplO1xuXHRcdFx0ZG9tLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IGNvbmZpZy5wYXJhbGxheEJhY2tncm91bmRSZXBlYXQ7XG5cdFx0XHRkb20uYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjb25maWcucGFyYWxsYXhCYWNrZ3JvdW5kUG9zaXRpb247XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgYmVsb3cgcHJvcGVydGllcyBhcmUgc2V0IG9uIHRoZSBlbGVtZW50IC0gdGhlc2UgcHJvcGVydGllcyBhcmVcblx0XHRcdC8vIG5lZWRlZCBmb3IgcHJvcGVyIHRyYW5zaXRpb25zIHRvIGJlIHNldCBvbiB0aGUgZWxlbWVudCB2aWEgQ1NTLiBUbyByZW1vdmVcblx0XHRcdC8vIGFubm95aW5nIGJhY2tncm91bmQgc2xpZGUtaW4gZWZmZWN0IHdoZW4gdGhlIHByZXNlbnRhdGlvbiBzdGFydHMsIGFwcGx5XG5cdFx0XHQvLyB0aGVzZSBwcm9wZXJ0aWVzIGFmdGVyIHNob3J0IHRpbWUgZGVsYXlcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnaGFzLXBhcmFsbGF4LWJhY2tncm91bmQnICk7XG5cdFx0XHR9LCAxICk7XG5cblx0XHR9XG5cdFx0ZWxzZSB7XG5cblx0XHRcdGRvbS5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICcnO1xuXHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSggJ2hhcy1wYXJhbGxheC1iYWNrZ3JvdW5kJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJhY2tncm91bmQgZm9yIHRoZSBnaXZlbiBzbGlkZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2xpZGVcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBlbGVtZW50IHRoYXQgdGhlIGJhY2tncm91bmRcblx0ICogc2hvdWxkIGJlIGFwcGVuZGVkIHRvXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBOZXcgYmFja2dyb3VuZCBkaXZcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUJhY2tncm91bmQoIHNsaWRlLCBjb250YWluZXIgKSB7XG5cblxuXHRcdC8vIE1haW4gc2xpZGUgYmFja2dyb3VuZCBlbGVtZW50XG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gJ3NsaWRlLWJhY2tncm91bmQgJyArIHNsaWRlLmNsYXNzTmFtZS5yZXBsYWNlKCAvcHJlc2VudHxwYXN0fGZ1dHVyZS8sICcnICk7XG5cblx0XHQvLyBJbm5lciBiYWNrZ3JvdW5kIGVsZW1lbnQgdGhhdCB3cmFwcyBpbWFnZXMvdmlkZW9zL2lmcmFtZXNcblx0XHR2YXIgY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdGNvbnRlbnRFbGVtZW50LmNsYXNzTmFtZSA9ICdzbGlkZS1iYWNrZ3JvdW5kLWNvbnRlbnQnO1xuXG5cdFx0ZWxlbWVudC5hcHBlbmRDaGlsZCggY29udGVudEVsZW1lbnQgKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGVsZW1lbnQgKTtcblxuXHRcdHNsaWRlLnNsaWRlQmFja2dyb3VuZEVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHNsaWRlLnNsaWRlQmFja2dyb3VuZENvbnRlbnRFbGVtZW50ID0gY29udGVudEVsZW1lbnQ7XG5cblx0XHQvLyBTeW5jcyB0aGUgYmFja2dyb3VuZCB0byByZWZsZWN0IGFsbCBjdXJyZW50IGJhY2tncm91bmQgc2V0dGluZ3Ncblx0XHRzeW5jQmFja2dyb3VuZCggc2xpZGUgKTtcblxuXHRcdHJldHVybiBlbGVtZW50O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyBhbGwgb2YgdGhlIHZpc3VhbCBwcm9wZXJ0aWVzIG9mIGEgc2xpZGUgYmFja2dyb3VuZFxuXHQgKiBiYXNlZCBvbiB0aGUgdmFyaW91cyBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNsaWRlXG5cdCAqL1xuXHRmdW5jdGlvbiBzeW5jQmFja2dyb3VuZCggc2xpZGUgKSB7XG5cblx0XHR2YXIgZWxlbWVudCA9IHNsaWRlLnNsaWRlQmFja2dyb3VuZEVsZW1lbnQsXG5cdFx0XHRjb250ZW50RWxlbWVudCA9IHNsaWRlLnNsaWRlQmFja2dyb3VuZENvbnRlbnRFbGVtZW50O1xuXG5cdFx0Ly8gUmVzZXQgdGhlIHByaW9yIGJhY2tncm91bmQgc3RhdGUgaW4gY2FzZSB0aGlzIGlzIG5vdCB0aGVcblx0XHQvLyBpbml0aWFsIHN5bmNcblx0XHRzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKCAnaGFzLWRhcmstYmFja2dyb3VuZCcgKTtcblx0XHRzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKCAnaGFzLWxpZ2h0LWJhY2tncm91bmQnICk7XG5cblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtbG9hZGVkJyApO1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLWhhc2gnICk7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtc2l6ZScgKTtcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC10cmFuc2l0aW9uJyApO1xuXHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyc7XG5cblx0XHRjb250ZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICcnO1xuXHRcdGNvbnRlbnRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSAnJztcblx0XHRjb250ZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnJztcblx0XHRjb250ZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJztcblx0XHRjb250ZW50RWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJyc7XG5cdFx0Y29udGVudEVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG5cblx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdGJhY2tncm91bmQ6IHNsaWRlLmdldEF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZCcgKSxcblx0XHRcdGJhY2tncm91bmRTaXplOiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtc2l6ZScgKSxcblx0XHRcdGJhY2tncm91bmRJbWFnZTogc2xpZGUuZ2V0QXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLWltYWdlJyApLFxuXHRcdFx0YmFja2dyb3VuZFZpZGVvOiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtdmlkZW8nICksXG5cdFx0XHRiYWNrZ3JvdW5kSWZyYW1lOiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtaWZyYW1lJyApLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtY29sb3InICksXG5cdFx0XHRiYWNrZ3JvdW5kUmVwZWF0OiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtcmVwZWF0JyApLFxuXHRcdFx0YmFja2dyb3VuZFBvc2l0aW9uOiBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtcG9zaXRpb24nICksXG5cdFx0XHRiYWNrZ3JvdW5kVHJhbnNpdGlvbjogc2xpZGUuZ2V0QXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLXRyYW5zaXRpb24nICksXG5cdFx0XHRiYWNrZ3JvdW5kT3BhY2l0eTogc2xpZGUuZ2V0QXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLW9wYWNpdHknIClcblx0XHR9O1xuXG5cdFx0aWYoIGRhdGEuYmFja2dyb3VuZCApIHtcblx0XHRcdC8vIEF1dG8td3JhcCBpbWFnZSB1cmxzIGluIHVybCguLi4pXG5cdFx0XHRpZiggL14oaHR0cHxmaWxlfFxcL1xcLykvZ2kudGVzdCggZGF0YS5iYWNrZ3JvdW5kICkgfHwgL1xcLihzdmd8cG5nfGpwZ3xqcGVnfGdpZnxibXApKFs/I1xcc118JCkvZ2kudGVzdCggZGF0YS5iYWNrZ3JvdW5kICkgKSB7XG5cdFx0XHRcdHNsaWRlLnNldEF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC1pbWFnZScsIGRhdGEuYmFja2dyb3VuZCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9IGRhdGEuYmFja2dyb3VuZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSBoYXNoIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIGJhY2tncm91bmQgc2V0dGluZ3MuXG5cdFx0Ly8gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVuIHR3byBzbGlkZSBiYWNrZ3JvdW5kcyBhcmVcblx0XHQvLyB0aGUgc2FtZS5cblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kIHx8IGRhdGEuYmFja2dyb3VuZENvbG9yIHx8IGRhdGEuYmFja2dyb3VuZEltYWdlIHx8IGRhdGEuYmFja2dyb3VuZFZpZGVvIHx8IGRhdGEuYmFja2dyb3VuZElmcmFtZSApIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLWhhc2gnLCBkYXRhLmJhY2tncm91bmQgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5iYWNrZ3JvdW5kU2l6ZSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmJhY2tncm91bmRJbWFnZSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmJhY2tncm91bmRWaWRlbyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhLmJhY2tncm91bmRJZnJhbWUgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5iYWNrZ3JvdW5kQ29sb3IgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5iYWNrZ3JvdW5kUmVwZWF0ICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuYmFja2dyb3VuZFBvc2l0aW9uICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuYmFja2dyb3VuZFRyYW5zaXRpb24gK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5iYWNrZ3JvdW5kT3BhY2l0eSApO1xuXHRcdH1cblxuXHRcdC8vIEFkZGl0aW9uYWwgYW5kIG9wdGlvbmFsIGJhY2tncm91bmQgcHJvcGVydGllc1xuXHRcdGlmKCBkYXRhLmJhY2tncm91bmRTaXplICkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtc2l6ZScsIGRhdGEuYmFja2dyb3VuZFNpemUgKTtcblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kQ29sb3IgKSBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGRhdGEuYmFja2dyb3VuZENvbG9yO1xuXHRcdGlmKCBkYXRhLmJhY2tncm91bmRUcmFuc2l0aW9uICkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtdHJhbnNpdGlvbicsIGRhdGEuYmFja2dyb3VuZFRyYW5zaXRpb24gKTtcblxuXHRcdC8vIEJhY2tncm91bmQgaW1hZ2Ugb3B0aW9ucyBhcmUgc2V0IG9uIHRoZSBjb250ZW50IHdyYXBwZXJcblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kU2l6ZSApIGNvbnRlbnRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplID0gZGF0YS5iYWNrZ3JvdW5kU2l6ZTtcblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kUmVwZWF0ICkgY29udGVudEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IGRhdGEuYmFja2dyb3VuZFJlcGVhdDtcblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kUG9zaXRpb24gKSBjb250ZW50RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBkYXRhLmJhY2tncm91bmRQb3NpdGlvbjtcblx0XHRpZiggZGF0YS5iYWNrZ3JvdW5kT3BhY2l0eSApIGNvbnRlbnRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBkYXRhLmJhY2tncm91bmRPcGFjaXR5O1xuXG5cdFx0Ly8gSWYgdGhpcyBzbGlkZSBoYXMgYSBiYWNrZ3JvdW5kIGNvbG9yLCBhZGQgYSBjbGFzcyB0aGF0XG5cdFx0Ly8gc2lnbmFscyBpZiBpdCBpcyBsaWdodCBvciBkYXJrLiBJZiB0aGUgc2xpZGUgaGFzIG5vIGJhY2tncm91bmRcblx0XHQvLyBjb2xvciwgbm8gY2xhc3Mgd2lsbCBiZSBzZXRcblx0XHR2YXIgY29tcHV0ZWRCYWNrZ3JvdW5kU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbWVudCApO1xuXHRcdGlmKCBjb21wdXRlZEJhY2tncm91bmRTdHlsZSAmJiBjb21wdXRlZEJhY2tncm91bmRTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgKSB7XG5cdFx0XHR2YXIgcmdiID0gY29sb3JUb1JnYiggY29tcHV0ZWRCYWNrZ3JvdW5kU3R5bGUuYmFja2dyb3VuZENvbG9yICk7XG5cblx0XHRcdC8vIElnbm9yZSBmdWxseSB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kcy4gU29tZSBicm93c2VycyByZXR1cm5cblx0XHRcdC8vIHJnYmEoMCwwLDAsMCkgd2hlbiByZWFkaW5nIHRoZSBjb21wdXRlZCBiYWNrZ3JvdW5kIGNvbG9yIG9mXG5cdFx0XHQvLyBhbiBlbGVtZW50IHdpdGggbm8gYmFja2dyb3VuZFxuXHRcdFx0aWYoIHJnYiAmJiByZ2IuYSAhPT0gMCApIHtcblx0XHRcdFx0aWYoIGNvbG9yQnJpZ2h0bmVzcyggY29tcHV0ZWRCYWNrZ3JvdW5kU3R5bGUuYmFja2dyb3VuZENvbG9yICkgPCAxMjggKSB7XG5cdFx0XHRcdFx0c2xpZGUuY2xhc3NMaXN0LmFkZCggJ2hhcy1kYXJrLWJhY2tncm91bmQnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c2xpZGUuY2xhc3NMaXN0LmFkZCggJ2hhcy1saWdodC1iYWNrZ3JvdW5kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdG8gcG9zdE1lc3NhZ2UgZXZlbnRzLCB0aGlzIG1ha2VzIGl0XG5cdCAqIHBvc3NpYmxlIHRvIGNhbGwgYWxsIHJldmVhbC5qcyBBUEkgbWV0aG9kcyBmcm9tIGFub3RoZXJcblx0ICogd2luZG93LiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogcmV2ZWFsV2luZG93LnBvc3RNZXNzYWdlKCBKU09OLnN0cmluZ2lmeSh7XG5cdCAqICAgbWV0aG9kOiAnc2xpZGUnLFxuXHQgKiAgIGFyZ3M6IFsgMiBdXG5cdCAqIH0pLCAnKicgKTtcblx0ICovXG5cdGZ1bmN0aW9uIHNldHVwUG9zdE1lc3NhZ2UoKSB7XG5cblx0XHRpZiggY29uZmlnLnBvc3RNZXNzYWdlICkge1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtZXNzYWdlJywgZnVuY3Rpb24gKCBldmVudCApIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSdyZSBkZWFsaW5nIHdpdGggSlNPTlxuXHRcdFx0XHRpZiggdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEuY2hhckF0KCAwICkgPT09ICd7JyAmJiBkYXRhLmNoYXJBdCggZGF0YS5sZW5ndGggLSAxICkgPT09ICd9JyApIHtcblx0XHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZSggZGF0YSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCBtZXRob2QgY2FuIGJlIGZvdW5kXG5cdFx0XHRcdFx0aWYoIGRhdGEubWV0aG9kICYmIHR5cGVvZiBSZXZlYWxbZGF0YS5tZXRob2RdID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0UmV2ZWFsW2RhdGEubWV0aG9kXS5hcHBseSggUmV2ZWFsLCBkYXRhLmFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmcm9tIHRoZSBjb25maWdcblx0ICogb2JqZWN0LiBNYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gY29uZmlndXJlKCBvcHRpb25zICkge1xuXG5cdFx0dmFyIG9sZFRyYW5zaXRpb24gPSBjb25maWcudHJhbnNpdGlvbjtcblxuXHRcdC8vIE5ldyBjb25maWcgb3B0aW9ucyBtYXkgYmUgcGFzc2VkIHdoZW4gdGhpcyBtZXRob2Rcblx0XHQvLyBpcyBpbnZva2VkIHRocm91Z2ggdGhlIEFQSSBhZnRlciBpbml0aWFsaXphdGlvblxuXHRcdGlmKCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgKSBleHRlbmQoIGNvbmZpZywgb3B0aW9ucyApO1xuXG5cdFx0Ly8gQWJvcnQgaWYgcmV2ZWFsLmpzIGhhc24ndCBmaW5pc2hlZCBsb2FkaW5nLCBjb25maWdcblx0XHQvLyBjaGFuZ2VzIHdpbGwgYmUgYXBwbGllZCBhdXRvbWF0aWNhbGx5IG9uY2UgbG9hZGluZ1xuXHRcdC8vIGZpbmlzaGVzXG5cdFx0aWYoIGxvYWRlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgbnVtYmVyT2ZTbGlkZXMgPSBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBTTElERVNfU0VMRUNUT1IgKS5sZW5ndGg7XG5cblx0XHQvLyBSZW1vdmUgdGhlIHByZXZpb3VzbHkgY29uZmlndXJlZCB0cmFuc2l0aW9uIGNsYXNzXG5cdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSggb2xkVHJhbnNpdGlvbiApO1xuXG5cdFx0Ly8gRm9yY2UgbGluZWFyIHRyYW5zaXRpb24gYmFzZWQgb24gYnJvd3NlciBjYXBhYmlsaXRpZXNcblx0XHRpZiggZmVhdHVyZXMudHJhbnNmb3JtczNkID09PSBmYWxzZSApIGNvbmZpZy50cmFuc2l0aW9uID0gJ2xpbmVhcic7XG5cblx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCBjb25maWcudHJhbnNpdGlvbiApO1xuXG5cdFx0ZG9tLndyYXBwZXIuc2V0QXR0cmlidXRlKCAnZGF0YS10cmFuc2l0aW9uLXNwZWVkJywgY29uZmlnLnRyYW5zaXRpb25TcGVlZCApO1xuXHRcdGRvbS53cmFwcGVyLnNldEF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC10cmFuc2l0aW9uJywgY29uZmlnLmJhY2tncm91bmRUcmFuc2l0aW9uICk7XG5cblx0XHRkb20uY29udHJvbHMuc3R5bGUuZGlzcGxheSA9IGNvbmZpZy5jb250cm9scyA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0ZG9tLnByb2dyZXNzLnN0eWxlLmRpc3BsYXkgPSBjb25maWcucHJvZ3Jlc3MgPyAnYmxvY2snIDogJ25vbmUnO1xuXG5cdFx0ZG9tLmNvbnRyb2xzLnNldEF0dHJpYnV0ZSggJ2RhdGEtY29udHJvbHMtbGF5b3V0JywgY29uZmlnLmNvbnRyb2xzTGF5b3V0ICk7XG5cdFx0ZG9tLmNvbnRyb2xzLnNldEF0dHJpYnV0ZSggJ2RhdGEtY29udHJvbHMtYmFjay1hcnJvd3MnLCBjb25maWcuY29udHJvbHNCYWNrQXJyb3dzICk7XG5cblx0XHRpZiggY29uZmlnLnNodWZmbGUgKSB7XG5cdFx0XHRzaHVmZmxlKCk7XG5cdFx0fVxuXG5cdFx0aWYoIGNvbmZpZy5ydGwgKSB7XG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAncnRsJyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoICdydGwnICk7XG5cdFx0fVxuXG5cdFx0aWYoIGNvbmZpZy5jZW50ZXIgKSB7XG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnY2VudGVyJyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoICdjZW50ZXInICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXhpdCB0aGUgcGF1c2VkIG1vZGUgaWYgaXQgd2FzIGNvbmZpZ3VyZWQgb2ZmXG5cdFx0aWYoIGNvbmZpZy5wYXVzZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXN1bWUoKTtcblx0XHR9XG5cblx0XHRpZiggY29uZmlnLnNob3dOb3RlcyApIHtcblx0XHRcdGRvbS5zcGVha2VyTm90ZXMuc2V0QXR0cmlidXRlKCAnZGF0YS1sYXlvdXQnLCB0eXBlb2YgY29uZmlnLnNob3dOb3RlcyA9PT0gJ3N0cmluZycgPyBjb25maWcuc2hvd05vdGVzIDogJ2lubGluZScgKTtcblx0XHR9XG5cblx0XHRpZiggY29uZmlnLm1vdXNlV2hlZWwgKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbkRvY3VtZW50TW91c2VTY3JvbGwsIGZhbHNlICk7IC8vIEZGXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V3aGVlbCcsIG9uRG9jdW1lbnRNb3VzZVNjcm9sbCwgZmFsc2UgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbkRvY3VtZW50TW91c2VTY3JvbGwsIGZhbHNlICk7IC8vIEZGXG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V3aGVlbCcsIG9uRG9jdW1lbnRNb3VzZVNjcm9sbCwgZmFsc2UgKTtcblx0XHR9XG5cblx0XHQvLyBSb2xsaW5nIDNEIGxpbmtzXG5cdFx0aWYoIGNvbmZpZy5yb2xsaW5nTGlua3MgKSB7XG5cdFx0XHRlbmFibGVSb2xsaW5nTGlua3MoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkaXNhYmxlUm9sbGluZ0xpbmtzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWZyYW1lIGxpbmsgcHJldmlld3Ncblx0XHRpZiggY29uZmlnLnByZXZpZXdMaW5rcyApIHtcblx0XHRcdGVuYWJsZVByZXZpZXdMaW5rcygpO1xuXHRcdFx0ZGlzYWJsZVByZXZpZXdMaW5rcyggJ1tkYXRhLXByZXZpZXctbGluaz1mYWxzZV0nICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZGlzYWJsZVByZXZpZXdMaW5rcygpO1xuXHRcdFx0ZW5hYmxlUHJldmlld0xpbmtzKCAnW2RhdGEtcHJldmlldy1saW5rXTpub3QoW2RhdGEtcHJldmlldy1saW5rPWZhbHNlXSknICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGV4aXN0aW5nIGF1dG8tc2xpZGUgY29udHJvbHNcblx0XHRpZiggYXV0b1NsaWRlUGxheWVyICkge1xuXHRcdFx0YXV0b1NsaWRlUGxheWVyLmRlc3Ryb3koKTtcblx0XHRcdGF1dG9TbGlkZVBsYXllciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gR2VuZXJhdGUgYXV0by1zbGlkZSBjb250cm9scyBpZiBuZWVkZWRcblx0XHRpZiggbnVtYmVyT2ZTbGlkZXMgPiAxICYmIGNvbmZpZy5hdXRvU2xpZGUgJiYgY29uZmlnLmF1dG9TbGlkZVN0b3BwYWJsZSAmJiBmZWF0dXJlcy5jYW52YXMgJiYgZmVhdHVyZXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0YXV0b1NsaWRlUGxheWVyID0gbmV3IFBsYXliYWNrKCBkb20ud3JhcHBlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoICggRGF0ZS5ub3coKSAtIGF1dG9TbGlkZVN0YXJ0VGltZSApIC8gYXV0b1NsaWRlLCAwICksIDEgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0YXV0b1NsaWRlUGxheWVyLm9uKCAnY2xpY2snLCBvbkF1dG9TbGlkZVBsYXllckNsaWNrICk7XG5cdFx0XHRhdXRvU2xpZGVQYXVzZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIGZyYWdtZW50cyBhcmUgdHVybmVkIG9mZiB0aGV5IHNob3VsZCBiZSB2aXNpYmxlXG5cdFx0aWYoIGNvbmZpZy5mcmFnbWVudHMgPT09IGZhbHNlICkge1xuXHRcdFx0dG9BcnJheSggZG9tLnNsaWRlcy5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApICkuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3Zpc2libGUnICk7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2xpZGUgbnVtYmVyc1xuXHRcdHZhciBzbGlkZU51bWJlckRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0aWYoIGNvbmZpZy5zbGlkZU51bWJlciAmJiAhaXNQcmludGluZ1BERigpICkge1xuXHRcdFx0aWYoIGNvbmZpZy5zaG93U2xpZGVOdW1iZXIgPT09ICdhbGwnICkge1xuXHRcdFx0XHRzbGlkZU51bWJlckRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiggY29uZmlnLnNob3dTbGlkZU51bWJlciA9PT0gJ3NwZWFrZXInICYmIGlzU3BlYWtlck5vdGVzKCkgKSB7XG5cdFx0XHRcdHNsaWRlTnVtYmVyRGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZG9tLnNsaWRlTnVtYmVyLnN0eWxlLmRpc3BsYXkgPSBzbGlkZU51bWJlckRpc3BsYXk7XG5cblx0XHRzeW5jKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG5cblx0XHRldmVudHNBcmVCb3VuZCA9IHRydWU7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2hhc2hjaGFuZ2UnLCBvbldpbmRvd0hhc2hDaGFuZ2UsIGZhbHNlICk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSwgZmFsc2UgKTtcblxuXHRcdGlmKCBjb25maWcudG91Y2ggKSB7XG5cdFx0XHRpZiggJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdyApIHtcblx0XHRcdFx0Ly8gVXNlIFczQyBwb2ludGVyIGV2ZW50c1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCBmYWxzZSApO1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgKSB7XG5cdFx0XHRcdC8vIElFIDEwIHVzZXMgcHJlZml4ZWQgdmVyc2lvbiBvZiBwb2ludGVyIGV2ZW50c1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyRG93bicsIG9uUG9pbnRlckRvd24sIGZhbHNlICk7XG5cdFx0XHRcdGRvbS53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJNb3ZlJywgb25Qb2ludGVyTW92ZSwgZmFsc2UgKTtcblx0XHRcdFx0ZG9tLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlclVwJywgb25Qb2ludGVyVXAsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gRmFsbCBiYWNrIHRvIHRvdWNoIGV2ZW50c1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0XHRcdFx0ZG9tLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb20ud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKCBjb25maWcua2V5Ym9hcmQgKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uRG9jdW1lbnRLZXlEb3duLCBmYWxzZSApO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXByZXNzJywgb25Eb2N1bWVudEtleVByZXNzLCBmYWxzZSApO1xuXHRcdH1cblxuXHRcdGlmKCBjb25maWcucHJvZ3Jlc3MgJiYgZG9tLnByb2dyZXNzICkge1xuXHRcdFx0ZG9tLnByb2dyZXNzLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIG9uUHJvZ3Jlc3NDbGlja2VkLCBmYWxzZSApO1xuXHRcdH1cblxuXHRcdGRvbS5yZXN1bWVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgcmVzdW1lLCBmYWxzZSApO1xuXG5cdFx0aWYoIGNvbmZpZy5mb2N1c0JvZHlPblBhZ2VWaXNpYmlsaXR5Q2hhbmdlICkge1xuXHRcdFx0dmFyIHZpc2liaWxpdHlDaGFuZ2U7XG5cblx0XHRcdGlmKCAnaGlkZGVuJyBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0dmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoICdtc0hpZGRlbicgaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoICd3ZWJraXRIaWRkZW4nIGluIGRvY3VtZW50ICkge1xuXHRcdFx0XHR2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggdmlzaWJpbGl0eUNoYW5nZSApIHtcblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdmlzaWJpbGl0eUNoYW5nZSwgb25QYWdlVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMaXN0ZW4gdG8gYm90aCB0b3VjaCBhbmQgY2xpY2sgZXZlbnRzLCBpbiBjYXNlIHRoZSBkZXZpY2Vcblx0XHQvLyBzdXBwb3J0cyBib3RoXG5cdFx0dmFyIHBvaW50ZXJFdmVudHMgPSBbICd0b3VjaHN0YXJ0JywgJ2NsaWNrJyBdO1xuXG5cdFx0Ly8gT25seSBzdXBwb3J0IHRvdWNoIGZvciBBbmRyb2lkLCBmaXhlcyBkb3VibGUgbmF2aWdhdGlvbnMgaW5cblx0XHQvLyBzdG9jayBicm93c2VyXG5cdFx0aWYoIFVBLm1hdGNoKCAvYW5kcm9pZC9naSApICkge1xuXHRcdFx0cG9pbnRlckV2ZW50cyA9IFsgJ3RvdWNoc3RhcnQnIF07XG5cdFx0fVxuXG5cdFx0cG9pbnRlckV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0ZG9tLmNvbnRyb2xzTGVmdC5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgb25OYXZpZ2F0ZUxlZnRDbGlja2VkLCBmYWxzZSApOyB9ICk7XG5cdFx0XHRkb20uY29udHJvbHNSaWdodC5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgb25OYXZpZ2F0ZVJpZ2h0Q2xpY2tlZCwgZmFsc2UgKTsgfSApO1xuXHRcdFx0ZG9tLmNvbnRyb2xzVXAuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIG9uTmF2aWdhdGVVcENsaWNrZWQsIGZhbHNlICk7IH0gKTtcblx0XHRcdGRvbS5jb250cm9sc0Rvd24uZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIG9uTmF2aWdhdGVEb3duQ2xpY2tlZCwgZmFsc2UgKTsgfSApO1xuXHRcdFx0ZG9tLmNvbnRyb2xzUHJldi5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgb25OYXZpZ2F0ZVByZXZDbGlja2VkLCBmYWxzZSApOyB9ICk7XG5cdFx0XHRkb20uY29udHJvbHNOZXh0LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBvbk5hdmlnYXRlTmV4dENsaWNrZWQsIGZhbHNlICk7IH0gKTtcblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmRzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcblxuXHRcdGV2ZW50c0FyZUJvdW5kID0gZmFsc2U7XG5cblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uRG9jdW1lbnRLZXlEb3duLCBmYWxzZSApO1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlwcmVzcycsIG9uRG9jdW1lbnRLZXlQcmVzcywgZmFsc2UgKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2hhc2hjaGFuZ2UnLCBvbldpbmRvd0hhc2hDaGFuZ2UsIGZhbHNlICk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSwgZmFsc2UgKTtcblxuXHRcdGRvbS53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIGZhbHNlICk7XG5cdFx0ZG9tLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSwgZmFsc2UgKTtcblx0XHRkb20ud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIGZhbHNlICk7XG5cblx0XHRkb20ud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCAnTVNQb2ludGVyRG93bicsIG9uUG9pbnRlckRvd24sIGZhbHNlICk7XG5cdFx0ZG9tLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ01TUG9pbnRlck1vdmUnLCBvblBvaW50ZXJNb3ZlLCBmYWxzZSApO1xuXHRcdGRvbS53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdNU1BvaW50ZXJVcCcsIG9uUG9pbnRlclVwLCBmYWxzZSApO1xuXG5cdFx0ZG9tLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlICk7XG5cdFx0ZG9tLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXHRcdGRvbS53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlICk7XG5cblx0XHRkb20ucmVzdW1lQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIHJlc3VtZSwgZmFsc2UgKTtcblxuXHRcdGlmICggY29uZmlnLnByb2dyZXNzICYmIGRvbS5wcm9ncmVzcyApIHtcblx0XHRcdGRvbS5wcm9ncmVzcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBvblByb2dyZXNzQ2xpY2tlZCwgZmFsc2UgKTtcblx0XHR9XG5cblx0XHRbICd0b3VjaHN0YXJ0JywgJ2NsaWNrJyBdLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG5cdFx0XHRkb20uY29udHJvbHNMZWZ0LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBvbk5hdmlnYXRlTGVmdENsaWNrZWQsIGZhbHNlICk7IH0gKTtcblx0XHRcdGRvbS5jb250cm9sc1JpZ2h0LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBvbk5hdmlnYXRlUmlnaHRDbGlja2VkLCBmYWxzZSApOyB9ICk7XG5cdFx0XHRkb20uY29udHJvbHNVcC5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgb25OYXZpZ2F0ZVVwQ2xpY2tlZCwgZmFsc2UgKTsgfSApO1xuXHRcdFx0ZG9tLmNvbnRyb2xzRG93bi5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgb25OYXZpZ2F0ZURvd25DbGlja2VkLCBmYWxzZSApOyB9ICk7XG5cdFx0XHRkb20uY29udHJvbHNQcmV2LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBvbk5hdmlnYXRlUHJldkNsaWNrZWQsIGZhbHNlICk7IH0gKTtcblx0XHRcdGRvbS5jb250cm9sc05leHQuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIG9uTmF2aWdhdGVOZXh0Q2xpY2tlZCwgZmFsc2UgKTsgfSApO1xuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIGN1c3RvbSBrZXkgYmluZGluZyB3aXRoIG9wdGlvbmFsIGRlc2NyaXB0aW9uIHRvXG5cdCAqIGJlIGFkZGVkIHRvIHRoZSBoZWxwIHNjcmVlbi5cblx0ICovXG5cdGZ1bmN0aW9uIGFkZEtleUJpbmRpbmcoIGJpbmRpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0aWYoIHR5cGVvZiBiaW5kaW5nID09PSAnb2JqZWN0JyAmJiBiaW5kaW5nLmtleUNvZGUgKSB7XG5cdFx0XHRyZWdpc3RlcmVkS2V5QmluZGluZ3NbYmluZGluZy5rZXlDb2RlXSA9IHtcblx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0XHRrZXk6IGJpbmRpbmcua2V5LFxuXHRcdFx0XHRkZXNjcmlwdGlvbjogYmluZGluZy5kZXNjcmlwdGlvblxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZWdpc3RlcmVkS2V5QmluZGluZ3NbYmluZGluZ10gPSB7XG5cdFx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdFx0a2V5OiBudWxsLFxuXHRcdFx0XHRkZXNjcmlwdGlvbjogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY3VzdG9tIGtleSBiaW5kaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlS2V5QmluZGluZygga2V5Q29kZSApIHtcblxuXHRcdGRlbGV0ZSByZWdpc3RlcmVkS2V5QmluZGluZ3Nba2V5Q29kZV07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cblx0ICogSWYgdGhlcmUncyBhIGNvbmZsaWN0LCBvYmplY3QgYiB0YWtlcyBwcmVjZWRlbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYVxuXHQgKiBAcGFyYW0ge29iamVjdH0gYlxuXHQgKi9cblx0ZnVuY3Rpb24gZXh0ZW5kKCBhLCBiICkge1xuXG5cdFx0Zm9yKCB2YXIgaSBpbiBiICkge1xuXHRcdFx0YVsgaSBdID0gYlsgaSBdO1xuXHRcdH1cblxuXHRcdHJldHVybiBhO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIHRhcmdldCBvYmplY3QgdG8gYW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BcnJheSggbyApIHtcblxuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggbyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXRpbGl0eSBmb3IgZGVzZXJpYWxpemluZyBhIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZSggdmFsdWUgKSB7XG5cblx0XHRpZiggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdGlmKCB2YWx1ZSA9PT0gJ251bGwnICkgcmV0dXJuIG51bGw7XG5cdFx0XHRlbHNlIGlmKCB2YWx1ZSA9PT0gJ3RydWUnICkgcmV0dXJuIHRydWU7XG5cdFx0XHRlbHNlIGlmKCB2YWx1ZSA9PT0gJ2ZhbHNlJyApIHJldHVybiBmYWxzZTtcblx0XHRcdGVsc2UgaWYoIHZhbHVlLm1hdGNoKCAvXi0/W1xcZFxcLl0rJC8gKSApIHJldHVybiBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1lYXN1cmVzIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgYmV0d2VlbiBwb2ludCBhXG5cdCAqIGFuZCBwb2ludCBiLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYSBwb2ludCB3aXRoIHgveSBwcm9wZXJ0aWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBiIHBvaW50IHdpdGggeC95IHByb3BlcnRpZXNcblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuKCBhLCBiICkge1xuXG5cdFx0dmFyIGR4ID0gYS54IC0gYi54LFxuXHRcdFx0ZHkgPSBhLnkgLSBiLnk7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgQ1NTIHRyYW5zZm9ybSB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNmb3JtRWxlbWVudCggZWxlbWVudCwgdHJhbnNmb3JtICkge1xuXG5cdFx0ZWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdFx0ZWxlbWVudC5zdHlsZS5Nb3pUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdFx0ZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0XHRlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgQ1NTIHRyYW5zZm9ybXMgdG8gdGhlIHNsaWRlcyBjb250YWluZXIuIFRoZSBjb250YWluZXJcblx0ICogaXMgdHJhbnNmb3JtZWQgZnJvbSB0d28gc2VwYXJhdGUgc291cmNlczogbGF5b3V0IGFuZCB0aGUgb3ZlcnZpZXdcblx0ICogbW9kZS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybXNcblx0ICovXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVNsaWRlcyggdHJhbnNmb3JtcyApIHtcblxuXHRcdC8vIFBpY2sgdXAgbmV3IHRyYW5zZm9ybXMgZnJvbSBhcmd1bWVudHNcblx0XHRpZiggdHlwZW9mIHRyYW5zZm9ybXMubGF5b3V0ID09PSAnc3RyaW5nJyApIHNsaWRlc1RyYW5zZm9ybS5sYXlvdXQgPSB0cmFuc2Zvcm1zLmxheW91dDtcblx0XHRpZiggdHlwZW9mIHRyYW5zZm9ybXMub3ZlcnZpZXcgPT09ICdzdHJpbmcnICkgc2xpZGVzVHJhbnNmb3JtLm92ZXJ2aWV3ID0gdHJhbnNmb3Jtcy5vdmVydmlldztcblxuXHRcdC8vIEFwcGx5IHRoZSB0cmFuc2Zvcm1zIHRvIHRoZSBzbGlkZXMgY29udGFpbmVyXG5cdFx0aWYoIHNsaWRlc1RyYW5zZm9ybS5sYXlvdXQgKSB7XG5cdFx0XHR0cmFuc2Zvcm1FbGVtZW50KCBkb20uc2xpZGVzLCBzbGlkZXNUcmFuc2Zvcm0ubGF5b3V0ICsgJyAnICsgc2xpZGVzVHJhbnNmb3JtLm92ZXJ2aWV3ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dHJhbnNmb3JtRWxlbWVudCggZG9tLnNsaWRlcywgc2xpZGVzVHJhbnNmb3JtLm92ZXJ2aWV3ICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogSW5qZWN0cyB0aGUgZ2l2ZW4gQ1NTIHN0eWxlcyBpbnRvIHRoZSBET00uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5qZWN0U3R5bGVTaGVldCggdmFsdWUgKSB7XG5cblx0XHR2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRcdHRhZy50eXBlID0gJ3RleHQvY3NzJztcblx0XHRpZiggdGFnLnN0eWxlU2hlZXQgKSB7XG5cdFx0XHR0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGFnLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKSApO1xuXHRcdH1cblx0XHRkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2hlYWQnIClbMF0uYXBwZW5kQ2hpbGQoIHRhZyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRmluZCB0aGUgY2xvc2VzdCBwYXJlbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlblxuXHQgKiBzZWxlY3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFRoZSBjaGlsZCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBUaGUgQ1NTIHNlbGVjdG9yIHRvIG1hdGNoXG5cdCAqIHRoZSBwYXJlbnRzIGFnYWluc3Rcblx0ICpcblx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBtYXRjaGVkIHBhcmVudCBvciBudWxsXG5cdCAqIGlmIG5vIG1hdGNoaW5nIHBhcmVudCB3YXMgZm91bmRcblx0ICovXG5cdGZ1bmN0aW9uIGNsb3Nlc3RQYXJlbnQoIHRhcmdldCwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cblx0XHR3aGlsZSggcGFyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIHNvbWUgb3ZlcmhlYWQgZG9pbmcgdGhpcyBlYWNoIHRpbWUsIHdlIGRvbid0XG5cdFx0XHQvLyB3YW50IHRvIHJld3JpdGUgdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJ1dCBzaG91bGQgc3RpbGxcblx0XHRcdC8vIGJlIGVub3VnaCB0byBmZWF0dXJlIGRldGVjdCBvbmNlIGF0IHN0YXJ0dXAuLi5cblx0XHRcdHZhciBtYXRjaGVzTWV0aG9kID0gcGFyZW50Lm1hdGNoZXMgfHwgcGFyZW50Lm1hdGNoZXNTZWxlY3RvciB8fCBwYXJlbnQubXNNYXRjaGVzU2VsZWN0b3I7XG5cblx0XHRcdC8vIElmIHdlIGZpbmQgYSBtYXRjaCwgd2UncmUgYWxsIHNldFxuXHRcdFx0aWYoIG1hdGNoZXNNZXRob2QgJiYgbWF0Y2hlc01ldGhvZC5jYWxsKCBwYXJlbnQsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgc2VhcmNoaW5nXG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdmFyaW91cyBjb2xvciBpbnB1dCBmb3JtYXRzIHRvIGFuIHtyOjAsZzowLGI6MH0gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yXG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbG9yVG9SZ2IoJyMwMDAnKTtcblx0ICogQGV4YW1wbGVcblx0ICogY29sb3JUb1JnYignIzAwMDAwMCcpO1xuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb2xvclRvUmdiKCdyZ2IoMCwwLDApJyk7XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbG9yVG9SZ2IoJ3JnYmEoMCwwLDApJyk7XG5cdCAqXG5cdCAqIEByZXR1cm4ge3tyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyLCBbYV06IG51bWJlcn18bnVsbH1cblx0ICovXG5cdGZ1bmN0aW9uIGNvbG9yVG9SZ2IoIGNvbG9yICkge1xuXG5cdFx0dmFyIGhleDMgPSBjb2xvci5tYXRjaCggL14jKFswLTlhLWZdezN9KSQvaSApO1xuXHRcdGlmKCBoZXgzICYmIGhleDNbMV0gKSB7XG5cdFx0XHRoZXgzID0gaGV4M1sxXTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IHBhcnNlSW50KCBoZXgzLmNoYXJBdCggMCApLCAxNiApICogMHgxMSxcblx0XHRcdFx0ZzogcGFyc2VJbnQoIGhleDMuY2hhckF0KCAxICksIDE2ICkgKiAweDExLFxuXHRcdFx0XHRiOiBwYXJzZUludCggaGV4My5jaGFyQXQoIDIgKSwgMTYgKSAqIDB4MTFcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGhleDYgPSBjb2xvci5tYXRjaCggL14jKFswLTlhLWZdezZ9KSQvaSApO1xuXHRcdGlmKCBoZXg2ICYmIGhleDZbMV0gKSB7XG5cdFx0XHRoZXg2ID0gaGV4NlsxXTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IHBhcnNlSW50KCBoZXg2LnN1YnN0ciggMCwgMiApLCAxNiApLFxuXHRcdFx0XHRnOiBwYXJzZUludCggaGV4Ni5zdWJzdHIoIDIsIDIgKSwgMTYgKSxcblx0XHRcdFx0YjogcGFyc2VJbnQoIGhleDYuc3Vic3RyKCA0LCAyICksIDE2IClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIHJnYiA9IGNvbG9yLm1hdGNoKCAvXnJnYlxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvaSApO1xuXHRcdGlmKCByZ2IgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyOiBwYXJzZUludCggcmdiWzFdLCAxMCApLFxuXHRcdFx0XHRnOiBwYXJzZUludCggcmdiWzJdLCAxMCApLFxuXHRcdFx0XHRiOiBwYXJzZUludCggcmdiWzNdLCAxMCApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciByZ2JhID0gY29sb3IubWF0Y2goIC9ecmdiYVxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcLFxccyooW1xcZF0rfFtcXGRdKi5bXFxkXSspXFxzKlxcKSQvaSApO1xuXHRcdGlmKCByZ2JhICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cjogcGFyc2VJbnQoIHJnYmFbMV0sIDEwICksXG5cdFx0XHRcdGc6IHBhcnNlSW50KCByZ2JhWzJdLCAxMCApLFxuXHRcdFx0XHRiOiBwYXJzZUludCggcmdiYVszXSwgMTAgKSxcblx0XHRcdFx0YTogcGFyc2VGbG9hdCggcmdiYVs0XSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBicmlnaHRuZXNzIG9uIGEgc2NhbGUgb2YgMC0yNTUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBTZWUgY29sb3JUb1JnYiBmb3Igc3VwcG9ydGVkIGZvcm1hdHMuXG5cdCAqIEBzZWUge0BsaW5rIGNvbG9yVG9SZ2J9XG5cdCAqL1xuXHRmdW5jdGlvbiBjb2xvckJyaWdodG5lc3MoIGNvbG9yICkge1xuXG5cdFx0aWYoIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgKSBjb2xvciA9IGNvbG9yVG9SZ2IoIGNvbG9yICk7XG5cblx0XHRpZiggY29sb3IgKSB7XG5cdFx0XHRyZXR1cm4gKCBjb2xvci5yICogMjk5ICsgY29sb3IuZyAqIDU4NyArIGNvbG9yLmIgKiAxMTQgKSAvIDEwMDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZW1haW5pbmcgaGVpZ2h0IHdpdGhpbiB0aGUgcGFyZW50IG9mIHRoZVxuXHQgKiB0YXJnZXQgZWxlbWVudC5cblx0ICpcblx0ICogcmVtYWluaW5nIGhlaWdodCA9IFsgY29uZmlndXJlZCBwYXJlbnQgaGVpZ2h0IF0gLSBbIGN1cnJlbnQgcGFyZW50IGhlaWdodCBdXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSZW1haW5pbmdIZWlnaHQoIGVsZW1lbnQsIGhlaWdodCApIHtcblxuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAwO1xuXG5cdFx0aWYoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmV3SGVpZ2h0LCBvbGRIZWlnaHQgPSBlbGVtZW50LnN0eWxlLmhlaWdodDtcblxuXHRcdFx0Ly8gQ2hhbmdlIHRoZSAuc3RyZXRjaCBlbGVtZW50IGhlaWdodCB0byAwIGluIG9yZGVyIGZpbmQgdGhlIGhlaWdodCBvZiBhbGxcblx0XHRcdC8vIHRoZSBvdGhlciBlbGVtZW50c1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMHB4Jztcblx0XHRcdG5ld0hlaWdodCA9IGhlaWdodCAtIGVsZW1lbnQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIG9sZCBoZWlnaHQsIGp1c3QgaW4gY2FzZVxuXHRcdFx0ZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBvbGRIZWlnaHQgKyAncHgnO1xuXG5cdFx0XHRyZXR1cm4gbmV3SGVpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBoZWlnaHQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBpcyBiZWluZyB1c2VkIHRvIHByaW50IGEgUERGLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNQcmludGluZ1BERigpIHtcblxuXHRcdHJldHVybiAoIC9wcmludC1wZGYvZ2kgKS50ZXN0KCB3aW5kb3cubG9jYXRpb24uc2VhcmNoICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGlzIGluc3RhbmNlIGlzIGJlaW5nIHVzZWQgdG8gcHJpbnQgYSBQREYgd2l0aCBmcmFnbWVudHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1ByaW50aW5nUERGRnJhZ21lbnRzKCkge1xuXG5cdFx0cmV0dXJuICggL3ByaW50LXBkZi1mcmFnbWVudHMvZ2kgKS50ZXN0KCB3aW5kb3cubG9jYXRpb24uc2VhcmNoICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIaWRlcyB0aGUgYWRkcmVzcyBiYXIgaWYgd2UncmUgb24gYSBtb2JpbGUgZGV2aWNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGlkZUFkZHJlc3NCYXIoKSB7XG5cblx0XHRpZiggY29uZmlnLmhpZGVBZGRyZXNzQmFyICYmIGlzTW9iaWxlRGV2aWNlICkge1xuXHRcdFx0Ly8gRXZlbnRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGFkZHJlc3MgYmFyIHRvIGhpZGVcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHJlbW92ZUFkZHJlc3NCYXIsIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ29yaWVudGF0aW9uY2hhbmdlJywgcmVtb3ZlQWRkcmVzc0JhciwgZmFsc2UgKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFkZHJlc3MgYmFyIHRvIGhpZGUgb24gbW9iaWxlIGRldmljZXMsXG5cdCAqIG1vcmUgdmVydGljYWwgc3BhY2UgZnR3LlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlQWRkcmVzc0JhcigpIHtcblxuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LnNjcm9sbFRvKCAwLCAxICk7XG5cdFx0fSwgMTAgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGZyb20gdGhlXG5cdCAqIHJldmVhbCBET00gZWxlbWVudC5cblx0ICovXG5cdGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoIHR5cGUsIGFyZ3MgKSB7XG5cblx0XHR2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCggJ0hUTUxFdmVudHMnLCAxLCAyICk7XG5cdFx0ZXZlbnQuaW5pdEV2ZW50KCB0eXBlLCB0cnVlLCB0cnVlICk7XG5cdFx0ZXh0ZW5kKCBldmVudCwgYXJncyApO1xuXHRcdGRvbS53cmFwcGVyLmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG5cblx0XHQvLyBJZiB3ZSdyZSBpbiBhbiBpZnJhbWUsIHBvc3QgZWFjaCByZXZlYWwuanMgZXZlbnQgdG8gdGhlXG5cdFx0Ly8gcGFyZW50IHdpbmRvdy4gVXNlZCBieSB0aGUgbm90ZXMgcGx1Z2luXG5cdFx0aWYoIGNvbmZpZy5wb3N0TWVzc2FnZUV2ZW50cyAmJiB3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cuc2VsZiApIHtcblx0XHRcdHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoIEpTT04uc3RyaW5naWZ5KHsgbmFtZXNwYWNlOiAncmV2ZWFsJywgZXZlbnROYW1lOiB0eXBlLCBzdGF0ZTogZ2V0U3RhdGUoKSB9KSwgJyonICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogV3JhcCBhbGwgbGlua3MgaW4gM0QgZ29vZG5lc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmFibGVSb2xsaW5nTGlua3MoKSB7XG5cblx0XHRpZiggZmVhdHVyZXMudHJhbnNmb3JtczNkICYmICEoICdtc1BlcnNwZWN0aXZlJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlICkgKSB7XG5cdFx0XHR2YXIgYW5jaG9ycyA9IGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFNMSURFU19TRUxFQ1RPUiArICcgYScgKTtcblxuXHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBhbmNob3JzW2ldO1xuXG5cdFx0XHRcdGlmKCBhbmNob3IudGV4dENvbnRlbnQgJiYgIWFuY2hvci5xdWVyeVNlbGVjdG9yKCAnKicgKSAmJiAoICFhbmNob3IuY2xhc3NOYW1lIHx8ICFhbmNob3IuY2xhc3NMaXN0LmNvbnRhaW5zKCBhbmNob3IsICdyb2xsJyApICkgKSB7XG5cdFx0XHRcdFx0dmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cdFx0XHRcdFx0c3Bhbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnLCBhbmNob3IudGV4dCk7XG5cdFx0XHRcdFx0c3Bhbi5pbm5lckhUTUwgPSBhbmNob3IuaW5uZXJIVE1MO1xuXG5cdFx0XHRcdFx0YW5jaG9yLmNsYXNzTGlzdC5hZGQoICdyb2xsJyApO1xuXHRcdFx0XHRcdGFuY2hvci5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0XHRhbmNob3IuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVbndyYXAgYWxsIDNEIGxpbmtzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlzYWJsZVJvbGxpbmdMaW5rcygpIHtcblxuXHRcdHZhciBhbmNob3JzID0gZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggU0xJREVTX1NFTEVDVE9SICsgJyBhLnJvbGwnICk7XG5cblx0XHRmb3IoIHZhciBpID0gMCwgbGVuID0gYW5jaG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHZhciBhbmNob3IgPSBhbmNob3JzW2ldO1xuXHRcdFx0dmFyIHNwYW4gPSBhbmNob3IucXVlcnlTZWxlY3RvciggJ3NwYW4nICk7XG5cblx0XHRcdGlmKCBzcGFuICkge1xuXHRcdFx0XHRhbmNob3IuY2xhc3NMaXN0LnJlbW92ZSggJ3JvbGwnICk7XG5cdFx0XHRcdGFuY2hvci5pbm5lckhUTUwgPSBzcGFuLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIHByZXZpZXcgZnJhbWUgbGlua3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2VsZWN0b3I9YV0gLSBzZWxlY3RvciBmb3IgYW5jaG9yc1xuXHQgKi9cblx0ZnVuY3Rpb24gZW5hYmxlUHJldmlld0xpbmtzKCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBhbmNob3JzID0gdG9BcnJheSggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgPyBzZWxlY3RvciA6ICdhJyApICk7XG5cblx0XHRhbmNob3JzLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0aWYoIC9eKGh0dHB8d3d3KS9naS50ZXN0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2hyZWYnICkgKSApIHtcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBvblByZXZpZXdMaW5rQ2xpY2tlZCwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmQgcHJldmlldyBmcmFtZSBsaW5rcy5cblx0ICovXG5cdGZ1bmN0aW9uIGRpc2FibGVQcmV2aWV3TGlua3MoIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGFuY2hvcnMgPSB0b0FycmF5KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciA/IHNlbGVjdG9yIDogJ2EnICkgKTtcblxuXHRcdGFuY2hvcnMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRpZiggL14oaHR0cHx3d3cpL2dpLnRlc3QoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaHJlZicgKSApICkge1xuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIG9uUHJldmlld0xpbmtDbGlja2VkLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW5zIGEgcHJldmlldyB3aW5kb3cgZm9yIHRoZSB0YXJnZXQgVVJMLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdXJsIGZvciBwcmV2aWV3IGlmcmFtZSBzcmNcblx0ICovXG5cdGZ1bmN0aW9uIHNob3dQcmV2aWV3KCB1cmwgKSB7XG5cblx0XHRjbG9zZU92ZXJsYXkoKTtcblxuXHRcdGRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHRkb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKCAnb3ZlcmxheScgKTtcblx0XHRkb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKCAnb3ZlcmxheS1wcmV2aWV3JyApO1xuXHRcdGRvbS53cmFwcGVyLmFwcGVuZENoaWxkKCBkb20ub3ZlcmxheSApO1xuXG5cdFx0ZG9tLm92ZXJsYXkuaW5uZXJIVE1MID0gW1xuXHRcdFx0JzxoZWFkZXI+Jyxcblx0XHRcdFx0JzxhIGNsYXNzPVwiY2xvc2VcIiBocmVmPVwiI1wiPjxzcGFuIGNsYXNzPVwiaWNvblwiPjwvc3Bhbj48L2E+Jyxcblx0XHRcdFx0JzxhIGNsYXNzPVwiZXh0ZXJuYWxcIiBocmVmPVwiJysgdXJsICsnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PHNwYW4gY2xhc3M9XCJpY29uXCI+PC9zcGFuPjwvYT4nLFxuXHRcdFx0JzwvaGVhZGVyPicsXG5cdFx0XHQnPGRpdiBjbGFzcz1cInNwaW5uZXJcIj48L2Rpdj4nLFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJ2aWV3cG9ydFwiPicsXG5cdFx0XHRcdCc8aWZyYW1lIHNyYz1cIicrIHVybCArJ1wiPjwvaWZyYW1lPicsXG5cdFx0XHRcdCc8c21hbGwgY2xhc3M9XCJ2aWV3cG9ydC1pbm5lclwiPicsXG5cdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwieC1mcmFtZS1lcnJvclwiPlVuYWJsZSB0byBsb2FkIGlmcmFtZS4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIHRoZSBzaXRlXFwncyBwb2xpY3kgKHgtZnJhbWUtb3B0aW9ucykuPC9zcGFuPicsXG5cdFx0XHRcdCc8L3NtYWxsPicsXG5cdFx0XHQnPC9kaXY+J1xuXHRcdF0uam9pbignJyk7XG5cblx0XHRkb20ub3ZlcmxheS5xdWVyeVNlbGVjdG9yKCAnaWZyYW1lJyApLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0ZG9tLm92ZXJsYXkuY2xhc3NMaXN0LmFkZCggJ2xvYWRlZCcgKTtcblx0XHR9LCBmYWxzZSApO1xuXG5cdFx0ZG9tLm92ZXJsYXkucXVlcnlTZWxlY3RvciggJy5jbG9zZScgKS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRjbG9zZU92ZXJsYXkoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdGRvbS5vdmVybGF5LnF1ZXJ5U2VsZWN0b3IoICcuZXh0ZXJuYWwnICkuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Y2xvc2VPdmVybGF5KCk7XG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZG9tLm92ZXJsYXkuY2xhc3NMaXN0LmFkZCggJ3Zpc2libGUnICk7XG5cdFx0fSwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogT3BlbiBvciBjbG9zZSBoZWxwIG92ZXJsYXkgd2luZG93LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvdmVycmlkZV0gRmxhZyB3aGljaCBvdmVycmlkZXMgdGhlXG5cdCAqIHRvZ2dsZSBsb2dpYyBhbmQgZm9yY2libHkgc2V0cyB0aGUgZGVzaXJlZCBzdGF0ZS4gVHJ1ZSBtZWFuc1xuXHQgKiBoZWxwIGlzIG9wZW4sIGZhbHNlIG1lYW5zIGl0J3MgY2xvc2VkLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9nZ2xlSGVscCggb3ZlcnJpZGUgKXtcblxuXHRcdGlmKCB0eXBlb2Ygb3ZlcnJpZGUgPT09ICdib29sZWFuJyApIHtcblx0XHRcdG92ZXJyaWRlID8gc2hvd0hlbHAoKSA6IGNsb3NlT3ZlcmxheSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmKCBkb20ub3ZlcmxheSApIHtcblx0XHRcdFx0Y2xvc2VPdmVybGF5KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2hvd0hlbHAoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogT3BlbnMgYW4gb3ZlcmxheSB3aW5kb3cgd2l0aCBoZWxwIG1hdGVyaWFsLlxuXHQgKi9cblx0ZnVuY3Rpb24gc2hvd0hlbHAoKSB7XG5cblx0XHRpZiggY29uZmlnLmhlbHAgKSB7XG5cblx0XHRcdGNsb3NlT3ZlcmxheSgpO1xuXG5cdFx0XHRkb20ub3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRkb20ub3ZlcmxheS5jbGFzc0xpc3QuYWRkKCAnb3ZlcmxheScgKTtcblx0XHRcdGRvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoICdvdmVybGF5LWhlbHAnICk7XG5cdFx0XHRkb20ud3JhcHBlci5hcHBlbmRDaGlsZCggZG9tLm92ZXJsYXkgKTtcblxuXHRcdFx0dmFyIGh0bWwgPSAnPHAgY2xhc3M9XCJ0aXRsZVwiPktleWJvYXJkIFNob3J0Y3V0czwvcD48YnIvPic7XG5cblx0XHRcdGh0bWwgKz0gJzx0YWJsZT48dGg+S0VZPC90aD48dGg+QUNUSU9OPC90aD4nO1xuXHRcdFx0Zm9yKCB2YXIga2V5IGluIGtleWJvYXJkU2hvcnRjdXRzICkge1xuXHRcdFx0XHRodG1sICs9ICc8dHI+PHRkPicgKyBrZXkgKyAnPC90ZD48dGQ+JyArIGtleWJvYXJkU2hvcnRjdXRzWyBrZXkgXSArICc8L3RkPjwvdHI+Jztcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGN1c3RvbSBrZXkgYmluZGluZ3MgdGhhdCBoYXZlIGFzc29jaWF0ZWQgZGVzY3JpcHRpb25zXG5cdFx0XHRmb3IoIHZhciBiaW5kaW5nIGluIHJlZ2lzdGVyZWRLZXlCaW5kaW5ncyApIHtcblx0XHRcdFx0aWYoIHJlZ2lzdGVyZWRLZXlCaW5kaW5nc1tiaW5kaW5nXS5rZXkgJiYgcmVnaXN0ZXJlZEtleUJpbmRpbmdzW2JpbmRpbmddLmRlc2NyaXB0aW9uICkge1xuXHRcdFx0XHRcdGh0bWwgKz0gJzx0cj48dGQ+JyArIHJlZ2lzdGVyZWRLZXlCaW5kaW5nc1tiaW5kaW5nXS5rZXkgKyAnPC90ZD48dGQ+JyArIHJlZ2lzdGVyZWRLZXlCaW5kaW5nc1tiaW5kaW5nXS5kZXNjcmlwdGlvbiArICc8L3RkPjwvdHI+Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRodG1sICs9ICc8L3RhYmxlPic7XG5cblx0XHRcdGRvbS5vdmVybGF5LmlubmVySFRNTCA9IFtcblx0XHRcdFx0JzxoZWFkZXI+Jyxcblx0XHRcdFx0XHQnPGEgY2xhc3M9XCJjbG9zZVwiIGhyZWY9XCIjXCI+PHNwYW4gY2xhc3M9XCJpY29uXCI+PC9zcGFuPjwvYT4nLFxuXHRcdFx0XHQnPC9oZWFkZXI+Jyxcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJ2aWV3cG9ydFwiPicsXG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJ2aWV3cG9ydC1pbm5lclwiPicrIGh0bWwgKyc8L2Rpdj4nLFxuXHRcdFx0XHQnPC9kaXY+J1xuXHRcdFx0XS5qb2luKCcnKTtcblxuXHRcdFx0ZG9tLm92ZXJsYXkucXVlcnlTZWxlY3RvciggJy5jbG9zZScgKS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGNsb3NlT3ZlcmxheSgpO1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRvbS5vdmVybGF5LmNsYXNzTGlzdC5hZGQoICd2aXNpYmxlJyApO1xuXHRcdFx0fSwgMSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2VzIGFueSBjdXJyZW50bHkgb3BlbiBvdmVybGF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gY2xvc2VPdmVybGF5KCkge1xuXG5cdFx0aWYoIGRvbS5vdmVybGF5ICkge1xuXHRcdFx0ZG9tLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZG9tLm92ZXJsYXkgKTtcblx0XHRcdGRvbS5vdmVybGF5ID0gbnVsbDtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIEphdmFTY3JpcHQtY29udHJvbGxlZCBsYXlvdXQgcnVsZXMgdG8gdGhlXG5cdCAqIHByZXNlbnRhdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGxheW91dCgpIHtcblxuXHRcdGlmKCBkb20ud3JhcHBlciAmJiAhaXNQcmludGluZ1BERigpICkge1xuXG5cdFx0XHRpZiggIWNvbmZpZy5kaXNhYmxlTGF5b3V0ICkge1xuXG5cdFx0XHRcdHZhciBzaXplID0gZ2V0Q29tcHV0ZWRTbGlkZVNpemUoKTtcblxuXHRcdFx0XHQvLyBMYXlvdXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzbGlkZXNcblx0XHRcdFx0bGF5b3V0U2xpZGVDb250ZW50cyggY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0ICk7XG5cblx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS53aWR0aCA9IHNpemUud2lkdGggKyAncHgnO1xuXHRcdFx0XHRkb20uc2xpZGVzLnN0eWxlLmhlaWdodCA9IHNpemUuaGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgc2NhbGUgb2YgY29udGVudCB0byBmaXQgd2l0aGluIGF2YWlsYWJsZSBzcGFjZVxuXHRcdFx0XHRzY2FsZSA9IE1hdGgubWluKCBzaXplLnByZXNlbnRhdGlvbldpZHRoIC8gc2l6ZS53aWR0aCwgc2l6ZS5wcmVzZW50YXRpb25IZWlnaHQgLyBzaXplLmhlaWdodCApO1xuXG5cdFx0XHRcdC8vIFJlc3BlY3QgbWF4L21pbiBzY2FsZSBzZXR0aW5nc1xuXHRcdFx0XHRzY2FsZSA9IE1hdGgubWF4KCBzY2FsZSwgY29uZmlnLm1pblNjYWxlICk7XG5cdFx0XHRcdHNjYWxlID0gTWF0aC5taW4oIHNjYWxlLCBjb25maWcubWF4U2NhbGUgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBhcHBseSBhbnkgc2NhbGluZyBzdHlsZXMgaWYgc2NhbGUgaXMgMVxuXHRcdFx0XHRpZiggc2NhbGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS56b29tID0gJyc7XG5cdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS5sZWZ0ID0gJyc7XG5cdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS50b3AgPSAnJztcblx0XHRcdFx0XHRkb20uc2xpZGVzLnN0eWxlLmJvdHRvbSA9ICcnO1xuXHRcdFx0XHRcdGRvbS5zbGlkZXMuc3R5bGUucmlnaHQgPSAnJztcblx0XHRcdFx0XHR0cmFuc2Zvcm1TbGlkZXMoIHsgbGF5b3V0OiAnJyB9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gUHJlZmVyIHpvb20gZm9yIHNjYWxpbmcgdXAgc28gdGhhdCBjb250ZW50IHJlbWFpbnMgY3Jpc3AuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgdXNlIHpvb20gdG8gc2NhbGUgZG93biBzaW5jZSB0aGF0IGNhbiBsZWFkIHRvIHNoaWZ0c1xuXHRcdFx0XHRcdC8vIGluIHRleHQgbGF5b3V0L2xpbmUgYnJlYWtzLlxuXHRcdFx0XHRcdGlmKCBzY2FsZSA+IDEgJiYgZmVhdHVyZXMuem9vbSApIHtcblx0XHRcdFx0XHRcdGRvbS5zbGlkZXMuc3R5bGUuem9vbSA9IHNjYWxlO1xuXHRcdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS5sZWZ0ID0gJyc7XG5cdFx0XHRcdFx0XHRkb20uc2xpZGVzLnN0eWxlLnRvcCA9ICcnO1xuXHRcdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS5ib3R0b20gPSAnJztcblx0XHRcdFx0XHRcdGRvbS5zbGlkZXMuc3R5bGUucmlnaHQgPSAnJztcblx0XHRcdFx0XHRcdHRyYW5zZm9ybVNsaWRlcyggeyBsYXlvdXQ6ICcnIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQXBwbHkgc2NhbGUgdHJhbnNmb3JtIGFzIGEgZmFsbGJhY2tcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGRvbS5zbGlkZXMuc3R5bGUuem9vbSA9ICcnO1xuXHRcdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS5sZWZ0ID0gJzUwJSc7XG5cdFx0XHRcdFx0XHRkb20uc2xpZGVzLnN0eWxlLnRvcCA9ICc1MCUnO1xuXHRcdFx0XHRcdFx0ZG9tLnNsaWRlcy5zdHlsZS5ib3R0b20gPSAnYXV0byc7XG5cdFx0XHRcdFx0XHRkb20uc2xpZGVzLnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtU2xpZGVzKCB7IGxheW91dDogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSBzY2FsZSgnKyBzY2FsZSArJyknIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZWxlY3QgYWxsIHNsaWRlcywgdmVydGljYWwgYW5kIGhvcml6b250YWxcblx0XHRcdFx0dmFyIHNsaWRlcyA9IHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFNMSURFU19TRUxFQ1RPUiApICk7XG5cblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGxlbiA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHR2YXIgc2xpZGUgPSBzbGlkZXNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGJvdGhlciB1cGRhdGluZyBpbnZpc2libGUgc2xpZGVzXG5cdFx0XHRcdFx0aWYoIHNsaWRlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKCBjb25maWcuY2VudGVyIHx8IHNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ2NlbnRlcicgKSApIHtcblx0XHRcdFx0XHRcdC8vIFZlcnRpY2FsIHN0YWNrcyBhcmUgbm90IGNlbnRyZWQgc2luY2UgdGhlaXIgc2VjdGlvblxuXHRcdFx0XHRcdFx0Ly8gY2hpbGRyZW4gd2lsbCBiZVxuXHRcdFx0XHRcdFx0aWYoIHNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ3N0YWNrJyApICkge1xuXHRcdFx0XHRcdFx0XHRzbGlkZS5zdHlsZS50b3AgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNsaWRlLnN0eWxlLnRvcCA9IE1hdGgubWF4KCAoIHNpemUuaGVpZ2h0IC0gc2xpZGUuc2Nyb2xsSGVpZ2h0ICkgLyAyLCAwICkgKyAncHgnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHNsaWRlLnN0eWxlLnRvcCA9ICcnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlUHJvZ3Jlc3MoKTtcblx0XHRcdHVwZGF0ZVBhcmFsbGF4KCk7XG5cblx0XHRcdGlmKCBpc092ZXJ2aWV3KCkgKSB7XG5cdFx0XHRcdHVwZGF0ZU92ZXJ2aWV3KCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGxheW91dCBsb2dpYyB0byB0aGUgY29udGVudHMgb2YgYWxsIHNsaWRlcyBpblxuXHQgKiB0aGUgcHJlc2VudGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaGVpZ2h0XG5cdCAqL1xuXHRmdW5jdGlvbiBsYXlvdXRTbGlkZUNvbnRlbnRzKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0Ly8gSGFuZGxlIHNpemluZyBvZiBlbGVtZW50cyB3aXRoIHRoZSAnc3RyZXRjaCcgY2xhc3Ncblx0XHR0b0FycmF5KCBkb20uc2xpZGVzLnF1ZXJ5U2VsZWN0b3JBbGwoICdzZWN0aW9uID4gLnN0cmV0Y2gnICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGhvdyBtdWNoIHZlcnRpY2FsIHNwYWNlIHdlIGNhbiB1c2Vcblx0XHRcdHZhciByZW1haW5pbmdIZWlnaHQgPSBnZXRSZW1haW5pbmdIZWlnaHQoIGVsZW1lbnQsIGhlaWdodCApO1xuXG5cdFx0XHQvLyBDb25zaWRlciB0aGUgYXNwZWN0IHJhdGlvIG9mIG1lZGlhIGVsZW1lbnRzXG5cdFx0XHRpZiggLyhpbWd8dmlkZW8pL2dpLnRlc3QoIGVsZW1lbnQubm9kZU5hbWUgKSApIHtcblx0XHRcdFx0dmFyIG53ID0gZWxlbWVudC5uYXR1cmFsV2lkdGggfHwgZWxlbWVudC52aWRlb1dpZHRoLFxuXHRcdFx0XHRcdG5oID0gZWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnQudmlkZW9IZWlnaHQ7XG5cblx0XHRcdFx0dmFyIGVzID0gTWF0aC5taW4oIHdpZHRoIC8gbncsIHJlbWFpbmluZ0hlaWdodCAvIG5oICk7XG5cblx0XHRcdFx0ZWxlbWVudC5zdHlsZS53aWR0aCA9ICggbncgKiBlcyApICsgJ3B4Jztcblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoIG5oICogZXMgKSArICdweCc7XG5cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRlbGVtZW50LnN0eWxlLmhlaWdodCA9IHJlbWFpbmluZ0hlaWdodCArICdweCc7XG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBjb21wdXRlZCBwaXhlbCBzaXplIG9mIG91ciBzbGlkZXMuIFRoZXNlXG5cdCAqIHZhbHVlcyBhcmUgYmFzZWQgb24gdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29uZmlndXJhdGlvblxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3ByZXNlbnRhdGlvbldpZHRoPWRvbS53cmFwcGVyLm9mZnNldFdpZHRoXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3ByZXNlbnRhdGlvbkhlaWdodD1kb20ud3JhcHBlci5vZmZzZXRIZWlnaHRdXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRDb21wdXRlZFNsaWRlU2l6ZSggcHJlc2VudGF0aW9uV2lkdGgsIHByZXNlbnRhdGlvbkhlaWdodCApIHtcblxuXHRcdHZhciBzaXplID0ge1xuXHRcdFx0Ly8gU2xpZGUgc2l6ZVxuXHRcdFx0d2lkdGg6IGNvbmZpZy53aWR0aCxcblx0XHRcdGhlaWdodDogY29uZmlnLmhlaWdodCxcblxuXHRcdFx0Ly8gUHJlc2VudGF0aW9uIHNpemVcblx0XHRcdHByZXNlbnRhdGlvbldpZHRoOiBwcmVzZW50YXRpb25XaWR0aCB8fCBkb20ud3JhcHBlci5vZmZzZXRXaWR0aCxcblx0XHRcdHByZXNlbnRhdGlvbkhlaWdodDogcHJlc2VudGF0aW9uSGVpZ2h0IHx8IGRvbS53cmFwcGVyLm9mZnNldEhlaWdodFxuXHRcdH07XG5cblx0XHQvLyBSZWR1Y2UgYXZhaWxhYmxlIHNwYWNlIGJ5IG1hcmdpblxuXHRcdHNpemUucHJlc2VudGF0aW9uV2lkdGggLT0gKCBzaXplLnByZXNlbnRhdGlvbldpZHRoICogY29uZmlnLm1hcmdpbiApO1xuXHRcdHNpemUucHJlc2VudGF0aW9uSGVpZ2h0IC09ICggc2l6ZS5wcmVzZW50YXRpb25IZWlnaHQgKiBjb25maWcubWFyZ2luICk7XG5cblx0XHQvLyBTbGlkZSB3aWR0aCBtYXkgYmUgYSBwZXJjZW50YWdlIG9mIGF2YWlsYWJsZSB3aWR0aFxuXHRcdGlmKCB0eXBlb2Ygc2l6ZS53aWR0aCA9PT0gJ3N0cmluZycgJiYgLyUkLy50ZXN0KCBzaXplLndpZHRoICkgKSB7XG5cdFx0XHRzaXplLndpZHRoID0gcGFyc2VJbnQoIHNpemUud2lkdGgsIDEwICkgLyAxMDAgKiBzaXplLnByZXNlbnRhdGlvbldpZHRoO1xuXHRcdH1cblxuXHRcdC8vIFNsaWRlIGhlaWdodCBtYXkgYmUgYSBwZXJjZW50YWdlIG9mIGF2YWlsYWJsZSBoZWlnaHRcblx0XHRpZiggdHlwZW9mIHNpemUuaGVpZ2h0ID09PSAnc3RyaW5nJyAmJiAvJSQvLnRlc3QoIHNpemUuaGVpZ2h0ICkgKSB7XG5cdFx0XHRzaXplLmhlaWdodCA9IHBhcnNlSW50KCBzaXplLmhlaWdodCwgMTAgKSAvIDEwMCAqIHNpemUucHJlc2VudGF0aW9uSGVpZ2h0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzaXplO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3RvcmVzIHRoZSB2ZXJ0aWNhbCBpbmRleCBvZiBhIHN0YWNrIHNvIHRoYXQgdGhlIHNhbWVcblx0ICogdmVydGljYWwgc2xpZGUgY2FuIGJlIHNlbGVjdGVkIHdoZW4gbmF2aWdhdGluZyB0byBhbmRcblx0ICogZnJvbSB0aGUgc3RhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YWNrIFRoZSB2ZXJ0aWNhbCBzdGFjayBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3Y9MF0gSW5kZXggdG8gbWVtb3JpemVcblx0ICovXG5cdGZ1bmN0aW9uIHNldFByZXZpb3VzVmVydGljYWxJbmRleCggc3RhY2ssIHYgKSB7XG5cblx0XHRpZiggdHlwZW9mIHN0YWNrID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc3RhY2suc2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0c3RhY2suc2V0QXR0cmlidXRlKCAnZGF0YS1wcmV2aW91cy1pbmRleHYnLCB2IHx8IDAgKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIHZlcnRpY2FsIGluZGV4IHdoaWNoIHdhcyBzdG9yZWQgdXNpbmdcblx0ICogI3NldFByZXZpb3VzVmVydGljYWxJbmRleCgpIG9yIDAgaWYgbm8gcHJldmlvdXMgaW5kZXhcblx0ICogZXhpc3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGFjayBUaGUgdmVydGljYWwgc3RhY2sgZWxlbWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UHJldmlvdXNWZXJ0aWNhbEluZGV4KCBzdGFjayApIHtcblxuXHRcdGlmKCB0eXBlb2Ygc3RhY2sgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzdGFjay5zZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbicgJiYgc3RhY2suY2xhc3NMaXN0LmNvbnRhaW5zKCAnc3RhY2snICkgKSB7XG5cdFx0XHQvLyBQcmVmZXIgbWFudWFsbHkgZGVmaW5lZCBzdGFydC1pbmRleHZcblx0XHRcdHZhciBhdHRyaWJ1dGVOYW1lID0gc3RhY2suaGFzQXR0cmlidXRlKCAnZGF0YS1zdGFydC1pbmRleHYnICkgPyAnZGF0YS1zdGFydC1pbmRleHYnIDogJ2RhdGEtcHJldmlvdXMtaW5kZXh2JztcblxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KCBzdGFjay5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKSB8fCAwLCAxMCApO1xuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXG5cdH1cblxuXHQvKipcblx0ICogRGlzcGxheXMgdGhlIG92ZXJ2aWV3IG9mIHNsaWRlcyAocXVpY2sgbmF2KSBieSBzY2FsaW5nXG5cdCAqIGRvd24gYW5kIGFycmFuZ2luZyBhbGwgc2xpZGUgZWxlbWVudHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBhY3RpdmF0ZU92ZXJ2aWV3KCkge1xuXG5cdFx0Ly8gT25seSBwcm9jZWVkIGlmIGVuYWJsZWQgaW4gY29uZmlnXG5cdFx0aWYoIGNvbmZpZy5vdmVydmlldyAmJiAhaXNPdmVydmlldygpICkge1xuXG5cdFx0XHRvdmVydmlldyA9IHRydWU7XG5cblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5hZGQoICdvdmVydmlldycgKTtcblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoICdvdmVydmlldy1kZWFjdGl2YXRpbmcnICk7XG5cblx0XHRcdGlmKCBmZWF0dXJlcy5vdmVydmlld1RyYW5zaXRpb25zICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnb3ZlcnZpZXctYW5pbWF0ZWQnICk7XG5cdFx0XHRcdH0sIDEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRG9uJ3QgYXV0by1zbGlkZSB3aGlsZSBpbiBvdmVydmlldyBtb2RlXG5cdFx0XHRjYW5jZWxBdXRvU2xpZGUoKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgYmFja2dyb3VuZHMgZWxlbWVudCBpbnRvIHRoZSBzbGlkZSBjb250YWluZXIgdG9cblx0XHRcdC8vIHRoYXQgdGhlIHNhbWUgc2NhbGluZyBpcyBhcHBsaWVkXG5cdFx0XHRkb20uc2xpZGVzLmFwcGVuZENoaWxkKCBkb20uYmFja2dyb3VuZCApO1xuXG5cdFx0XHQvLyBDbGlja2luZyBvbiBhbiBvdmVydmlldyBzbGlkZSBuYXZpZ2F0ZXMgdG8gaXRcblx0XHRcdHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFNMSURFU19TRUxFQ1RPUiApICkuZm9yRWFjaCggZnVuY3Rpb24oIHNsaWRlICkge1xuXHRcdFx0XHRpZiggIXNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ3N0YWNrJyApICkge1xuXHRcdFx0XHRcdHNsaWRlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIG9uT3ZlcnZpZXdTbGlkZUNsaWNrZWQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgc2xpZGUgc2l6ZXNcblx0XHRcdHZhciBtYXJnaW4gPSA3MDtcblx0XHRcdHZhciBzbGlkZVNpemUgPSBnZXRDb21wdXRlZFNsaWRlU2l6ZSgpO1xuXHRcdFx0b3ZlcnZpZXdTbGlkZVdpZHRoID0gc2xpZGVTaXplLndpZHRoICsgbWFyZ2luO1xuXHRcdFx0b3ZlcnZpZXdTbGlkZUhlaWdodCA9IHNsaWRlU2l6ZS5oZWlnaHQgKyBtYXJnaW47XG5cblx0XHRcdC8vIFJldmVyc2UgaW4gUlRMIG1vZGVcblx0XHRcdGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0XHRvdmVydmlld1NsaWRlV2lkdGggPSAtb3ZlcnZpZXdTbGlkZVdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVTbGlkZXNWaXNpYmlsaXR5KCk7XG5cdFx0XHRsYXlvdXRPdmVydmlldygpO1xuXHRcdFx0dXBkYXRlT3ZlcnZpZXcoKTtcblxuXHRcdFx0bGF5b3V0KCk7XG5cblx0XHRcdC8vIE5vdGlmeSBvYnNlcnZlcnMgb2YgdGhlIG92ZXJ2aWV3IHNob3dpbmdcblx0XHRcdGRpc3BhdGNoRXZlbnQoICdvdmVydmlld3Nob3duJywge1xuXHRcdFx0XHQnaW5kZXhoJzogaW5kZXhoLFxuXHRcdFx0XHQnaW5kZXh2JzogaW5kZXh2LFxuXHRcdFx0XHQnY3VycmVudFNsaWRlJzogY3VycmVudFNsaWRlXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIENTUyB0cmFuc2Zvcm1zIHRvIHBvc2l0aW9uIGFsbCBzbGlkZXMgaW4gYSBncmlkIGZvclxuXHQgKiBkaXNwbGF5IGluc2lkZSBvZiB0aGUgb3ZlcnZpZXcgbW9kZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxheW91dE92ZXJ2aWV3KCkge1xuXG5cdFx0Ly8gTGF5b3V0IHNsaWRlc1xuXHRcdHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggaHNsaWRlLCBoICkge1xuXHRcdFx0aHNsaWRlLnNldEF0dHJpYnV0ZSggJ2RhdGEtaW5kZXgtaCcsIGggKTtcblx0XHRcdHRyYW5zZm9ybUVsZW1lbnQoIGhzbGlkZSwgJ3RyYW5zbGF0ZTNkKCcgKyAoIGggKiBvdmVydmlld1NsaWRlV2lkdGggKSArICdweCwgMCwgMCknICk7XG5cblx0XHRcdGlmKCBoc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCAnc3RhY2snICkgKSB7XG5cblx0XHRcdFx0dG9BcnJheSggaHNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICdzZWN0aW9uJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIHZzbGlkZSwgdiApIHtcblx0XHRcdFx0XHR2c2xpZGUuc2V0QXR0cmlidXRlKCAnZGF0YS1pbmRleC1oJywgaCApO1xuXHRcdFx0XHRcdHZzbGlkZS5zZXRBdHRyaWJ1dGUoICdkYXRhLWluZGV4LXYnLCB2ICk7XG5cblx0XHRcdFx0XHR0cmFuc2Zvcm1FbGVtZW50KCB2c2xpZGUsICd0cmFuc2xhdGUzZCgwLCAnICsgKCB2ICogb3ZlcnZpZXdTbGlkZUhlaWdodCApICsgJ3B4LCAwKScgKTtcblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gTGF5b3V0IHNsaWRlIGJhY2tncm91bmRzXG5cdFx0dG9BcnJheSggZG9tLmJhY2tncm91bmQuY2hpbGROb2RlcyApLmZvckVhY2goIGZ1bmN0aW9uKCBoYmFja2dyb3VuZCwgaCApIHtcblx0XHRcdHRyYW5zZm9ybUVsZW1lbnQoIGhiYWNrZ3JvdW5kLCAndHJhbnNsYXRlM2QoJyArICggaCAqIG92ZXJ2aWV3U2xpZGVXaWR0aCApICsgJ3B4LCAwLCAwKScgKTtcblxuXHRcdFx0dG9BcnJheSggaGJhY2tncm91bmQucXVlcnlTZWxlY3RvckFsbCggJy5zbGlkZS1iYWNrZ3JvdW5kJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIHZiYWNrZ3JvdW5kLCB2ICkge1xuXHRcdFx0XHR0cmFuc2Zvcm1FbGVtZW50KCB2YmFja2dyb3VuZCwgJ3RyYW5zbGF0ZTNkKDAsICcgKyAoIHYgKiBvdmVydmlld1NsaWRlSGVpZ2h0ICkgKyAncHgsIDApJyApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1vdmVzIHRoZSBvdmVydmlldyB2aWV3cG9ydCB0byB0aGUgY3VycmVudCBzbGlkZXMuXG5cdCAqIENhbGxlZCBlYWNoIHRpbWUgdGhlIGN1cnJlbnQgc2xpZGUgY2hhbmdlcy5cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZU92ZXJ2aWV3KCkge1xuXG5cdFx0dmFyIHZtaW4gPSBNYXRoLm1pbiggd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCApO1xuXHRcdHZhciBzY2FsZSA9IE1hdGgubWF4KCB2bWluIC8gNSwgMTUwICkgLyB2bWluO1xuXG5cdFx0dHJhbnNmb3JtU2xpZGVzKCB7XG5cdFx0XHRvdmVydmlldzogW1xuXHRcdFx0XHQnc2NhbGUoJysgc2NhbGUgKycpJyxcblx0XHRcdFx0J3RyYW5zbGF0ZVgoJysgKCAtaW5kZXhoICogb3ZlcnZpZXdTbGlkZVdpZHRoICkgKydweCknLFxuXHRcdFx0XHQndHJhbnNsYXRlWSgnKyAoIC1pbmRleHYgKiBvdmVydmlld1NsaWRlSGVpZ2h0ICkgKydweCknXG5cdFx0XHRdLmpvaW4oICcgJyApXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogRXhpdHMgdGhlIHNsaWRlIG92ZXJ2aWV3IGFuZCBlbnRlcnMgdGhlIGN1cnJlbnRseVxuXHQgKiBhY3RpdmUgc2xpZGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWFjdGl2YXRlT3ZlcnZpZXcoKSB7XG5cblx0XHQvLyBPbmx5IHByb2NlZWQgaWYgZW5hYmxlZCBpbiBjb25maWdcblx0XHRpZiggY29uZmlnLm92ZXJ2aWV3ICkge1xuXG5cdFx0XHRvdmVydmlldyA9IGZhbHNlO1xuXG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAnb3ZlcnZpZXcnICk7XG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAnb3ZlcnZpZXctYW5pbWF0ZWQnICk7XG5cblx0XHRcdC8vIFRlbXBvcmFyaWx5IGFkZCBhIGNsYXNzIHNvIHRoYXQgdHJhbnNpdGlvbnMgY2FuIGRvIGRpZmZlcmVudCB0aGluZ3Ncblx0XHRcdC8vIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZXkgYXJlIGV4aXRpbmcvZW50ZXJpbmcgb3ZlcnZpZXcsIG9yIGp1c3Rcblx0XHRcdC8vIG1vdmluZyBmcm9tIHNsaWRlIHRvIHNsaWRlXG5cdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnb3ZlcnZpZXctZGVhY3RpdmF0aW5nJyApO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoICdvdmVydmlldy1kZWFjdGl2YXRpbmcnICk7XG5cdFx0XHR9LCAxICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGJhY2tncm91bmQgZWxlbWVudCBiYWNrIG91dFxuXHRcdFx0ZG9tLndyYXBwZXIuYXBwZW5kQ2hpbGQoIGRvbS5iYWNrZ3JvdW5kICk7XG5cblx0XHRcdC8vIENsZWFuIHVwIGNoYW5nZXMgbWFkZSB0byBzbGlkZXNcblx0XHRcdHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFNMSURFU19TRUxFQ1RPUiApICkuZm9yRWFjaCggZnVuY3Rpb24oIHNsaWRlICkge1xuXHRcdFx0XHR0cmFuc2Zvcm1FbGVtZW50KCBzbGlkZSwgJycgKTtcblxuXHRcdFx0XHRzbGlkZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBvbk92ZXJ2aWV3U2xpZGVDbGlja2VkLCB0cnVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIENsZWFuIHVwIGNoYW5nZXMgbWFkZSB0byBiYWNrZ3JvdW5kc1xuXHRcdFx0dG9BcnJheSggZG9tLmJhY2tncm91bmQucXVlcnlTZWxlY3RvckFsbCggJy5zbGlkZS1iYWNrZ3JvdW5kJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIGJhY2tncm91bmQgKSB7XG5cdFx0XHRcdHRyYW5zZm9ybUVsZW1lbnQoIGJhY2tncm91bmQsICcnICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRyYW5zZm9ybVNsaWRlcyggeyBvdmVydmlldzogJycgfSApO1xuXG5cdFx0XHRzbGlkZSggaW5kZXhoLCBpbmRleHYgKTtcblxuXHRcdFx0bGF5b3V0KCk7XG5cblx0XHRcdGN1ZUF1dG9TbGlkZSgpO1xuXG5cdFx0XHQvLyBOb3RpZnkgb2JzZXJ2ZXJzIG9mIHRoZSBvdmVydmlldyBoaWRpbmdcblx0XHRcdGRpc3BhdGNoRXZlbnQoICdvdmVydmlld2hpZGRlbicsIHtcblx0XHRcdFx0J2luZGV4aCc6IGluZGV4aCxcblx0XHRcdFx0J2luZGV4dic6IGluZGV4dixcblx0XHRcdFx0J2N1cnJlbnRTbGlkZSc6IGN1cnJlbnRTbGlkZVxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgdGhlIHNsaWRlIG92ZXJ2aWV3IG1vZGUgb24gYW5kIG9mZi5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3ZlcnJpZGVdIEZsYWcgd2hpY2ggb3ZlcnJpZGVzIHRoZVxuXHQgKiB0b2dnbGUgbG9naWMgYW5kIGZvcmNpYmx5IHNldHMgdGhlIGRlc2lyZWQgc3RhdGUuIFRydWUgbWVhbnNcblx0ICogb3ZlcnZpZXcgaXMgb3BlbiwgZmFsc2UgbWVhbnMgaXQncyBjbG9zZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b2dnbGVPdmVydmlldyggb3ZlcnJpZGUgKSB7XG5cblx0XHRpZiggdHlwZW9mIG92ZXJyaWRlID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRvdmVycmlkZSA/IGFjdGl2YXRlT3ZlcnZpZXcoKSA6IGRlYWN0aXZhdGVPdmVydmlldygpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlzT3ZlcnZpZXcoKSA/IGRlYWN0aXZhdGVPdmVydmlldygpIDogYWN0aXZhdGVPdmVydmlldygpO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgb3ZlcnZpZXcgaXMgY3VycmVudGx5IGFjdGl2ZS5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb3ZlcnZpZXcgaXMgYWN0aXZlLFxuXHQgKiBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT3ZlcnZpZXcoKSB7XG5cblx0XHRyZXR1cm4gb3ZlcnZpZXc7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBoYXNoIFVSTCB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgY3VycmVudCBzbGlkZSBsb2NhdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGxvY2F0aW9uSGFzaCgpIHtcblxuXHRcdHZhciB1cmwgPSAnLyc7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGNyZWF0ZSBhIG5hbWVkIGxpbmsgYmFzZWQgb24gdGhlIHNsaWRlJ3MgSURcblx0XHR2YXIgaWQgPSBjdXJyZW50U2xpZGUgPyBjdXJyZW50U2xpZGUuZ2V0QXR0cmlidXRlKCAnaWQnICkgOiBudWxsO1xuXHRcdGlmKCBpZCApIHtcblx0XHRcdGlkID0gZW5jb2RlVVJJQ29tcG9uZW50KCBpZCApO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleGY7XG5cdFx0aWYoIGNvbmZpZy5mcmFnbWVudEluVVJMICkge1xuXHRcdFx0aW5kZXhmID0gZ2V0SW5kaWNlcygpLmY7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGN1cnJlbnQgc2xpZGUgaGFzIGFuIElELCB1c2UgdGhhdCBhcyBhIG5hbWVkIGxpbmssXG5cdFx0Ly8gYnV0IHdlIGRvbid0IHN1cHBvcnQgbmFtZWQgbGlua3Mgd2l0aCBhIGZyYWdtZW50IGluZGV4XG5cdFx0aWYoIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgaWQubGVuZ3RoICYmIGluZGV4ZiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dXJsID0gJy8nICsgaWQ7XG5cdFx0fVxuXHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIC9oL3YgaW5kZXhcblx0XHRlbHNlIHtcblx0XHRcdHZhciBoYXNoSW5kZXhCYXNlID0gY29uZmlnLmhhc2hPbmVCYXNlZEluZGV4ID8gMSA6IDA7XG5cdFx0XHRpZiggaW5kZXhoID4gMCB8fCBpbmRleHYgPiAwIHx8IGluZGV4ZiAhPT0gdW5kZWZpbmVkICkgdXJsICs9IGluZGV4aCArIGhhc2hJbmRleEJhc2U7XG5cdFx0XHRpZiggaW5kZXh2ID4gMCB8fCBpbmRleGYgIT09IHVuZGVmaW5lZCApIHVybCArPSAnLycgKyAoaW5kZXh2ICsgaGFzaEluZGV4QmFzZSApO1xuXHRcdFx0aWYoIGluZGV4ZiAhPT0gdW5kZWZpbmVkICkgdXJsICs9ICcvJyArIGluZGV4Zjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJsO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IG9yIHNwZWNpZmllZCBzbGlkZSBpcyB2ZXJ0aWNhbFxuXHQgKiAobmVzdGVkIHdpdGhpbiBhbm90aGVyIHNsaWRlKS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3NsaWRlPWN1cnJlbnRTbGlkZV0gVGhlIHNsaWRlIHRvIGNoZWNrXG5cdCAqIG9yaWVudGF0aW9uIG9mXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBpc1ZlcnRpY2FsU2xpZGUoIHNsaWRlICkge1xuXG5cdFx0Ly8gUHJlZmVyIHNsaWRlIGFyZ3VtZW50LCBvdGhlcndpc2UgdXNlIGN1cnJlbnQgc2xpZGVcblx0XHRzbGlkZSA9IHNsaWRlID8gc2xpZGUgOiBjdXJyZW50U2xpZGU7XG5cblx0XHRyZXR1cm4gc2xpZGUgJiYgc2xpZGUucGFyZW50Tm9kZSAmJiAhIXNsaWRlLnBhcmVudE5vZGUubm9kZU5hbWUubWF0Y2goIC9zZWN0aW9uL2kgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsaW5nIHRoZSBmdWxsc2NyZWVuIGZ1bmN0aW9uYWxpdHkgdmlhIHRoZSBmdWxsc2NyZWVuIEFQSVxuXHQgKlxuXHQgKiBAc2VlIGh0dHA6Ly9mdWxsc2NyZWVuLnNwZWMud2hhdHdnLm9yZy9cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9Vc2luZ19mdWxsc2NyZWVuX21vZGVcblx0ICovXG5cdGZ1bmN0aW9uIGVudGVyRnVsbHNjcmVlbigpIHtcblxuXHRcdHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gQ2hlY2sgd2hpY2ggaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlXG5cdFx0dmFyIHJlcXVlc3RNZXRob2QgPSBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuIHx8XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gfHxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbiB8fFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuIHx8XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbjtcblxuXHRcdGlmKCByZXF1ZXN0TWV0aG9kICkge1xuXHRcdFx0cmVxdWVzdE1ldGhvZC5hcHBseSggZWxlbWVudCApO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEVudGVycyB0aGUgcGF1c2VkIG1vZGUgd2hpY2ggZmFkZXMgZXZlcnl0aGluZyBvbiBzY3JlZW4gdG9cblx0ICogYmxhY2suXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXVzZSgpIHtcblxuXHRcdGlmKCBjb25maWcucGF1c2UgKSB7XG5cdFx0XHR2YXIgd2FzUGF1c2VkID0gZG9tLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCAncGF1c2VkJyApO1xuXG5cdFx0XHRjYW5jZWxBdXRvU2xpZGUoKTtcblx0XHRcdGRvbS53cmFwcGVyLmNsYXNzTGlzdC5hZGQoICdwYXVzZWQnICk7XG5cblx0XHRcdGlmKCB3YXNQYXVzZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRkaXNwYXRjaEV2ZW50KCAncGF1c2VkJyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4aXRzIGZyb20gdGhlIHBhdXNlZCBtb2RlLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzdW1lKCkge1xuXG5cdFx0dmFyIHdhc1BhdXNlZCA9IGRvbS53cmFwcGVyLmNsYXNzTGlzdC5jb250YWlucyggJ3BhdXNlZCcgKTtcblx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAncGF1c2VkJyApO1xuXG5cdFx0Y3VlQXV0b1NsaWRlKCk7XG5cblx0XHRpZiggd2FzUGF1c2VkICkge1xuXHRcdFx0ZGlzcGF0Y2hFdmVudCggJ3Jlc3VtZWQnICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgcGF1c2VkIG1vZGUgb24gYW5kIG9mZi5cblx0ICovXG5cdGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKCBvdmVycmlkZSApIHtcblxuXHRcdGlmKCB0eXBlb2Ygb3ZlcnJpZGUgPT09ICdib29sZWFuJyApIHtcblx0XHRcdG92ZXJyaWRlID8gcGF1c2UoKSA6IHJlc3VtZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlzUGF1c2VkKCkgPyByZXN1bWUoKSA6IHBhdXNlKCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHdlIGFyZSBjdXJyZW50bHkgaW4gdGhlIHBhdXNlZCBtb2RlLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG5cblx0XHRyZXR1cm4gZG9tLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCAncGF1c2VkJyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgYXV0byBzbGlkZSBtb2RlIG9uIGFuZCBvZmYuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlXSBGbGFnIHdoaWNoIHNldHMgdGhlIGRlc2lyZWQgc3RhdGUuXG5cdCAqIFRydWUgbWVhbnMgYXV0b3BsYXkgc3RhcnRzLCBmYWxzZSBtZWFucyBpdCBzdG9wcy5cblx0ICovXG5cblx0ZnVuY3Rpb24gdG9nZ2xlQXV0b1NsaWRlKCBvdmVycmlkZSApIHtcblxuXHRcdGlmKCB0eXBlb2Ygb3ZlcnJpZGUgPT09ICdib29sZWFuJyApIHtcblx0XHRcdG92ZXJyaWRlID8gcmVzdW1lQXV0b1NsaWRlKCkgOiBwYXVzZUF1dG9TbGlkZSgpO1xuXHRcdH1cblxuXHRcdGVsc2Uge1xuXHRcdFx0YXV0b1NsaWRlUGF1c2VkID8gcmVzdW1lQXV0b1NsaWRlKCkgOiBwYXVzZUF1dG9TbGlkZSgpO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgYXV0byBzbGlkZSBtb2RlIGlzIGN1cnJlbnRseSBvbi5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzQXV0b1NsaWRpbmcoKSB7XG5cblx0XHRyZXR1cm4gISEoIGF1dG9TbGlkZSAmJiAhYXV0b1NsaWRlUGF1c2VkICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTdGVwcyBmcm9tIHRoZSBjdXJyZW50IHBvaW50IGluIHRoZSBwcmVzZW50YXRpb24gdG8gdGhlXG5cdCAqIHNsaWRlIHdoaWNoIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuXHQgKiBpbmRpY2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2g9aW5kZXhoXSBIb3Jpem9udGFsIGluZGV4IG9mIHRoZSB0YXJnZXQgc2xpZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt2PWluZGV4dl0gVmVydGljYWwgaW5kZXggb2YgdGhlIHRhcmdldCBzbGlkZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2ZdIEluZGV4IG9mIGEgZnJhZ21lbnQgd2l0aGluIHRoZVxuXHQgKiB0YXJnZXQgc2xpZGUgdG8gYWN0aXZhdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvXSBPcmlnaW4gZm9yIHVzZSBpbiBtdWx0aW1hc3RlciBlbnZpcm9ubWVudHNcblx0ICovXG5cdGZ1bmN0aW9uIHNsaWRlKCBoLCB2LCBmLCBvICkge1xuXG5cdFx0Ly8gUmVtZW1iZXIgd2hlcmUgd2Ugd2VyZSBhdCBiZWZvcmVcblx0XHRwcmV2aW91c1NsaWRlID0gY3VycmVudFNsaWRlO1xuXG5cdFx0Ly8gUXVlcnkgYWxsIGhvcml6b250YWwgc2xpZGVzIGluIHRoZSBkZWNrXG5cdFx0dmFyIGhvcml6b250YWxTbGlkZXMgPSBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApO1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIG5vIHNsaWRlc1xuXHRcdGlmKCBob3Jpem9udGFsU2xpZGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdC8vIElmIG5vIHZlcnRpY2FsIGluZGV4IGlzIHNwZWNpZmllZCBhbmQgdGhlIHVwY29taW5nIHNsaWRlIGlzIGFcblx0XHQvLyBzdGFjaywgcmVzdW1lIGF0IGl0cyBwcmV2aW91cyB2ZXJ0aWNhbCBpbmRleFxuXHRcdGlmKCB2ID09PSB1bmRlZmluZWQgJiYgIWlzT3ZlcnZpZXcoKSApIHtcblx0XHRcdHYgPSBnZXRQcmV2aW91c1ZlcnRpY2FsSW5kZXgoIGhvcml6b250YWxTbGlkZXNbIGggXSApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIHdlcmUgb24gYSB2ZXJ0aWNhbCBzdGFjaywgcmVtZW1iZXIgd2hhdCB2ZXJ0aWNhbCBpbmRleFxuXHRcdC8vIGl0IHdhcyBvbiBzbyB3ZSBjYW4gcmVzdW1lIGF0IHRoZSBzYW1lIHBvc2l0aW9uIHdoZW4gcmV0dXJuaW5nXG5cdFx0aWYoIHByZXZpb3VzU2xpZGUgJiYgcHJldmlvdXNTbGlkZS5wYXJlbnROb2RlICYmIHByZXZpb3VzU2xpZGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoICdzdGFjaycgKSApIHtcblx0XHRcdHNldFByZXZpb3VzVmVydGljYWxJbmRleCggcHJldmlvdXNTbGlkZS5wYXJlbnROb2RlLCBpbmRleHYgKTtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGUgc3RhdGUgYmVmb3JlIHRoaXMgc2xpZGVcblx0XHR2YXIgc3RhdGVCZWZvcmUgPSBzdGF0ZS5jb25jYXQoKTtcblxuXHRcdC8vIFJlc2V0IHRoZSBzdGF0ZSBhcnJheVxuXHRcdHN0YXRlLmxlbmd0aCA9IDA7XG5cblx0XHR2YXIgaW5kZXhoQmVmb3JlID0gaW5kZXhoIHx8IDAsXG5cdFx0XHRpbmRleHZCZWZvcmUgPSBpbmRleHYgfHwgMDtcblxuXHRcdC8vIEFjdGl2YXRlIGFuZCB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgc2xpZGVcblx0XHRpbmRleGggPSB1cGRhdGVTbGlkZXMoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SLCBoID09PSB1bmRlZmluZWQgPyBpbmRleGggOiBoICk7XG5cdFx0aW5kZXh2ID0gdXBkYXRlU2xpZGVzKCBWRVJUSUNBTF9TTElERVNfU0VMRUNUT1IsIHYgPT09IHVuZGVmaW5lZCA/IGluZGV4diA6IHYgKTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgdmlzaWJpbGl0eSBvZiBzbGlkZXMgbm93IHRoYXQgdGhlIGluZGljZXMgaGF2ZSBjaGFuZ2VkXG5cdFx0dXBkYXRlU2xpZGVzVmlzaWJpbGl0eSgpO1xuXG5cdFx0bGF5b3V0KCk7XG5cblx0XHQvLyBBcHBseSB0aGUgbmV3IHN0YXRlXG5cdFx0c3RhdGVMb29wOiBmb3IoIHZhciBpID0gMCwgbGVuID0gc3RhdGUubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHQvLyBDaGVjayBpZiB0aGlzIHN0YXRlIGV4aXN0ZWQgb24gdGhlIHByZXZpb3VzIHNsaWRlLiBJZiBpdFxuXHRcdFx0Ly8gZGlkLCB3ZSB3aWxsIGF2b2lkIGFkZGluZyBpdCByZXBlYXRlZGx5XG5cdFx0XHRmb3IoIHZhciBqID0gMDsgaiA8IHN0YXRlQmVmb3JlLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHRpZiggc3RhdGVCZWZvcmVbal0gPT09IHN0YXRlW2ldICkge1xuXHRcdFx0XHRcdHN0YXRlQmVmb3JlLnNwbGljZSggaiwgMSApO1xuXHRcdFx0XHRcdGNvbnRpbnVlIHN0YXRlTG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCggc3RhdGVbaV0gKTtcblxuXHRcdFx0Ly8gRGlzcGF0Y2ggY3VzdG9tIGV2ZW50IG1hdGNoaW5nIHRoZSBzdGF0ZSdzIG5hbWVcblx0XHRcdGRpc3BhdGNoRXZlbnQoIHN0YXRlW2ldICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIHJlbWFpbnMgb2YgdGhlIHByZXZpb3VzIHN0YXRlXG5cdFx0d2hpbGUoIHN0YXRlQmVmb3JlLmxlbmd0aCApIHtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCBzdGF0ZUJlZm9yZS5wb3AoKSApO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSB0aGUgb3ZlcnZpZXcgaWYgaXQncyBjdXJyZW50bHkgYWN0aXZlXG5cdFx0aWYoIGlzT3ZlcnZpZXcoKSApIHtcblx0XHRcdHVwZGF0ZU92ZXJ2aWV3KCk7XG5cdFx0fVxuXG5cdFx0Ly8gRmluZCB0aGUgY3VycmVudCBob3Jpem9udGFsIHNsaWRlIGFuZCBhbnkgcG9zc2libGUgdmVydGljYWwgc2xpZGVzXG5cdFx0Ly8gd2l0aGluIGl0XG5cdFx0dmFyIGN1cnJlbnRIb3Jpem9udGFsU2xpZGUgPSBob3Jpem9udGFsU2xpZGVzWyBpbmRleGggXSxcblx0XHRcdGN1cnJlbnRWZXJ0aWNhbFNsaWRlcyA9IGN1cnJlbnRIb3Jpem9udGFsU2xpZGUucXVlcnlTZWxlY3RvckFsbCggJ3NlY3Rpb24nICk7XG5cblx0XHQvLyBTdG9yZSByZWZlcmVuY2VzIHRvIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBzbGlkZXNcblx0XHRjdXJyZW50U2xpZGUgPSBjdXJyZW50VmVydGljYWxTbGlkZXNbIGluZGV4diBdIHx8IGN1cnJlbnRIb3Jpem9udGFsU2xpZGU7XG5cblx0XHQvLyBTaG93IGZyYWdtZW50LCBpZiBzcGVjaWZpZWRcblx0XHRpZiggdHlwZW9mIGYgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0bmF2aWdhdGVGcmFnbWVudCggZiApO1xuXHRcdH1cblxuXHRcdC8vIERpc3BhdGNoIGFuIGV2ZW50IGlmIHRoZSBzbGlkZSBjaGFuZ2VkXG5cdFx0dmFyIHNsaWRlQ2hhbmdlZCA9ICggaW5kZXhoICE9PSBpbmRleGhCZWZvcmUgfHwgaW5kZXh2ICE9PSBpbmRleHZCZWZvcmUgKTtcblx0XHRpZiAoIXNsaWRlQ2hhbmdlZCkge1xuXHRcdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIHByZXZpb3VzIHNsaWRlIGlzIG5ldmVyIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG5cdFx0XHRwcmV2aW91c1NsaWRlID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBTb2x2ZXMgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwcmV2aW91cyBzbGlkZSBtYWludGFpbnMgdGhlXG5cdFx0Ly8gJ3ByZXNlbnQnIGNsYXNzIHdoZW4gbmF2aWdhdGluZyBiZXR3ZWVuIGFkamFjZW50IHZlcnRpY2FsXG5cdFx0Ly8gc3RhY2tzXG5cdFx0aWYoIHByZXZpb3VzU2xpZGUgJiYgcHJldmlvdXNTbGlkZSAhPT0gY3VycmVudFNsaWRlICkge1xuXHRcdFx0cHJldmlvdXNTbGlkZS5jbGFzc0xpc3QucmVtb3ZlKCAncHJlc2VudCcgKTtcblx0XHRcdHByZXZpb3VzU2xpZGUuc2V0QXR0cmlidXRlKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblxuXHRcdFx0Ly8gUmVzZXQgYWxsIHNsaWRlcyB1cG9uIG5hdmlnYXRlIHRvIGhvbWVcblx0XHRcdC8vIElzc3VlOiAjMjg1XG5cdFx0XHRpZiAoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoIEhPTUVfU0xJREVfU0VMRUNUT1IgKS5jbGFzc0xpc3QuY29udGFpbnMoICdwcmVzZW50JyApICkge1xuXHRcdFx0XHQvLyBMYXVuY2ggYXN5bmMgdGFza1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHNsaWRlcyA9IHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICsgJy5zdGFjaycpICksIGk7XG5cdFx0XHRcdFx0Zm9yKCBpIGluIHNsaWRlcyApIHtcblx0XHRcdFx0XHRcdGlmKCBzbGlkZXNbaV0gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IHN0YWNrXG5cdFx0XHRcdFx0XHRcdHNldFByZXZpb3VzVmVydGljYWxJbmRleCggc2xpZGVzW2ldLCAwICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoIHNsaWRlQ2hhbmdlZCApIHtcblx0XHRcdGRpc3BhdGNoRXZlbnQoICdzbGlkZWNoYW5nZWQnLCB7XG5cdFx0XHRcdCdpbmRleGgnOiBpbmRleGgsXG5cdFx0XHRcdCdpbmRleHYnOiBpbmRleHYsXG5cdFx0XHRcdCdwcmV2aW91c1NsaWRlJzogcHJldmlvdXNTbGlkZSxcblx0XHRcdFx0J2N1cnJlbnRTbGlkZSc6IGN1cnJlbnRTbGlkZSxcblx0XHRcdFx0J29yaWdpbic6IG9cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgZW1iZWRkZWQgY29udGVudFxuXHRcdGlmKCBzbGlkZUNoYW5nZWQgfHwgIXByZXZpb3VzU2xpZGUgKSB7XG5cdFx0XHRzdG9wRW1iZWRkZWRDb250ZW50KCBwcmV2aW91c1NsaWRlICk7XG5cdFx0XHRzdGFydEVtYmVkZGVkQ29udGVudCggY3VycmVudFNsaWRlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQW5ub3VuY2UgdGhlIGN1cnJlbnQgc2xpZGUgY29udGVudHMsIGZvciBzY3JlZW4gcmVhZGVyc1xuXHRcdGRvbS5zdGF0dXNEaXYudGV4dENvbnRlbnQgPSBnZXRTdGF0dXNUZXh0KCBjdXJyZW50U2xpZGUgKTtcblxuXHRcdHVwZGF0ZUNvbnRyb2xzKCk7XG5cdFx0dXBkYXRlUHJvZ3Jlc3MoKTtcblx0XHR1cGRhdGVCYWNrZ3JvdW5kKCk7XG5cdFx0dXBkYXRlUGFyYWxsYXgoKTtcblx0XHR1cGRhdGVTbGlkZU51bWJlcigpO1xuXHRcdHVwZGF0ZU5vdGVzKCk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIFVSTCBoYXNoXG5cdFx0d3JpdGVVUkwoKTtcblxuXHRcdGN1ZUF1dG9TbGlkZSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3luY3MgdGhlIHByZXNlbnRhdGlvbiB3aXRoIHRoZSBjdXJyZW50IERPTS4gVXNlZnVsXG5cdCAqIHdoZW4gbmV3IHNsaWRlcyBvciBjb250cm9sIGVsZW1lbnRzIGFyZSBhZGRlZCBvciB3aGVuXG5cdCAqIHRoZSBjb25maWd1cmF0aW9uIGhhcyBjaGFuZ2VkLlxuXHQgKi9cblx0ZnVuY3Rpb24gc3luYygpIHtcblxuXHRcdC8vIFN1YnNjcmliZSB0byBpbnB1dFxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0YWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuXHRcdC8vIEZvcmNlIGEgbGF5b3V0IHRvIG1ha2Ugc3VyZSB0aGUgY3VycmVudCBjb25maWcgaXMgYWNjb3VudGVkIGZvclxuXHRcdGxheW91dCgpO1xuXG5cdFx0Ly8gUmVmbGVjdCB0aGUgY3VycmVudCBhdXRvU2xpZGUgdmFsdWVcblx0XHRhdXRvU2xpZGUgPSBjb25maWcuYXV0b1NsaWRlO1xuXG5cdFx0Ly8gU3RhcnQgYXV0by1zbGlkaW5nIGlmIGl0J3MgZW5hYmxlZFxuXHRcdGN1ZUF1dG9TbGlkZSgpO1xuXG5cdFx0Ly8gUmUtY3JlYXRlIHRoZSBzbGlkZSBiYWNrZ3JvdW5kc1xuXHRcdGNyZWF0ZUJhY2tncm91bmRzKCk7XG5cblx0XHQvLyBXcml0ZSB0aGUgY3VycmVudCBoYXNoIHRvIHRoZSBVUkxcblx0XHR3cml0ZVVSTCgpO1xuXG5cdFx0c29ydEFsbEZyYWdtZW50cygpO1xuXG5cdFx0dXBkYXRlQ29udHJvbHMoKTtcblx0XHR1cGRhdGVQcm9ncmVzcygpO1xuXHRcdHVwZGF0ZVNsaWRlTnVtYmVyKCk7XG5cdFx0dXBkYXRlU2xpZGVzVmlzaWJpbGl0eSgpO1xuXHRcdHVwZGF0ZUJhY2tncm91bmQoIHRydWUgKTtcblx0XHR1cGRhdGVOb3Rlc1Zpc2liaWxpdHkoKTtcblx0XHR1cGRhdGVOb3RlcygpO1xuXG5cdFx0Zm9ybWF0RW1iZWRkZWRDb250ZW50KCk7XG5cblx0XHQvLyBTdGFydCBvciBzdG9wIGVtYmVkZGVkIGNvbnRlbnQgZGVwZW5kaW5nIG9uIGdsb2JhbCBjb25maWdcblx0XHRpZiggY29uZmlnLmF1dG9QbGF5TWVkaWEgPT09IGZhbHNlICkge1xuXHRcdFx0c3RvcEVtYmVkZGVkQ29udGVudCggY3VycmVudFNsaWRlLCB7IHVubG9hZElmcmFtZXM6IGZhbHNlIH0gKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzdGFydEVtYmVkZGVkQ29udGVudCggY3VycmVudFNsaWRlICk7XG5cdFx0fVxuXG5cdFx0aWYoIGlzT3ZlcnZpZXcoKSApIHtcblx0XHRcdGxheW91dE92ZXJ2aWV3KCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyByZXZlYWwuanMgdG8ga2VlcCBpbiBzeW5jIHdpdGggbmV3IHNsaWRlIGF0dHJpYnV0ZXMuIEZvclxuXHQgKiBleGFtcGxlLCBpZiB5b3UgYWRkIGEgbmV3IGBkYXRhLWJhY2tncm91bmQtaW1hZ2VgIHlvdSBjYW4gY2FsbFxuXHQgKiB0aGlzIHRvIGhhdmUgcmV2ZWFsLmpzIHJlbmRlciB0aGUgbmV3IGJhY2tncm91bmQgaW1hZ2UuXG5cdCAqXG5cdCAqIFNpbWlsYXIgdG8gI3N5bmMoKSBidXQgbW9yZSBlZmZpY2llbnQgd2hlbiB5b3Ugb25seSBuZWVkIHRvXG5cdCAqIHJlZnJlc2ggYSBzcGVjaWZpYyBzbGlkZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2xpZGVcblx0ICovXG5cdGZ1bmN0aW9uIHN5bmNTbGlkZSggc2xpZGUgKSB7XG5cblx0XHRzeW5jQmFja2dyb3VuZCggc2xpZGUgKTtcblx0XHRzeW5jRnJhZ21lbnRzKCBzbGlkZSApO1xuXG5cdFx0dXBkYXRlQmFja2dyb3VuZCgpO1xuXHRcdHVwZGF0ZU5vdGVzKCk7XG5cblx0XHRsb2FkU2xpZGUoIHNsaWRlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtYXRzIHRoZSBmcmFnbWVudHMgb24gdGhlIGdpdmVuIHNsaWRlIHNvIHRoYXQgdGhleSBoYXZlXG5cdCAqIHZhbGlkIGluZGljZXMuIENhbGwgdGhpcyBpZiBmcmFnbWVudHMgYXJlIGNoYW5nZWQgaW4gdGhlIERPTVxuXHQgKiBhZnRlciByZXZlYWwuanMgaGFzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNsaWRlXG5cdCAqL1xuXHRmdW5jdGlvbiBzeW5jRnJhZ21lbnRzKCBzbGlkZSApIHtcblxuXHRcdHNvcnRGcmFnbWVudHMoIHNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICcuZnJhZ21lbnQnICkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBhbGwgdmVydGljYWwgc2xpZGVzIHNvIHRoYXQgb25seSB0aGUgZmlyc3Rcblx0ICogaXMgdmlzaWJsZS5cblx0ICovXG5cdGZ1bmN0aW9uIHJlc2V0VmVydGljYWxTbGlkZXMoKSB7XG5cblx0XHR2YXIgaG9yaXpvbnRhbFNsaWRlcyA9IHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICkgKTtcblx0XHRob3Jpem9udGFsU2xpZGVzLmZvckVhY2goIGZ1bmN0aW9uKCBob3Jpem9udGFsU2xpZGUgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNhbFNsaWRlcyA9IHRvQXJyYXkoIGhvcml6b250YWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKSApO1xuXHRcdFx0dmVydGljYWxTbGlkZXMuZm9yRWFjaCggZnVuY3Rpb24oIHZlcnRpY2FsU2xpZGUsIHkgKSB7XG5cblx0XHRcdFx0aWYoIHkgPiAwICkge1xuXHRcdFx0XHRcdHZlcnRpY2FsU2xpZGUuY2xhc3NMaXN0LnJlbW92ZSggJ3ByZXNlbnQnICk7XG5cdFx0XHRcdFx0dmVydGljYWxTbGlkZS5jbGFzc0xpc3QucmVtb3ZlKCAncGFzdCcgKTtcblx0XHRcdFx0XHR2ZXJ0aWNhbFNsaWRlLmNsYXNzTGlzdC5hZGQoICdmdXR1cmUnICk7XG5cdFx0XHRcdFx0dmVydGljYWxTbGlkZS5zZXRBdHRyaWJ1dGUoICdhcmlhLWhpZGRlbicsICd0cnVlJyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNvcnRzIGFuZCBmb3JtYXRzIGFsbCBvZiBmcmFnbWVudHMgaW4gdGhlXG5cdCAqIHByZXNlbnRhdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIHNvcnRBbGxGcmFnbWVudHMoKSB7XG5cblx0XHR2YXIgaG9yaXpvbnRhbFNsaWRlcyA9IHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICkgKTtcblx0XHRob3Jpem9udGFsU2xpZGVzLmZvckVhY2goIGZ1bmN0aW9uKCBob3Jpem9udGFsU2xpZGUgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNhbFNsaWRlcyA9IHRvQXJyYXkoIGhvcml6b250YWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKSApO1xuXHRcdFx0dmVydGljYWxTbGlkZXMuZm9yRWFjaCggZnVuY3Rpb24oIHZlcnRpY2FsU2xpZGUsIHkgKSB7XG5cblx0XHRcdFx0c29ydEZyYWdtZW50cyggdmVydGljYWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYoIHZlcnRpY2FsU2xpZGVzLmxlbmd0aCA9PT0gMCApIHNvcnRGcmFnbWVudHMoIGhvcml6b250YWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSYW5kb21seSBzaHVmZmxlcyBhbGwgc2xpZGVzIGluIHRoZSBkZWNrLlxuXHQgKi9cblx0ZnVuY3Rpb24gc2h1ZmZsZSgpIHtcblxuXHRcdHZhciBzbGlkZXMgPSB0b0FycmF5KCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApICk7XG5cblx0XHRzbGlkZXMuZm9yRWFjaCggZnVuY3Rpb24oIHNsaWRlICkge1xuXG5cdFx0XHQvLyBJbnNlcnQgdGhpcyBzbGlkZSBuZXh0IHRvIGFub3RoZXIgcmFuZG9tIHNsaWRlLiBUaGlzIG1heVxuXHRcdFx0Ly8gY2F1c2UgdGhlIHNsaWRlIHRvIGluc2VydCBiZWZvcmUgaXRzZWxmIGJ1dCB0aGF0J3MgZmluZS5cblx0XHRcdGRvbS5zbGlkZXMuaW5zZXJ0QmVmb3JlKCBzbGlkZSwgc2xpZGVzWyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogc2xpZGVzLmxlbmd0aCApIF0gKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgb25lIGRpbWVuc2lvbiBvZiBzbGlkZXMgYnkgc2hvd2luZyB0aGUgc2xpZGVcblx0ICogd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgQSBDU1Mgc2VsZWN0b3IgdGhhdCB3aWxsIGZldGNoXG5cdCAqIHRoZSBncm91cCBvZiBzbGlkZXMgd2UgYXJlIHdvcmtpbmcgd2l0aFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBzbGlkZSB0aGF0IHNob3VsZCBiZVxuXHQgKiBzaG93blxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc2xpZGUgdGhhdCBpcyBub3cgc2hvd24sXG5cdCAqIG1pZ2h0IGRpZmZlciBmcm9tIHRoZSBwYXNzZWQgaW4gaW5kZXggaWYgaXQgd2FzIG91dCBvZlxuXHQgKiBib3VuZHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVTbGlkZXMoIHNlbGVjdG9yLCBpbmRleCApIHtcblxuXHRcdC8vIFNlbGVjdCBhbGwgc2xpZGVzIGFuZCBjb252ZXJ0IHRoZSBOb2RlTGlzdCByZXN1bHQgdG9cblx0XHQvLyBhbiBhcnJheVxuXHRcdHZhciBzbGlkZXMgPSB0b0FycmF5KCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApICksXG5cdFx0XHRzbGlkZXNMZW5ndGggPSBzbGlkZXMubGVuZ3RoO1xuXG5cdFx0dmFyIHByaW50TW9kZSA9IGlzUHJpbnRpbmdQREYoKTtcblxuXHRcdGlmKCBzbGlkZXNMZW5ndGggKSB7XG5cblx0XHRcdC8vIFNob3VsZCB0aGUgaW5kZXggbG9vcD9cblx0XHRcdGlmKCBjb25maWcubG9vcCApIHtcblx0XHRcdFx0aW5kZXggJT0gc2xpZGVzTGVuZ3RoO1xuXG5cdFx0XHRcdGlmKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBzbGlkZXNMZW5ndGggKyBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbmZvcmNlIG1heCBhbmQgbWluaW11bSBpbmRleCBib3VuZHNcblx0XHRcdGluZGV4ID0gTWF0aC5tYXgoIE1hdGgubWluKCBpbmRleCwgc2xpZGVzTGVuZ3RoIC0gMSApLCAwICk7XG5cblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gc2xpZGVzW2ldO1xuXG5cdFx0XHRcdHZhciByZXZlcnNlID0gY29uZmlnLnJ0bCAmJiAhaXNWZXJ0aWNhbFNsaWRlKCBlbGVtZW50ICk7XG5cblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAncGFzdCcgKTtcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAncHJlc2VudCcgKTtcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAnZnV0dXJlJyApO1xuXG5cdFx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VkaXRpbmcuaHRtbCN0aGUtaGlkZGVuLWF0dHJpYnV0ZVxuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSggJ2hpZGRlbicsICcnICk7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblxuXHRcdFx0XHQvLyBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgdmVydGljYWwgc2xpZGVzXG5cdFx0XHRcdGlmKCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoICdzZWN0aW9uJyApICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3N0YWNrJyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgd2UncmUgcHJpbnRpbmcgc3RhdGljIHNsaWRlcywgYWxsIHNsaWRlcyBhcmUgXCJwcmVzZW50XCJcblx0XHRcdFx0aWYoIHByaW50TW9kZSApIHtcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoICdwcmVzZW50JyApO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIGkgPCBpbmRleCApIHtcblx0XHRcdFx0XHQvLyBBbnkgZWxlbWVudCBwcmV2aW91cyB0byBpbmRleCBpcyBnaXZlbiB0aGUgJ3Bhc3QnIGNsYXNzXG5cdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCByZXZlcnNlID8gJ2Z1dHVyZScgOiAncGFzdCcgKTtcblxuXHRcdFx0XHRcdGlmKCBjb25maWcuZnJhZ21lbnRzICkge1xuXHRcdFx0XHRcdFx0dmFyIHBhc3RGcmFnbWVudHMgPSB0b0FycmF5KCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcuZnJhZ21lbnQnICkgKTtcblxuXHRcdFx0XHRcdFx0Ly8gU2hvdyBhbGwgZnJhZ21lbnRzIG9uIHByaW9yIHNsaWRlc1xuXHRcdFx0XHRcdFx0d2hpbGUoIHBhc3RGcmFnbWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcGFzdEZyYWdtZW50ID0gcGFzdEZyYWdtZW50cy5wb3AoKTtcblx0XHRcdFx0XHRcdFx0cGFzdEZyYWdtZW50LmNsYXNzTGlzdC5hZGQoICd2aXNpYmxlJyApO1xuXHRcdFx0XHRcdFx0XHRwYXN0RnJhZ21lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoIGkgPiBpbmRleCApIHtcblx0XHRcdFx0XHQvLyBBbnkgZWxlbWVudCBzdWJzZXF1ZW50IHRvIGluZGV4IGlzIGdpdmVuIHRoZSAnZnV0dXJlJyBjbGFzc1xuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCggcmV2ZXJzZSA/ICdwYXN0JyA6ICdmdXR1cmUnICk7XG5cblx0XHRcdFx0XHRpZiggY29uZmlnLmZyYWdtZW50cyApIHtcblx0XHRcdFx0XHRcdHZhciBmdXR1cmVGcmFnbWVudHMgPSB0b0FycmF5KCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICcuZnJhZ21lbnQudmlzaWJsZScgKSApO1xuXG5cdFx0XHRcdFx0XHQvLyBObyBmcmFnbWVudHMgaW4gZnV0dXJlIHNsaWRlcyBzaG91bGQgYmUgdmlzaWJsZSBhaGVhZCBvZiB0aW1lXG5cdFx0XHRcdFx0XHR3aGlsZSggZnV0dXJlRnJhZ21lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZ1dHVyZUZyYWdtZW50ID0gZnV0dXJlRnJhZ21lbnRzLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRmdXR1cmVGcmFnbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAndmlzaWJsZScgKTtcblx0XHRcdFx0XHRcdFx0ZnV0dXJlRnJhZ21lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hcmsgdGhlIGN1cnJlbnQgc2xpZGUgYXMgcHJlc2VudFxuXHRcdFx0c2xpZGVzW2luZGV4XS5jbGFzc0xpc3QuYWRkKCAncHJlc2VudCcgKTtcblx0XHRcdHNsaWRlc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKCAnaGlkZGVuJyApO1xuXHRcdFx0c2xpZGVzW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoICdhcmlhLWhpZGRlbicgKTtcblxuXHRcdFx0Ly8gSWYgdGhpcyBzbGlkZSBoYXMgYSBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggaXQsIGFkZCBpdFxuXHRcdFx0Ly8gb250byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGVja1xuXHRcdFx0dmFyIHNsaWRlU3RhdGUgPSBzbGlkZXNbaW5kZXhdLmdldEF0dHJpYnV0ZSggJ2RhdGEtc3RhdGUnICk7XG5cdFx0XHRpZiggc2xpZGVTdGF0ZSApIHtcblx0XHRcdFx0c3RhdGUgPSBzdGF0ZS5jb25jYXQoIHNsaWRlU3RhdGUuc3BsaXQoICcgJyApICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBTaW5jZSB0aGVyZSBhcmUgbm8gc2xpZGVzIHdlIGNhbid0IGJlIGFueXdoZXJlIGJleW9uZCB0aGVcblx0XHRcdC8vIHplcm90aCBpbmRleFxuXHRcdFx0aW5kZXggPSAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE9wdGltaXphdGlvbiBtZXRob2Q7IGhpZGUgYWxsIHNsaWRlcyB0aGF0IGFyZSBmYXIgYXdheVxuXHQgKiBmcm9tIHRoZSBwcmVzZW50IHNsaWRlLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlU2xpZGVzVmlzaWJpbGl0eSgpIHtcblxuXHRcdC8vIFNlbGVjdCBhbGwgc2xpZGVzIGFuZCBjb252ZXJ0IHRoZSBOb2RlTGlzdCByZXN1bHQgdG9cblx0XHQvLyBhbiBhcnJheVxuXHRcdHZhciBob3Jpem9udGFsU2xpZGVzID0gdG9BcnJheSggZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggSE9SSVpPTlRBTF9TTElERVNfU0VMRUNUT1IgKSApLFxuXHRcdFx0aG9yaXpvbnRhbFNsaWRlc0xlbmd0aCA9IGhvcml6b250YWxTbGlkZXMubGVuZ3RoLFxuXHRcdFx0ZGlzdGFuY2VYLFxuXHRcdFx0ZGlzdGFuY2VZO1xuXG5cdFx0aWYoIGhvcml6b250YWxTbGlkZXNMZW5ndGggJiYgdHlwZW9mIGluZGV4aCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdC8vIFRoZSBudW1iZXIgb2Ygc3RlcHMgYXdheSBmcm9tIHRoZSBwcmVzZW50IHNsaWRlIHRoYXQgd2lsbFxuXHRcdFx0Ly8gYmUgdmlzaWJsZVxuXHRcdFx0dmFyIHZpZXdEaXN0YW5jZSA9IGlzT3ZlcnZpZXcoKSA/IDEwIDogY29uZmlnLnZpZXdEaXN0YW5jZTtcblxuXHRcdFx0Ly8gTGltaXQgdmlldyBkaXN0YW5jZSBvbiB3ZWFrZXIgZGV2aWNlc1xuXHRcdFx0aWYoIGlzTW9iaWxlRGV2aWNlICkge1xuXHRcdFx0XHR2aWV3RGlzdGFuY2UgPSBpc092ZXJ2aWV3KCkgPyA2IDogMjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxsIHNsaWRlcyBuZWVkIHRvIGJlIHZpc2libGUgd2hlbiBleHBvcnRpbmcgdG8gUERGXG5cdFx0XHRpZiggaXNQcmludGluZ1BERigpICkge1xuXHRcdFx0XHR2aWV3RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoIHZhciB4ID0gMDsgeCA8IGhvcml6b250YWxTbGlkZXNMZW5ndGg7IHgrKyApIHtcblx0XHRcdFx0dmFyIGhvcml6b250YWxTbGlkZSA9IGhvcml6b250YWxTbGlkZXNbeF07XG5cblx0XHRcdFx0dmFyIHZlcnRpY2FsU2xpZGVzID0gdG9BcnJheSggaG9yaXpvbnRhbFNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICdzZWN0aW9uJyApICksXG5cdFx0XHRcdFx0dmVydGljYWxTbGlkZXNMZW5ndGggPSB2ZXJ0aWNhbFNsaWRlcy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGhvdyBmYXIgYXdheSB0aGlzIHNsaWRlIGlzIGZyb20gdGhlIHByZXNlbnRcblx0XHRcdFx0ZGlzdGFuY2VYID0gTWF0aC5hYnMoICggaW5kZXhoIHx8IDAgKSAtIHggKSB8fCAwO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBwcmVzZW50YXRpb24gaXMgbG9vcGVkLCBkaXN0YW5jZSBzaG91bGQgbWVhc3VyZVxuXHRcdFx0XHQvLyAxIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IHNsaWRlc1xuXHRcdFx0XHRpZiggY29uZmlnLmxvb3AgKSB7XG5cdFx0XHRcdFx0ZGlzdGFuY2VYID0gTWF0aC5hYnMoICggKCBpbmRleGggfHwgMCApIC0geCApICUgKCBob3Jpem9udGFsU2xpZGVzTGVuZ3RoIC0gdmlld0Rpc3RhbmNlICkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2hvdyB0aGUgaG9yaXpvbnRhbCBzbGlkZSBpZiBpdCdzIHdpdGhpbiB0aGUgdmlldyBkaXN0YW5jZVxuXHRcdFx0XHRpZiggZGlzdGFuY2VYIDwgdmlld0Rpc3RhbmNlICkge1xuXHRcdFx0XHRcdGxvYWRTbGlkZSggaG9yaXpvbnRhbFNsaWRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dW5sb2FkU2xpZGUoIGhvcml6b250YWxTbGlkZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIHZlcnRpY2FsU2xpZGVzTGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0dmFyIG95ID0gZ2V0UHJldmlvdXNWZXJ0aWNhbEluZGV4KCBob3Jpem9udGFsU2xpZGUgKTtcblxuXHRcdFx0XHRcdGZvciggdmFyIHkgPSAwOyB5IDwgdmVydGljYWxTbGlkZXNMZW5ndGg7IHkrKyApIHtcblx0XHRcdFx0XHRcdHZhciB2ZXJ0aWNhbFNsaWRlID0gdmVydGljYWxTbGlkZXNbeV07XG5cblx0XHRcdFx0XHRcdGRpc3RhbmNlWSA9IHggPT09ICggaW5kZXhoIHx8IDAgKSA/IE1hdGguYWJzKCAoIGluZGV4diB8fCAwICkgLSB5ICkgOiBNYXRoLmFicyggeSAtIG95ICk7XG5cblx0XHRcdFx0XHRcdGlmKCBkaXN0YW5jZVggKyBkaXN0YW5jZVkgPCB2aWV3RGlzdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRcdGxvYWRTbGlkZSggdmVydGljYWxTbGlkZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHVubG9hZFNsaWRlKCB2ZXJ0aWNhbFNsaWRlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyBpZiB0aGVyZSBhcmUgQU5ZIHZlcnRpY2FsIHNsaWRlcywgYW55d2hlcmUgaW4gdGhlIGRlY2tcblx0XHRcdGlmKCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCAnLnNsaWRlcz5zZWN0aW9uPnNlY3Rpb24nICkubGVuZ3RoICkge1xuXHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCAnaGFzLXZlcnRpY2FsLXNsaWRlcycgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAnaGFzLXZlcnRpY2FsLXNsaWRlcycgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyBpZiB0aGVyZSBhcmUgQU5ZIGhvcml6b250YWwgc2xpZGVzLCBhbnl3aGVyZSBpbiB0aGUgZGVja1xuXHRcdFx0aWYoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoICcuc2xpZGVzPnNlY3Rpb24nICkubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LmFkZCggJ2hhcy1ob3Jpem9udGFsLXNsaWRlcycgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCAnaGFzLWhvcml6b250YWwtc2xpZGVzJyApO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUGljayB1cCBub3RlcyBmcm9tIHRoZSBjdXJyZW50IHNsaWRlIGFuZCBkaXNwbGF5IHRoZW1cblx0ICogdG8gdGhlIHZpZXdlci5cblx0ICpcblx0ICogQHNlZSB7QGxpbmsgY29uZmlnLnNob3dOb3Rlc31cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vdGVzKCkge1xuXG5cdFx0aWYoIGNvbmZpZy5zaG93Tm90ZXMgJiYgZG9tLnNwZWFrZXJOb3RlcyAmJiBjdXJyZW50U2xpZGUgJiYgIWlzUHJpbnRpbmdQREYoKSApIHtcblxuXHRcdFx0ZG9tLnNwZWFrZXJOb3Rlcy5pbm5lckhUTUwgPSBnZXRTbGlkZU5vdGVzKCkgfHwgJzxzcGFuIGNsYXNzPVwibm90ZXMtcGxhY2Vob2xkZXJcIj5ObyBub3RlcyBvbiB0aGlzIHNsaWRlLjwvc3Bhbj4nO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3BlYWtlciBub3RlcyBzaWRlYmFyIHRoYXRcblx0ICogaXMgdXNlZCB0byBzaGFyZSBhbm5vdGF0ZWQgc2xpZGVzLiBUaGUgbm90ZXMgc2lkZWJhciBpc1xuXHQgKiBvbmx5IHZpc2libGUgaWYgc2hvd05vdGVzIGlzIHRydWUgYW5kIHRoZXJlIGFyZSBub3RlcyBvblxuXHQgKiBvbmUgb3IgbW9yZSBzbGlkZXMgaW4gdGhlIGRlY2suXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVOb3Rlc1Zpc2liaWxpdHkoKSB7XG5cblx0XHRpZiggY29uZmlnLnNob3dOb3RlcyAmJiBoYXNOb3RlcygpICkge1xuXHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LmFkZCggJ3Nob3ctbm90ZXMnICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSggJ3Nob3ctbm90ZXMnICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZXJlIGFyZSBzcGVha2VyIG5vdGVzIGZvciBBTlkgc2xpZGUgaW4gdGhlXG5cdCAqIHByZXNlbnRhdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc05vdGVzKCkge1xuXG5cdFx0cmV0dXJuIGRvbS5zbGlkZXMucXVlcnlTZWxlY3RvckFsbCggJ1tkYXRhLW5vdGVzXSwgYXNpZGUubm90ZXMnICkubGVuZ3RoID4gMDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHByb2dyZXNzIGJhciB0byByZWZsZWN0IHRoZSBjdXJyZW50IHNsaWRlLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MoKSB7XG5cblx0XHQvLyBVcGRhdGUgcHJvZ3Jlc3MgaWYgZW5hYmxlZFxuXHRcdGlmKCBjb25maWcucHJvZ3Jlc3MgJiYgZG9tLnByb2dyZXNzYmFyICkge1xuXG5cdFx0XHRkb20ucHJvZ3Jlc3NiYXIuc3R5bGUud2lkdGggPSBnZXRQcm9ncmVzcygpICogZG9tLndyYXBwZXIub2Zmc2V0V2lkdGggKyAncHgnO1xuXG5cdFx0fVxuXG5cdH1cblxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBzbGlkZSBudW1iZXIgZGl2IHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgc2xpZGUuXG5cdCAqXG5cdCAqIFRoZSBmb2xsb3dpbmcgc2xpZGUgbnVtYmVyIGZvcm1hdHMgYXJlIGF2YWlsYWJsZTpcblx0ICogIFwiaC52XCI6XHRob3Jpem9udGFsIC4gdmVydGljYWwgc2xpZGUgbnVtYmVyIChkZWZhdWx0KVxuXHQgKiAgXCJoL3ZcIjpcdGhvcml6b250YWwgLyB2ZXJ0aWNhbCBzbGlkZSBudW1iZXJcblx0ICogICAgXCJjXCI6XHRmbGF0dGVuZWQgc2xpZGUgbnVtYmVyXG5cdCAqICBcImMvdFwiOlx0ZmxhdHRlbmVkIHNsaWRlIG51bWJlciAvIHRvdGFsIHNsaWRlc1xuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlU2xpZGVOdW1iZXIoKSB7XG5cblx0XHQvLyBVcGRhdGUgc2xpZGUgbnVtYmVyIGlmIGVuYWJsZWRcblx0XHRpZiggY29uZmlnLnNsaWRlTnVtYmVyICYmIGRvbS5zbGlkZU51bWJlciApIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gW107XG5cdFx0XHR2YXIgZm9ybWF0ID0gJ2gudic7XG5cblx0XHRcdC8vIENoZWNrIGlmIGEgY3VzdG9tIG51bWJlciBmb3JtYXQgaXMgYXZhaWxhYmxlXG5cdFx0XHRpZiggdHlwZW9mIGNvbmZpZy5zbGlkZU51bWJlciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZvcm1hdCA9IGNvbmZpZy5zbGlkZU51bWJlcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIE9OTFkgdmVydGljYWwgc2xpZGVzIGluIHRoaXMgZGVjaywgYWx3YXlzIHVzZVxuXHRcdFx0Ly8gYSBmbGF0dGVuZWQgc2xpZGUgbnVtYmVyXG5cdFx0XHRpZiggIS9jLy50ZXN0KCBmb3JtYXQgKSAmJiBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0Zm9ybWF0ID0gJ2MnO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2goIGZvcm1hdCApIHtcblx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0dmFsdWUucHVzaCggZ2V0U2xpZGVQYXN0Q291bnQoKSArIDEgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnYy90Jzpcblx0XHRcdFx0XHR2YWx1ZS5wdXNoKCBnZXRTbGlkZVBhc3RDb3VudCgpICsgMSwgJy8nLCBnZXRUb3RhbFNsaWRlcygpICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2gvdic6XG5cdFx0XHRcdFx0dmFsdWUucHVzaCggaW5kZXhoICsgMSApO1xuXHRcdFx0XHRcdGlmKCBpc1ZlcnRpY2FsU2xpZGUoKSApIHZhbHVlLnB1c2goICcvJywgaW5kZXh2ICsgMSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHZhbHVlLnB1c2goIGluZGV4aCArIDEgKTtcblx0XHRcdFx0XHRpZiggaXNWZXJ0aWNhbFNsaWRlKCkgKSB2YWx1ZS5wdXNoKCAnLicsIGluZGV4diArIDEgKTtcblx0XHRcdH1cblxuXHRcdFx0ZG9tLnNsaWRlTnVtYmVyLmlubmVySFRNTCA9IGZvcm1hdFNsaWRlTnVtYmVyKCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyBIVE1MIGZvcm1hdHRpbmcgdG8gYSBzbGlkZSBudW1iZXIgYmVmb3JlIGl0J3Ncblx0ICogd3JpdHRlbiB0byB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYSBDdXJyZW50IHNsaWRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkZWxpbWl0ZXIgQ2hhcmFjdGVyIHRvIHNlcGFyYXRlIHNsaWRlIG51bWJlcnNcblx0ICogQHBhcmFtIHsobnVtYmVyfCopfSBiIFRvdGFsIHNsaWRlc1xuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgc3RyaW5nIGZyYWdtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXRTbGlkZU51bWJlciggYSwgZGVsaW1pdGVyLCBiICkge1xuXG5cdFx0dmFyIHVybCA9ICcjJyArIGxvY2F0aW9uSGFzaCgpO1xuXHRcdGlmKCB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKCBiICkgKSB7XG5cdFx0XHRyZXR1cm4gICc8YSBocmVmPVwiJyArIHVybCArICdcIj4nICtcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJzbGlkZS1udW1iZXItYVwiPicrIGEgKyc8L3NwYW4+JyArXG5cdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwic2xpZGUtbnVtYmVyLWRlbGltaXRlclwiPicrIGRlbGltaXRlciArJzwvc3Bhbj4nICtcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJzbGlkZS1udW1iZXItYlwiPicrIGIgKyc8L3NwYW4+JyArXG5cdFx0XHRcdFx0JzwvYT4nO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+JyArXG5cdFx0XHQgICAgICAgJzxzcGFuIGNsYXNzPVwic2xpZGUtbnVtYmVyLWFcIj4nKyBhICsnPC9zcGFuPicgK1xuXHRcdFx0ICAgICAgICc8L2E+Jztcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgY29udHJvbC9uYXZpZ2F0aW9uIGFycm93cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xzKCkge1xuXG5cdFx0dmFyIHJvdXRlcyA9IGF2YWlsYWJsZVJvdXRlcygpO1xuXHRcdHZhciBmcmFnbWVudHMgPSBhdmFpbGFibGVGcmFnbWVudHMoKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgJ2VuYWJsZWQnIGNsYXNzIGZyb20gYWxsIGRpcmVjdGlvbnNcblx0XHRkb20uY29udHJvbHNMZWZ0LmNvbmNhdCggZG9tLmNvbnRyb2xzUmlnaHQgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggZG9tLmNvbnRyb2xzVXAgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggZG9tLmNvbnRyb2xzRG93biApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCBkb20uY29udHJvbHNQcmV2IClcblx0XHRcdFx0XHRcdC5jb25jYXQoIGRvbS5jb250cm9sc05leHQgKS5mb3JFYWNoKCBmdW5jdGlvbiggbm9kZSApIHtcblx0XHRcdG5vZGUuY2xhc3NMaXN0LnJlbW92ZSggJ2VuYWJsZWQnICk7XG5cdFx0XHRub2RlLmNsYXNzTGlzdC5yZW1vdmUoICdmcmFnbWVudGVkJyApO1xuXG5cdFx0XHQvLyBTZXQgJ2Rpc2FibGVkJyBhdHRyaWJ1dGUgb24gYWxsIGRpcmVjdGlvbnNcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCAnZGlzYWJsZWQnLCAnZGlzYWJsZWQnICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQWRkIHRoZSAnZW5hYmxlZCcgY2xhc3MgdG8gdGhlIGF2YWlsYWJsZSByb3V0ZXM7IHJlbW92ZSAnZGlzYWJsZWQnIGF0dHJpYnV0ZSB0byBlbmFibGUgYnV0dG9uc1xuXHRcdGlmKCByb3V0ZXMubGVmdCApIGRvbS5jb250cm9sc0xlZnQuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZW5hYmxlZCcgKTsgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGlzYWJsZWQnICk7IH0gKTtcblx0XHRpZiggcm91dGVzLnJpZ2h0ICkgZG9tLmNvbnRyb2xzUmlnaHQuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZW5hYmxlZCcgKTsgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGlzYWJsZWQnICk7IH0gKTtcblx0XHRpZiggcm91dGVzLnVwICkgZG9tLmNvbnRyb2xzVXAuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZW5hYmxlZCcgKTsgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGlzYWJsZWQnICk7IH0gKTtcblx0XHRpZiggcm91dGVzLmRvd24gKSBkb20uY29udHJvbHNEb3duLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwuY2xhc3NMaXN0LmFkZCggJ2VuYWJsZWQnICk7IGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApOyB9ICk7XG5cblx0XHQvLyBQcmV2L25leHQgYnV0dG9uc1xuXHRcdGlmKCByb3V0ZXMubGVmdCB8fCByb3V0ZXMudXAgKSBkb20uY29udHJvbHNQcmV2LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwuY2xhc3NMaXN0LmFkZCggJ2VuYWJsZWQnICk7IGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApOyB9ICk7XG5cdFx0aWYoIHJvdXRlcy5yaWdodCB8fCByb3V0ZXMuZG93biApIGRvbS5jb250cm9sc05leHQuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZW5hYmxlZCcgKTsgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGlzYWJsZWQnICk7IH0gKTtcblxuXHRcdC8vIEhpZ2hsaWdodCBmcmFnbWVudCBkaXJlY3Rpb25zXG5cdFx0aWYoIGN1cnJlbnRTbGlkZSApIHtcblxuXHRcdFx0Ly8gQWx3YXlzIGFwcGx5IGZyYWdtZW50IGRlY29yYXRvciB0byBwcmV2L25leHQgYnV0dG9uc1xuXHRcdFx0aWYoIGZyYWdtZW50cy5wcmV2ICkgZG9tLmNvbnRyb2xzUHJldi5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmNsYXNzTGlzdC5hZGQoICdmcmFnbWVudGVkJywgJ2VuYWJsZWQnICk7IGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApOyB9ICk7XG5cdFx0XHRpZiggZnJhZ21lbnRzLm5leHQgKSBkb20uY29udHJvbHNOZXh0LmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHsgZWwuY2xhc3NMaXN0LmFkZCggJ2ZyYWdtZW50ZWQnLCAnZW5hYmxlZCcgKTsgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGlzYWJsZWQnICk7IH0gKTtcblxuXHRcdFx0Ly8gQXBwbHkgZnJhZ21lbnQgZGVjb3JhdG9ycyB0byBkaXJlY3Rpb25hbCBidXR0b25zIGJhc2VkIG9uXG5cdFx0XHQvLyB3aGF0IHNsaWRlIGF4aXMgdGhleSBhcmUgaW5cblx0XHRcdGlmKCBpc1ZlcnRpY2FsU2xpZGUoIGN1cnJlbnRTbGlkZSApICkge1xuXHRcdFx0XHRpZiggZnJhZ21lbnRzLnByZXYgKSBkb20uY29udHJvbHNVcC5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmNsYXNzTGlzdC5hZGQoICdmcmFnbWVudGVkJywgJ2VuYWJsZWQnICk7IGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApOyB9ICk7XG5cdFx0XHRcdGlmKCBmcmFnbWVudHMubmV4dCApIGRvbS5jb250cm9sc0Rvd24uZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZnJhZ21lbnRlZCcsICdlbmFibGVkJyApOyBlbC5yZW1vdmVBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKTsgfSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmKCBmcmFnbWVudHMucHJldiApIGRvbS5jb250cm9sc0xlZnQuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkgeyBlbC5jbGFzc0xpc3QuYWRkKCAnZnJhZ21lbnRlZCcsICdlbmFibGVkJyApOyBlbC5yZW1vdmVBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKTsgfSApO1xuXHRcdFx0XHRpZiggZnJhZ21lbnRzLm5leHQgKSBkb20uY29udHJvbHNSaWdodC5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7IGVsLmNsYXNzTGlzdC5hZGQoICdmcmFnbWVudGVkJywgJ2VuYWJsZWQnICk7IGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApOyB9ICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiggY29uZmlnLmNvbnRyb2xzVHV0b3JpYWwgKSB7XG5cblx0XHRcdC8vIEhpZ2hsaWdodCBjb250cm9sIGFycm93cyB3aXRoIGFuIGFuaW1hdGlvbiB0byBlbnN1cmVcblx0XHRcdC8vIHRoYXQgdGhlIHZpZXdlciBrbm93cyBob3cgdG8gbmF2aWdhdGVcblx0XHRcdGlmKCAhaGFzTmF2aWdhdGVkRG93biAmJiByb3V0ZXMuZG93biApIHtcblx0XHRcdFx0ZG9tLmNvbnRyb2xzRG93bkFycm93LmNsYXNzTGlzdC5hZGQoICdoaWdobGlnaHQnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZG9tLmNvbnRyb2xzRG93bkFycm93LmNsYXNzTGlzdC5yZW1vdmUoICdoaWdobGlnaHQnICk7XG5cblx0XHRcdFx0aWYoICFoYXNOYXZpZ2F0ZWRSaWdodCAmJiByb3V0ZXMucmlnaHQgJiYgaW5kZXh2ID09PSAwICkge1xuXHRcdFx0XHRcdGRvbS5jb250cm9sc1JpZ2h0QXJyb3cuY2xhc3NMaXN0LmFkZCggJ2hpZ2hsaWdodCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkb20uY29udHJvbHNSaWdodEFycm93LmNsYXNzTGlzdC5yZW1vdmUoICdoaWdobGlnaHQnICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGJhY2tncm91bmQgZWxlbWVudHMgdG8gcmVmbGVjdCB0aGUgY3VycmVudFxuXHQgKiBzbGlkZS5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQWxsIElmIHRydWUsIHRoZSBiYWNrZ3JvdW5kcyBvZlxuXHQgKiBhbGwgdmVydGljYWwgc2xpZGVzIChub3QganVzdCB0aGUgcHJlc2VudCkgd2lsbCBiZSB1cGRhdGVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlQmFja2dyb3VuZCggaW5jbHVkZUFsbCApIHtcblxuXHRcdHZhciBjdXJyZW50QmFja2dyb3VuZCA9IG51bGw7XG5cblx0XHQvLyBSZXZlcnNlIHBhc3QvZnV0dXJlIGNsYXNzZXMgd2hlbiBpbiBSVEwgbW9kZVxuXHRcdHZhciBob3Jpem9udGFsUGFzdCA9IGNvbmZpZy5ydGwgPyAnZnV0dXJlJyA6ICdwYXN0Jyxcblx0XHRcdGhvcml6b250YWxGdXR1cmUgPSBjb25maWcucnRsID8gJ3Bhc3QnIDogJ2Z1dHVyZSc7XG5cblx0XHQvLyBVcGRhdGUgdGhlIGNsYXNzZXMgb2YgYWxsIGJhY2tncm91bmRzIHRvIG1hdGNoIHRoZVxuXHRcdC8vIHN0YXRlcyBvZiB0aGVpciBzbGlkZXMgKHBhc3QvcHJlc2VudC9mdXR1cmUpXG5cdFx0dG9BcnJheSggZG9tLmJhY2tncm91bmQuY2hpbGROb2RlcyApLmZvckVhY2goIGZ1bmN0aW9uKCBiYWNrZ3JvdW5kaCwgaCApIHtcblxuXHRcdFx0YmFja2dyb3VuZGguY2xhc3NMaXN0LnJlbW92ZSggJ3Bhc3QnICk7XG5cdFx0XHRiYWNrZ3JvdW5kaC5jbGFzc0xpc3QucmVtb3ZlKCAncHJlc2VudCcgKTtcblx0XHRcdGJhY2tncm91bmRoLmNsYXNzTGlzdC5yZW1vdmUoICdmdXR1cmUnICk7XG5cblx0XHRcdGlmKCBoIDwgaW5kZXhoICkge1xuXHRcdFx0XHRiYWNrZ3JvdW5kaC5jbGFzc0xpc3QuYWRkKCBob3Jpem9udGFsUGFzdCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGggPiBpbmRleGggKSB7XG5cdFx0XHRcdGJhY2tncm91bmRoLmNsYXNzTGlzdC5hZGQoIGhvcml6b250YWxGdXR1cmUgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRiYWNrZ3JvdW5kaC5jbGFzc0xpc3QuYWRkKCAncHJlc2VudCcgKTtcblxuXHRcdFx0XHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBiYWNrZ3JvdW5kIGVsZW1lbnRcblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kaDtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGluY2x1ZGVBbGwgfHwgaCA9PT0gaW5kZXhoICkge1xuXHRcdFx0XHR0b0FycmF5KCBiYWNrZ3JvdW5kaC5xdWVyeVNlbGVjdG9yQWxsKCAnLnNsaWRlLWJhY2tncm91bmQnICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggYmFja2dyb3VuZHYsIHYgKSB7XG5cblx0XHRcdFx0XHRiYWNrZ3JvdW5kdi5jbGFzc0xpc3QucmVtb3ZlKCAncGFzdCcgKTtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kdi5jbGFzc0xpc3QucmVtb3ZlKCAncHJlc2VudCcgKTtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kdi5jbGFzc0xpc3QucmVtb3ZlKCAnZnV0dXJlJyApO1xuXG5cdFx0XHRcdFx0aWYoIHYgPCBpbmRleHYgKSB7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kdi5jbGFzc0xpc3QuYWRkKCAncGFzdCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHYgPiBpbmRleHYgKSB7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kdi5jbGFzc0xpc3QuYWRkKCAnZnV0dXJlJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGJhY2tncm91bmR2LmNsYXNzTGlzdC5hZGQoICdwcmVzZW50JyApO1xuXG5cdFx0XHRcdFx0XHQvLyBPbmx5IGlmIHRoaXMgaXMgdGhlIHByZXNlbnQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2xpZGVcblx0XHRcdFx0XHRcdGlmKCBoID09PSBpbmRleGggKSBjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmR2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHQvLyBTdG9wIGNvbnRlbnQgaW5zaWRlIG9mIHByZXZpb3VzIGJhY2tncm91bmRzXG5cdFx0aWYoIHByZXZpb3VzQmFja2dyb3VuZCApIHtcblxuXHRcdFx0c3RvcEVtYmVkZGVkQ29udGVudCggcHJldmlvdXNCYWNrZ3JvdW5kICk7XG5cblx0XHR9XG5cblx0XHQvLyBTdGFydCBjb250ZW50IGluIHRoZSBjdXJyZW50IGJhY2tncm91bmRcblx0XHRpZiggY3VycmVudEJhY2tncm91bmQgKSB7XG5cblx0XHRcdHN0YXJ0RW1iZWRkZWRDb250ZW50KCBjdXJyZW50QmFja2dyb3VuZCApO1xuXG5cdFx0XHR2YXIgY3VycmVudEJhY2tncm91bmRDb250ZW50ID0gY3VycmVudEJhY2tncm91bmQucXVlcnlTZWxlY3RvciggJy5zbGlkZS1iYWNrZ3JvdW5kLWNvbnRlbnQnICk7XG5cdFx0XHRpZiggY3VycmVudEJhY2tncm91bmRDb250ZW50ICkge1xuXG5cdFx0XHRcdHZhciBiYWNrZ3JvdW5kSW1hZ2VVUkwgPSBjdXJyZW50QmFja2dyb3VuZENvbnRlbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlIHx8ICcnO1xuXG5cdFx0XHRcdC8vIFJlc3RhcnQgR0lGcyAoZG9lc24ndCB3b3JrIGluIEZpcmVmb3gpXG5cdFx0XHRcdGlmKCAvXFwuZ2lmL2kudGVzdCggYmFja2dyb3VuZEltYWdlVVJMICkgKSB7XG5cdFx0XHRcdFx0Y3VycmVudEJhY2tncm91bmRDb250ZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICcnO1xuXHRcdFx0XHRcdHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjdXJyZW50QmFja2dyb3VuZENvbnRlbnQgKS5vcGFjaXR5O1xuXHRcdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kQ29udGVudC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2VVUkw7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBEb24ndCB0cmFuc2l0aW9uIGJldHdlZW4gaWRlbnRpY2FsIGJhY2tncm91bmRzLiBUaGlzXG5cdFx0XHQvLyBwcmV2ZW50cyB1bndhbnRlZCBmbGlja2VyLlxuXHRcdFx0dmFyIHByZXZpb3VzQmFja2dyb3VuZEhhc2ggPSBwcmV2aW91c0JhY2tncm91bmQgPyBwcmV2aW91c0JhY2tncm91bmQuZ2V0QXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLWhhc2gnICkgOiBudWxsO1xuXHRcdFx0dmFyIGN1cnJlbnRCYWNrZ3JvdW5kSGFzaCA9IGN1cnJlbnRCYWNrZ3JvdW5kLmdldEF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC1oYXNoJyApO1xuXHRcdFx0aWYoIGN1cnJlbnRCYWNrZ3JvdW5kSGFzaCAmJiBjdXJyZW50QmFja2dyb3VuZEhhc2ggPT09IHByZXZpb3VzQmFja2dyb3VuZEhhc2ggJiYgY3VycmVudEJhY2tncm91bmQgIT09IHByZXZpb3VzQmFja2dyb3VuZCApIHtcblx0XHRcdFx0ZG9tLmJhY2tncm91bmQuY2xhc3NMaXN0LmFkZCggJ25vLXRyYW5zaXRpb24nICk7XG5cdFx0XHR9XG5cblx0XHRcdHByZXZpb3VzQmFja2dyb3VuZCA9IGN1cnJlbnRCYWNrZ3JvdW5kO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUncyBhIGJhY2tncm91bmQgYnJpZ2h0bmVzcyBmbGFnIGZvciB0aGlzIHNsaWRlLFxuXHRcdC8vIGJ1YmJsZSBpdCB0byB0aGUgLnJldmVhbCBjb250YWluZXJcblx0XHRpZiggY3VycmVudFNsaWRlICkge1xuXHRcdFx0WyAnaGFzLWxpZ2h0LWJhY2tncm91bmQnLCAnaGFzLWRhcmstYmFja2dyb3VuZCcgXS5mb3JFYWNoKCBmdW5jdGlvbiggY2xhc3NUb0J1YmJsZSApIHtcblx0XHRcdFx0aWYoIGN1cnJlbnRTbGlkZS5jbGFzc0xpc3QuY29udGFpbnMoIGNsYXNzVG9CdWJibGUgKSApIHtcblx0XHRcdFx0XHRkb20ud3JhcHBlci5jbGFzc0xpc3QuYWRkKCBjbGFzc1RvQnViYmxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZG9tLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSggY2xhc3NUb0J1YmJsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgdGhlIGZpcnN0IGJhY2tncm91bmQgdG8gYXBwbHkgd2l0aG91dCB0cmFuc2l0aW9uXG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkb20uYmFja2dyb3VuZC5jbGFzc0xpc3QucmVtb3ZlKCAnbm8tdHJhbnNpdGlvbicgKTtcblx0XHR9LCAxICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFyYWxsYXggYmFja2dyb3VuZCBiYXNlZFxuXHQgKiBvbiB0aGUgY3VycmVudCBzbGlkZSBpbmRleC5cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZVBhcmFsbGF4KCkge1xuXG5cdFx0aWYoIGNvbmZpZy5wYXJhbGxheEJhY2tncm91bmRJbWFnZSApIHtcblxuXHRcdFx0dmFyIGhvcml6b250YWxTbGlkZXMgPSBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApLFxuXHRcdFx0XHR2ZXJ0aWNhbFNsaWRlcyA9IGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFZFUlRJQ0FMX1NMSURFU19TRUxFQ1RPUiApO1xuXG5cdFx0XHR2YXIgYmFja2dyb3VuZFNpemUgPSBkb20uYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZS5zcGxpdCggJyAnICksXG5cdFx0XHRcdGJhY2tncm91bmRXaWR0aCwgYmFja2dyb3VuZEhlaWdodDtcblxuXHRcdFx0aWYoIGJhY2tncm91bmRTaXplLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0YmFja2dyb3VuZFdpZHRoID0gYmFja2dyb3VuZEhlaWdodCA9IHBhcnNlSW50KCBiYWNrZ3JvdW5kU2l6ZVswXSwgMTAgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRiYWNrZ3JvdW5kV2lkdGggPSBwYXJzZUludCggYmFja2dyb3VuZFNpemVbMF0sIDEwICk7XG5cdFx0XHRcdGJhY2tncm91bmRIZWlnaHQgPSBwYXJzZUludCggYmFja2dyb3VuZFNpemVbMV0sIDEwICk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzbGlkZVdpZHRoID0gZG9tLmJhY2tncm91bmQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdGhvcml6b250YWxTbGlkZUNvdW50ID0gaG9yaXpvbnRhbFNsaWRlcy5sZW5ndGgsXG5cdFx0XHRcdGhvcml6b250YWxPZmZzZXRNdWx0aXBsaWVyLFxuXHRcdFx0XHRob3Jpem9udGFsT2Zmc2V0O1xuXG5cdFx0XHRpZiggdHlwZW9mIGNvbmZpZy5wYXJhbGxheEJhY2tncm91bmRIb3Jpem9udGFsID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0aG9yaXpvbnRhbE9mZnNldE11bHRpcGxpZXIgPSBjb25maWcucGFyYWxsYXhCYWNrZ3JvdW5kSG9yaXpvbnRhbDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRob3Jpem9udGFsT2Zmc2V0TXVsdGlwbGllciA9IGhvcml6b250YWxTbGlkZUNvdW50ID4gMSA/ICggYmFja2dyb3VuZFdpZHRoIC0gc2xpZGVXaWR0aCApIC8gKCBob3Jpem9udGFsU2xpZGVDb3VudC0xICkgOiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRob3Jpem9udGFsT2Zmc2V0ID0gaG9yaXpvbnRhbE9mZnNldE11bHRpcGxpZXIgKiBpbmRleGggKiAtMTtcblxuXHRcdFx0dmFyIHNsaWRlSGVpZ2h0ID0gZG9tLmJhY2tncm91bmQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHR2ZXJ0aWNhbFNsaWRlQ291bnQgPSB2ZXJ0aWNhbFNsaWRlcy5sZW5ndGgsXG5cdFx0XHRcdHZlcnRpY2FsT2Zmc2V0TXVsdGlwbGllcixcblx0XHRcdFx0dmVydGljYWxPZmZzZXQ7XG5cblx0XHRcdGlmKCB0eXBlb2YgY29uZmlnLnBhcmFsbGF4QmFja2dyb3VuZFZlcnRpY2FsID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0dmVydGljYWxPZmZzZXRNdWx0aXBsaWVyID0gY29uZmlnLnBhcmFsbGF4QmFja2dyb3VuZFZlcnRpY2FsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZlcnRpY2FsT2Zmc2V0TXVsdGlwbGllciA9ICggYmFja2dyb3VuZEhlaWdodCAtIHNsaWRlSGVpZ2h0ICkgLyAoIHZlcnRpY2FsU2xpZGVDb3VudC0xICk7XG5cdFx0XHR9XG5cblx0XHRcdHZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxTbGlkZUNvdW50ID4gMCA/ICB2ZXJ0aWNhbE9mZnNldE11bHRpcGxpZXIgKiBpbmRleHYgOiAwO1xuXG5cdFx0XHRkb20uYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBob3Jpem9udGFsT2Zmc2V0ICsgJ3B4ICcgKyAtdmVydGljYWxPZmZzZXQgKyAncHgnO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGdpdmVuIHNsaWRlIGlzIHdpdGhpbiB0aGUgY29uZmlndXJlZCB2aWV3XG5cdCAqIGRpc3RhbmNlLiBTaG93cyB0aGUgc2xpZGUgZWxlbWVudCBhbmQgbG9hZHMgYW55IGNvbnRlbnRcblx0ICogdGhhdCBpcyBzZXQgdG8gbG9hZCBsYXppbHkgKGRhdGEtc3JjKS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2xpZGUgU2xpZGUgdG8gc2hvd1xuXHQgKi9cblx0ZnVuY3Rpb24gbG9hZFNsaWRlKCBzbGlkZSwgb3B0aW9ucyApIHtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gU2hvdyB0aGUgc2xpZGUgZWxlbWVudFxuXHRcdHNsaWRlLnN0eWxlLmRpc3BsYXkgPSBjb25maWcuZGlzcGxheTtcblxuXHRcdC8vIE1lZGlhIGVsZW1lbnRzIHdpdGggZGF0YS1zcmMgYXR0cmlidXRlc1xuXHRcdHRvQXJyYXkoIHNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICdpbWdbZGF0YS1zcmNdLCB2aWRlb1tkYXRhLXNyY10sIGF1ZGlvW2RhdGEtc3JjXScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoICdzcmMnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJyApICk7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSggJ2RhdGEtbGF6eS1sb2FkZWQnLCAnJyApO1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLXNyYycgKTtcblx0XHR9ICk7XG5cblx0XHQvLyBNZWRpYSBlbGVtZW50cyB3aXRoIDxzb3VyY2U+IGNoaWxkcmVuXG5cdFx0dG9BcnJheSggc2xpZGUucXVlcnlTZWxlY3RvckFsbCggJ3ZpZGVvLCBhdWRpbycgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBtZWRpYSApIHtcblx0XHRcdHZhciBzb3VyY2VzID0gMDtcblxuXHRcdFx0dG9BcnJheSggbWVkaWEucXVlcnlTZWxlY3RvckFsbCggJ3NvdXJjZVtkYXRhLXNyY10nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggc291cmNlICkge1xuXHRcdFx0XHRzb3VyY2Uuc2V0QXR0cmlidXRlKCAnc3JjJywgc291cmNlLmdldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJyApICk7XG5cdFx0XHRcdHNvdXJjZS5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLXNyYycgKTtcblx0XHRcdFx0c291cmNlLnNldEF0dHJpYnV0ZSggJ2RhdGEtbGF6eS1sb2FkZWQnLCAnJyApO1xuXHRcdFx0XHRzb3VyY2VzICs9IDE7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIElmIHdlIHJld3JvdGUgc291cmNlcyBmb3IgdGhpcyB2aWRlby9hdWRpbyBlbGVtZW50LCB3ZSBuZWVkXG5cdFx0XHQvLyB0byBtYW51YWxseSB0ZWxsIGl0IHRvIGxvYWQgZnJvbSBpdHMgbmV3IG9yaWdpblxuXHRcdFx0aWYoIHNvdXJjZXMgPiAwICkge1xuXHRcdFx0XHRtZWRpYS5sb2FkKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cblx0XHQvLyBTaG93IHRoZSBjb3JyZXNwb25kaW5nIGJhY2tncm91bmQgZWxlbWVudFxuXHRcdHZhciBiYWNrZ3JvdW5kID0gc2xpZGUuc2xpZGVCYWNrZ3JvdW5kRWxlbWVudDtcblx0XHRpZiggYmFja2dyb3VuZCApIHtcblx0XHRcdGJhY2tncm91bmQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cblx0XHRcdHZhciBiYWNrZ3JvdW5kQ29udGVudCA9IHNsaWRlLnNsaWRlQmFja2dyb3VuZENvbnRlbnRFbGVtZW50O1xuXG5cdFx0XHQvLyBJZiB0aGUgYmFja2dyb3VuZCBjb250YWlucyBtZWRpYSwgbG9hZCBpdFxuXHRcdFx0aWYoIGJhY2tncm91bmQuaGFzQXR0cmlidXRlKCAnZGF0YS1sb2FkZWQnICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRiYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSggJ2RhdGEtbG9hZGVkJywgJ3RydWUnICk7XG5cblx0XHRcdFx0dmFyIGJhY2tncm91bmRJbWFnZSA9IHNsaWRlLmdldEF0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC1pbWFnZScgKSxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kVmlkZW8gPSBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtdmlkZW8nICksXG5cdFx0XHRcdFx0YmFja2dyb3VuZFZpZGVvTG9vcCA9IHNsaWRlLmhhc0F0dHJpYnV0ZSggJ2RhdGEtYmFja2dyb3VuZC12aWRlby1sb29wJyApLFxuXHRcdFx0XHRcdGJhY2tncm91bmRWaWRlb011dGVkID0gc2xpZGUuaGFzQXR0cmlidXRlKCAnZGF0YS1iYWNrZ3JvdW5kLXZpZGVvLW11dGVkJyApLFxuXHRcdFx0XHRcdGJhY2tncm91bmRJZnJhbWUgPSBzbGlkZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWJhY2tncm91bmQtaWZyYW1lJyApO1xuXG5cdFx0XHRcdC8vIEltYWdlc1xuXHRcdFx0XHRpZiggYmFja2dyb3VuZEltYWdlICkge1xuXHRcdFx0XHRcdGJhY2tncm91bmRDb250ZW50LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJysgZW5jb2RlVVJJKCBiYWNrZ3JvdW5kSW1hZ2UgKSArJyknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFZpZGVvc1xuXHRcdFx0XHRlbHNlIGlmICggYmFja2dyb3VuZFZpZGVvICYmICFpc1NwZWFrZXJOb3RlcygpICkge1xuXHRcdFx0XHRcdHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICd2aWRlbycgKTtcblxuXHRcdFx0XHRcdGlmKCBiYWNrZ3JvdW5kVmlkZW9Mb29wICkge1xuXHRcdFx0XHRcdFx0dmlkZW8uc2V0QXR0cmlidXRlKCAnbG9vcCcsICcnICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIGJhY2tncm91bmRWaWRlb011dGVkICkge1xuXHRcdFx0XHRcdFx0dmlkZW8ubXV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElubGluZSB2aWRlbyBwbGF5YmFjayB3b3JrcyAoYXQgbGVhc3QgaW4gTW9iaWxlIFNhZmFyaSkgYXNcblx0XHRcdFx0XHQvLyBsb25nIGFzIHRoZSB2aWRlbyBpcyBtdXRlZCBhbmQgdGhlIGBwbGF5c2lubGluZWAgYXR0cmlidXRlIGlzXG5cdFx0XHRcdFx0Ly8gcHJlc2VudFxuXHRcdFx0XHRcdGlmKCBpc01vYmlsZURldmljZSApIHtcblx0XHRcdFx0XHRcdHZpZGVvLm11dGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZpZGVvLnNldEF0dHJpYnV0ZSggJ3BsYXlzaW5saW5lJywgJycgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0IGNvbW1hIHNlcGFyYXRlZCBsaXN0cyBvZiB2aWRlbyBzb3VyY2VzXG5cdFx0XHRcdFx0YmFja2dyb3VuZFZpZGVvLnNwbGl0KCAnLCcgKS5mb3JFYWNoKCBmdW5jdGlvbiggc291cmNlICkge1xuXHRcdFx0XHRcdFx0dmlkZW8uaW5uZXJIVE1MICs9ICc8c291cmNlIHNyYz1cIicrIHNvdXJjZSArJ1wiPic7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbnRlbnQuYXBwZW5kQ2hpbGQoIHZpZGVvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWZyYW1lc1xuXHRcdFx0XHRlbHNlIGlmKCBiYWNrZ3JvdW5kSWZyYW1lICYmIG9wdGlvbnMuZXhjbHVkZUlmcmFtZXMgIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpZnJhbWUnICk7XG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSggJ2FsbG93ZnVsbHNjcmVlbicsICcnICk7XG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSggJ21vemFsbG93ZnVsbHNjcmVlbicsICcnICk7XG5cdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSggJ3dlYmtpdGFsbG93ZnVsbHNjcmVlbicsICcnICk7XG5cblx0XHRcdFx0XHQvLyBPbmx5IGxvYWQgYXV0b3BsYXlpbmcgY29udGVudCB3aGVuIHRoZSBzbGlkZSBpcyBzaG93biB0b1xuXHRcdFx0XHRcdC8vIGF2b2lkIGhhdmluZyBpdCBwbGF5IGluIHRoZSBiYWNrZ3JvdW5kXG5cdFx0XHRcdFx0aWYoIC9hdXRvcGxheT0oMXx0cnVlfHllcykvZ2kudGVzdCggYmFja2dyb3VuZElmcmFtZSApICkge1xuXHRcdFx0XHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJywgYmFja2dyb3VuZElmcmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmcmFtZS5zZXRBdHRyaWJ1dGUoICdzcmMnLCBiYWNrZ3JvdW5kSWZyYW1lICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWZyYW1lLnN0eWxlLndpZHRoICA9ICcxMDAlJztcblx0XHRcdFx0XHRpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdFx0XHRcdGlmcmFtZS5zdHlsZS5tYXhIZWlnaHQgPSAnMTAwJSc7XG5cdFx0XHRcdFx0aWZyYW1lLnN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbnRlbnQuYXBwZW5kQ2hpbGQoIGlmcmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmxvYWRzIGFuZCBoaWRlcyB0aGUgZ2l2ZW4gc2xpZGUuIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlXG5cdCAqIHNsaWRlIGlzIG1vdmVkIG91dHNpZGUgb2YgdGhlIGNvbmZpZ3VyZWQgdmlldyBkaXN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2xpZGVcblx0ICovXG5cdGZ1bmN0aW9uIHVubG9hZFNsaWRlKCBzbGlkZSApIHtcblxuXHRcdC8vIEhpZGUgdGhlIHNsaWRlIGVsZW1lbnRcblx0XHRzbGlkZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0Ly8gSGlkZSB0aGUgY29ycmVzcG9uZGluZyBiYWNrZ3JvdW5kIGVsZW1lbnRcblx0XHR2YXIgYmFja2dyb3VuZCA9IGdldFNsaWRlQmFja2dyb3VuZCggc2xpZGUgKTtcblx0XHRpZiggYmFja2dyb3VuZCApIHtcblx0XHRcdGJhY2tncm91bmQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHR9XG5cblx0XHQvLyBSZXNldCBsYXp5LWxvYWRlZCBtZWRpYSBlbGVtZW50cyB3aXRoIHNyYyBhdHRyaWJ1dGVzXG5cdFx0dG9BcnJheSggc2xpZGUucXVlcnlTZWxlY3RvckFsbCggJ3ZpZGVvW2RhdGEtbGF6eS1sb2FkZWRdW3NyY10sIGF1ZGlvW2RhdGEtbGF6eS1sb2FkZWRdW3NyY10nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnZGF0YS1zcmMnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NyYycgKSApO1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoICdzcmMnICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVzZXQgbGF6eS1sb2FkZWQgbWVkaWEgZWxlbWVudHMgd2l0aCA8c291cmNlPiBjaGlsZHJlblxuXHRcdHRvQXJyYXkoIHNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICd2aWRlb1tkYXRhLWxhenktbG9hZGVkXSBzb3VyY2Vbc3JjXSwgYXVkaW8gc291cmNlW3NyY10nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggc291cmNlICkge1xuXHRcdFx0c291cmNlLnNldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJywgc291cmNlLmdldEF0dHJpYnV0ZSggJ3NyYycgKSApO1xuXHRcdFx0c291cmNlLnJlbW92ZUF0dHJpYnV0ZSggJ3NyYycgKTtcblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hhdCBhdmFpbGFibGUgcm91dGVzIHRoZXJlIGFyZSBmb3IgbmF2aWdhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7e2xlZnQ6IGJvb2xlYW4sIHJpZ2h0OiBib29sZWFuLCB1cDogYm9vbGVhbiwgZG93bjogYm9vbGVhbn19XG5cdCAqL1xuXHRmdW5jdGlvbiBhdmFpbGFibGVSb3V0ZXMoKSB7XG5cblx0XHR2YXIgaG9yaXpvbnRhbFNsaWRlcyA9IGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICksXG5cdFx0XHR2ZXJ0aWNhbFNsaWRlcyA9IGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIFZFUlRJQ0FMX1NMSURFU19TRUxFQ1RPUiApO1xuXG5cdFx0dmFyIHJvdXRlcyA9IHtcblx0XHRcdGxlZnQ6IGluZGV4aCA+IDAsXG5cdFx0XHRyaWdodDogaW5kZXhoIDwgaG9yaXpvbnRhbFNsaWRlcy5sZW5ndGggLSAxLFxuXHRcdFx0dXA6IGluZGV4diA+IDAsXG5cdFx0XHRkb3duOiBpbmRleHYgPCB2ZXJ0aWNhbFNsaWRlcy5sZW5ndGggLSAxXG5cdFx0fTtcblxuXHRcdC8vIExvb3BlZCBwcmVzZW50YXRpb25zIGNhbiBhbHdheXMgYmUgbmF2aWdhdGVkIGFzIGxvbmcgYXNcblx0XHQvLyB0aGVyZSBhcmUgc2xpZGVzIGF2YWlsYWJsZVxuXHRcdGlmKCBjb25maWcubG9vcCApIHtcblx0XHRcdGlmKCBob3Jpem9udGFsU2xpZGVzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdHJvdXRlcy5sZWZ0ID0gdHJ1ZTtcblx0XHRcdFx0cm91dGVzLnJpZ2h0ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIHZlcnRpY2FsU2xpZGVzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdHJvdXRlcy51cCA9IHRydWU7XG5cdFx0XHRcdHJvdXRlcy5kb3duID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXZlcnNlIGhvcml6b250YWwgY29udHJvbHMgZm9yIHJ0bFxuXHRcdGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0dmFyIGxlZnQgPSByb3V0ZXMubGVmdDtcblx0XHRcdHJvdXRlcy5sZWZ0ID0gcm91dGVzLnJpZ2h0O1xuXHRcdFx0cm91dGVzLnJpZ2h0ID0gbGVmdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm91dGVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgYXZhaWxhYmxlIGZyYWdtZW50XG5cdCAqIGRpcmVjdGlvbnMuXG5cdCAqXG5cdCAqIEByZXR1cm4ge3twcmV2OiBib29sZWFuLCBuZXh0OiBib29sZWFufX1cblx0ICovXG5cdGZ1bmN0aW9uIGF2YWlsYWJsZUZyYWdtZW50cygpIHtcblxuXHRcdGlmKCBjdXJyZW50U2xpZGUgJiYgY29uZmlnLmZyYWdtZW50cyApIHtcblx0XHRcdHZhciBmcmFnbWVudHMgPSBjdXJyZW50U2xpZGUucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudCcgKTtcblx0XHRcdHZhciBoaWRkZW5GcmFnbWVudHMgPSBjdXJyZW50U2xpZGUucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudDpub3QoLnZpc2libGUpJyApO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwcmV2OiBmcmFnbWVudHMubGVuZ3RoIC0gaGlkZGVuRnJhZ21lbnRzLmxlbmd0aCA+IDAsXG5cdFx0XHRcdG5leHQ6ICEhaGlkZGVuRnJhZ21lbnRzLmxlbmd0aFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4geyBwcmV2OiBmYWxzZSwgbmV4dDogZmFsc2UgfTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmZvcmNlcyBvcmlnaW4tc3BlY2lmaWMgZm9ybWF0IHJ1bGVzIGZvciBlbWJlZGRlZCBtZWRpYS5cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdEVtYmVkZGVkQ29udGVudCgpIHtcblxuXHRcdHZhciBfYXBwZW5kUGFyYW1Ub0lmcmFtZVNvdXJjZSA9IGZ1bmN0aW9uKCBzb3VyY2VBdHRyaWJ1dGUsIHNvdXJjZVVSTCwgcGFyYW0gKSB7XG5cdFx0XHR0b0FycmF5KCBkb20uc2xpZGVzLnF1ZXJ5U2VsZWN0b3JBbGwoICdpZnJhbWVbJysgc291cmNlQXR0cmlidXRlICsnKj1cIicrIHNvdXJjZVVSTCArJ1wiXScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0dmFyIHNyYyA9IGVsLmdldEF0dHJpYnV0ZSggc291cmNlQXR0cmlidXRlICk7XG5cdFx0XHRcdGlmKCBzcmMgJiYgc3JjLmluZGV4T2YoIHBhcmFtICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSggc291cmNlQXR0cmlidXRlLCBzcmMgKyAoICEvXFw/Ly50ZXN0KCBzcmMgKSA/ICc/JyA6ICcmJyApICsgcGFyYW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdC8vIFlvdVR1YmUgZnJhbWVzIG11c3QgaW5jbHVkZSBcIj9lbmFibGVqc2FwaT0xXCJcblx0XHRfYXBwZW5kUGFyYW1Ub0lmcmFtZVNvdXJjZSggJ3NyYycsICd5b3V0dWJlLmNvbS9lbWJlZC8nLCAnZW5hYmxlanNhcGk9MScgKTtcblx0XHRfYXBwZW5kUGFyYW1Ub0lmcmFtZVNvdXJjZSggJ2RhdGEtc3JjJywgJ3lvdXR1YmUuY29tL2VtYmVkLycsICdlbmFibGVqc2FwaT0xJyApO1xuXG5cdFx0Ly8gVmltZW8gZnJhbWVzIG11c3QgaW5jbHVkZSBcIj9hcGk9MVwiXG5cdFx0X2FwcGVuZFBhcmFtVG9JZnJhbWVTb3VyY2UoICdzcmMnLCAncGxheWVyLnZpbWVvLmNvbS8nLCAnYXBpPTEnICk7XG5cdFx0X2FwcGVuZFBhcmFtVG9JZnJhbWVTb3VyY2UoICdkYXRhLXNyYycsICdwbGF5ZXIudmltZW8uY29tLycsICdhcGk9MScgKTtcblxuXHRcdC8vIEFsd2F5cyBzaG93IG1lZGlhIGNvbnRyb2xzIG9uIG1vYmlsZSBkZXZpY2VzXG5cdFx0aWYoIGlzTW9iaWxlRGV2aWNlICkge1xuXHRcdFx0dG9BcnJheSggZG9tLnNsaWRlcy5xdWVyeVNlbGVjdG9yQWxsKCAndmlkZW8sIGF1ZGlvJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRlbC5jb250cm9scyA9IHRydWU7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU3RhcnQgcGxheWJhY2sgb2YgYW55IGVtYmVkZGVkIGNvbnRlbnQgaW5zaWRlIG9mXG5cdCAqIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFydEVtYmVkZGVkQ29udGVudCggZWxlbWVudCApIHtcblxuXHRcdGlmKCBlbGVtZW50ICYmICFpc1NwZWFrZXJOb3RlcygpICkge1xuXG5cdFx0XHQvLyBSZXN0YXJ0IEdJRnNcblx0XHRcdHRvQXJyYXkoIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ2ltZ1tzcmMkPVwiLmdpZlwiXScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgc2FtZSB1bmNoYW5nZWQgc291cmNlIGxpa2UgdGhpcyB3YXMgY29uZmlybWVkXG5cdFx0XHRcdC8vIHRvIHdvcmsgaW4gQ2hyb21lLCBGRiAmIFNhZmFyaVxuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoICdzcmMnLCBlbC5nZXRBdHRyaWJ1dGUoICdzcmMnICkgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gSFRNTDUgbWVkaWEgZWxlbWVudHNcblx0XHRcdHRvQXJyYXkoIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ3ZpZGVvLCBhdWRpbycgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0aWYoIGNsb3Nlc3RQYXJlbnQoIGVsLCAnLmZyYWdtZW50JyApICYmICFjbG9zZXN0UGFyZW50KCBlbCwgJy5mcmFnbWVudC52aXNpYmxlJyApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByZWZlciBhbiBleHBsaWNpdCBnbG9iYWwgYXV0b3BsYXkgc2V0dGluZ1xuXHRcdFx0XHR2YXIgYXV0b3BsYXkgPSBjb25maWcuYXV0b1BsYXlNZWRpYTtcblxuXHRcdFx0XHQvLyBJZiBubyBnbG9iYWwgc2V0dGluZyBpcyBhdmFpbGFibGUsIGZhbGwgYmFjayBvbiB0aGUgZWxlbWVudCdzXG5cdFx0XHRcdC8vIG93biBhdXRvcGxheSBzZXR0aW5nXG5cdFx0XHRcdGlmKCB0eXBlb2YgYXV0b3BsYXkgIT09ICdib29sZWFuJyApIHtcblx0XHRcdFx0XHRhdXRvcGxheSA9IGVsLmhhc0F0dHJpYnV0ZSggJ2RhdGEtYXV0b3BsYXknICkgfHwgISFjbG9zZXN0UGFyZW50KCBlbCwgJy5zbGlkZS1iYWNrZ3JvdW5kJyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIGF1dG9wbGF5ICYmIHR5cGVvZiBlbC5wbGF5ID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG1lZGlhIGlzIHJlYWR5LCBzdGFydCBwbGF5YmFja1xuXHRcdFx0XHRcdGlmKCBlbC5yZWFkeVN0YXRlID4gMSApIHtcblx0XHRcdFx0XHRcdHN0YXJ0RW1iZWRkZWRNZWRpYSggeyB0YXJnZXQ6IGVsIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTW9iaWxlIGRldmljZXMgbmV2ZXIgZmlyZSBhIGxvYWRlZCBldmVudCBzbyBpbnN0ZWFkXG5cdFx0XHRcdFx0Ly8gb2Ygd2FpdGluZywgd2UgaW5pdGlhdGUgcGxheWJhY2tcblx0XHRcdFx0XHRlbHNlIGlmKCBpc01vYmlsZURldmljZSApIHtcblx0XHRcdFx0XHRcdGVsLnBsYXkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG1lZGlhIGlzbid0IGxvYWRlZCwgd2FpdCBiZWZvcmUgcGxheWluZ1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWRlZGRhdGEnLCBzdGFydEVtYmVkZGVkTWVkaWEgKTsgLy8gcmVtb3ZlIGZpcnN0IHRvIGF2b2lkIGR1cGVzXG5cdFx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZGVkZGF0YScsIHN0YXJ0RW1iZWRkZWRNZWRpYSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIE5vcm1hbCBpZnJhbWVzXG5cdFx0XHR0b0FycmF5KCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICdpZnJhbWVbc3JjXScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0aWYoIGNsb3Nlc3RQYXJlbnQoIGVsLCAnLmZyYWdtZW50JyApICYmICFjbG9zZXN0UGFyZW50KCBlbCwgJy5mcmFnbWVudC52aXNpYmxlJyApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXJ0RW1iZWRkZWRJZnJhbWUoIHsgdGFyZ2V0OiBlbCB9ICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIExhenkgbG9hZGluZyBpZnJhbWVzXG5cdFx0XHR0b0FycmF5KCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICdpZnJhbWVbZGF0YS1zcmNdJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRpZiggY2xvc2VzdFBhcmVudCggZWwsICcuZnJhZ21lbnQnICkgJiYgIWNsb3Nlc3RQYXJlbnQoIGVsLCAnLmZyYWdtZW50LnZpc2libGUnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIGVsLmdldEF0dHJpYnV0ZSggJ3NyYycgKSAhPT0gZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1zcmMnICkgKSB7XG5cdFx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBzdGFydEVtYmVkZGVkSWZyYW1lICk7IC8vIHJlbW92ZSBmaXJzdCB0byBhdm9pZCBkdXBlc1xuXHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgc3RhcnRFbWJlZGRlZElmcmFtZSApO1xuXHRcdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSggJ3NyYycsIGVsLmdldEF0dHJpYnV0ZSggJ2RhdGEtc3JjJyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBwbGF5aW5nIGFuIGVtYmVkZGVkIHZpZGVvL2F1ZGlvIGVsZW1lbnQgYWZ0ZXJcblx0ICogaXQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gc3RhcnRFbWJlZGRlZE1lZGlhKCBldmVudCApIHtcblxuXHRcdHZhciBpc0F0dGFjaGVkVG9ET00gPSAhIWNsb3Nlc3RQYXJlbnQoIGV2ZW50LnRhcmdldCwgJ2h0bWwnICksXG5cdFx0XHRpc1Zpc2libGUgIFx0XHQ9ICEhY2xvc2VzdFBhcmVudCggZXZlbnQudGFyZ2V0LCAnLnByZXNlbnQnICk7XG5cblx0XHRpZiggaXNBdHRhY2hlZFRvRE9NICYmIGlzVmlzaWJsZSApIHtcblx0XHRcdGV2ZW50LnRhcmdldC5jdXJyZW50VGltZSA9IDA7XG5cdFx0XHRldmVudC50YXJnZXQucGxheSgpO1xuXHRcdH1cblxuXHRcdGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZGVkZGF0YScsIHN0YXJ0RW1iZWRkZWRNZWRpYSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogXCJTdGFydHNcIiB0aGUgY29udGVudCBvZiBhbiBlbWJlZGRlZCBpZnJhbWUgdXNpbmcgdGhlXG5cdCAqIHBvc3RNZXNzYWdlIEFQSS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFydEVtYmVkZGVkSWZyYW1lKCBldmVudCApIHtcblxuXHRcdHZhciBpZnJhbWUgPSBldmVudC50YXJnZXQ7XG5cblx0XHRpZiggaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93ICkge1xuXG5cdFx0XHR2YXIgaXNBdHRhY2hlZFRvRE9NID0gISFjbG9zZXN0UGFyZW50KCBldmVudC50YXJnZXQsICdodG1sJyApLFxuXHRcdFx0XHRpc1Zpc2libGUgIFx0XHQ9ICEhY2xvc2VzdFBhcmVudCggZXZlbnQudGFyZ2V0LCAnLnByZXNlbnQnICk7XG5cblx0XHRcdGlmKCBpc0F0dGFjaGVkVG9ET00gJiYgaXNWaXNpYmxlICkge1xuXG5cdFx0XHRcdC8vIFByZWZlciBhbiBleHBsaWNpdCBnbG9iYWwgYXV0b3BsYXkgc2V0dGluZ1xuXHRcdFx0XHR2YXIgYXV0b3BsYXkgPSBjb25maWcuYXV0b1BsYXlNZWRpYTtcblxuXHRcdFx0XHQvLyBJZiBubyBnbG9iYWwgc2V0dGluZyBpcyBhdmFpbGFibGUsIGZhbGwgYmFjayBvbiB0aGUgZWxlbWVudCdzXG5cdFx0XHRcdC8vIG93biBhdXRvcGxheSBzZXR0aW5nXG5cdFx0XHRcdGlmKCB0eXBlb2YgYXV0b3BsYXkgIT09ICdib29sZWFuJyApIHtcblx0XHRcdFx0XHRhdXRvcGxheSA9IGlmcmFtZS5oYXNBdHRyaWJ1dGUoICdkYXRhLWF1dG9wbGF5JyApIHx8ICEhY2xvc2VzdFBhcmVudCggaWZyYW1lLCAnLnNsaWRlLWJhY2tncm91bmQnICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBZb3VUdWJlIHBvc3RNZXNzYWdlIEFQSVxuXHRcdFx0XHRpZiggL3lvdXR1YmVcXC5jb21cXC9lbWJlZFxcLy8udGVzdCggaWZyYW1lLmdldEF0dHJpYnV0ZSggJ3NyYycgKSApICYmIGF1dG9wbGF5ICkge1xuXHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKCAne1wiZXZlbnRcIjpcImNvbW1hbmRcIixcImZ1bmNcIjpcInBsYXlWaWRlb1wiLFwiYXJnc1wiOlwiXCJ9JywgJyonICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVmltZW8gcG9zdE1lc3NhZ2UgQVBJXG5cdFx0XHRcdGVsc2UgaWYoIC9wbGF5ZXJcXC52aW1lb1xcLmNvbVxcLy8udGVzdCggaWZyYW1lLmdldEF0dHJpYnV0ZSggJ3NyYycgKSApICYmIGF1dG9wbGF5ICkge1xuXHRcdFx0XHRcdGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKCAne1wibWV0aG9kXCI6XCJwbGF5XCJ9JywgJyonICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gR2VuZXJpYyBwb3N0TWVzc2FnZSBBUElcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoICdzbGlkZTpzdGFydCcsICcqJyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWJhY2sgb2YgYW55IGVtYmVkZGVkIGNvbnRlbnQgaW5zaWRlIG9mXG5cdCAqIHRoZSB0YXJnZXRlZCBzbGlkZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gc3RvcEVtYmVkZGVkQ29udGVudCggZWxlbWVudCwgb3B0aW9ucyApIHtcblxuXHRcdG9wdGlvbnMgPSBleHRlbmQoIHtcblx0XHRcdC8vIERlZmF1bHRzXG5cdFx0XHR1bmxvYWRJZnJhbWVzOiB0cnVlXG5cdFx0fSwgb3B0aW9ucyB8fCB7fSApO1xuXG5cdFx0aWYoIGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0Ly8gSFRNTDUgbWVkaWEgZWxlbWVudHNcblx0XHRcdHRvQXJyYXkoIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ3ZpZGVvLCBhdWRpbycgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0aWYoICFlbC5oYXNBdHRyaWJ1dGUoICdkYXRhLWlnbm9yZScgKSAmJiB0eXBlb2YgZWwucGF1c2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXBhdXNlZC1ieS1yZXZlYWwnLCAnJyk7XG5cdFx0XHRcdFx0ZWwucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBHZW5lcmljIHBvc3RNZXNzYWdlIEFQSSBmb3Igbm9uLWxhenkgbG9hZGVkIGlmcmFtZXNcblx0XHRcdHRvQXJyYXkoIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ2lmcmFtZScgKSApLmZvckVhY2goIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0aWYoIGVsLmNvbnRlbnRXaW5kb3cgKSBlbC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKCAnc2xpZGU6c3RvcCcsICcqJyApO1xuXHRcdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIHN0YXJ0RW1iZWRkZWRJZnJhbWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBZb3VUdWJlIHBvc3RNZXNzYWdlIEFQSVxuXHRcdFx0dG9BcnJheSggZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnaWZyYW1lW3NyYyo9XCJ5b3V0dWJlLmNvbS9lbWJlZC9cIl0nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdGlmKCAhZWwuaGFzQXR0cmlidXRlKCAnZGF0YS1pZ25vcmUnICkgJiYgZWwuY29udGVudFdpbmRvdyAmJiB0eXBlb2YgZWwuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlbC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKCAne1wiZXZlbnRcIjpcImNvbW1hbmRcIixcImZ1bmNcIjpcInBhdXNlVmlkZW9cIixcImFyZ3NcIjpcIlwifScsICcqJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVmltZW8gcG9zdE1lc3NhZ2UgQVBJXG5cdFx0XHR0b0FycmF5KCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoICdpZnJhbWVbc3JjKj1cInBsYXllci52aW1lby5jb20vXCJdJyApICkuZm9yRWFjaCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRpZiggIWVsLmhhc0F0dHJpYnV0ZSggJ2RhdGEtaWdub3JlJyApICYmIGVsLmNvbnRlbnRXaW5kb3cgJiYgdHlwZW9mIGVsLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWwuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSggJ3tcIm1ldGhvZFwiOlwicGF1c2VcIn0nLCAnKicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmKCBvcHRpb25zLnVubG9hZElmcmFtZXMgPT09IHRydWUgKSB7XG5cdFx0XHRcdC8vIFVubG9hZCBsYXp5LWxvYWRlZCBpZnJhbWVzXG5cdFx0XHRcdHRvQXJyYXkoIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ2lmcmFtZVtkYXRhLXNyY10nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0Ly8gT25seSByZW1vdmluZyB0aGUgc3JjIGRvZXNuJ3QgYWN0dWFsbHkgdW5sb2FkIHRoZSBmcmFtZVxuXHRcdFx0XHRcdC8vIGluIGFsbCBicm93c2VycyAoRmlyZWZveCkgc28gd2Ugc2V0IGl0IHRvIGJsYW5rIGZpcnN0XG5cdFx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCAnc3JjJywgJ2Fib3V0OmJsYW5rJyApO1xuXHRcdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZSggJ3NyYycgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXN0IHNsaWRlcy4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGdsb2JhbFxuXHQgKiBmbGF0dGVuZWQgaW5kZXggZm9yIHNsaWRlcy5cblx0ICpcblx0ICogQHJldHVybiB7bnVtYmVyfSBQYXN0IHNsaWRlIGNvdW50XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTbGlkZVBhc3RDb3VudCgpIHtcblxuXHRcdHZhciBob3Jpem9udGFsU2xpZGVzID0gdG9BcnJheSggZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggSE9SSVpPTlRBTF9TTElERVNfU0VMRUNUT1IgKSApO1xuXG5cdFx0Ly8gVGhlIG51bWJlciBvZiBwYXN0IHNsaWRlc1xuXHRcdHZhciBwYXN0Q291bnQgPSAwO1xuXG5cdFx0Ly8gU3RlcCB0aHJvdWdoIGFsbCBzbGlkZXMgYW5kIGNvdW50IHRoZSBwYXN0IG9uZXNcblx0XHRtYWluTG9vcDogZm9yKCB2YXIgaSA9IDA7IGkgPCBob3Jpem9udGFsU2xpZGVzLmxlbmd0aDsgaSsrICkge1xuXG5cdFx0XHR2YXIgaG9yaXpvbnRhbFNsaWRlID0gaG9yaXpvbnRhbFNsaWRlc1tpXTtcblx0XHRcdHZhciB2ZXJ0aWNhbFNsaWRlcyA9IHRvQXJyYXkoIGhvcml6b250YWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKSApO1xuXG5cdFx0XHRmb3IoIHZhciBqID0gMDsgaiA8IHZlcnRpY2FsU2xpZGVzLmxlbmd0aDsgaisrICkge1xuXG5cdFx0XHRcdC8vIFN0b3AgYXMgc29vbiBhcyB3ZSBhcnJpdmUgYXQgdGhlIHByZXNlbnRcblx0XHRcdFx0aWYoIHZlcnRpY2FsU2xpZGVzW2pdLmNsYXNzTGlzdC5jb250YWlucyggJ3ByZXNlbnQnICkgKSB7XG5cdFx0XHRcdFx0YnJlYWsgbWFpbkxvb3A7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXN0Q291bnQrKztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9wIGFzIHNvb24gYXMgd2UgYXJyaXZlIGF0IHRoZSBwcmVzZW50XG5cdFx0XHRpZiggaG9yaXpvbnRhbFNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ3ByZXNlbnQnICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEb24ndCBjb3VudCB0aGUgd3JhcHBpbmcgc2VjdGlvbiBmb3IgdmVydGljYWwgc2xpZGVzXG5cdFx0XHRpZiggaG9yaXpvbnRhbFNsaWRlLmNsYXNzTGlzdC5jb250YWlucyggJ3N0YWNrJyApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cGFzdENvdW50Kys7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFzdENvdW50O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIHJhbmdpbmcgZnJvbSAwLTEgdGhhdCByZXByZXNlbnRzXG5cdCAqIGhvdyBmYXIgaW50byB0aGUgcHJlc2VudGF0aW9uIHdlIGhhdmUgbmF2aWdhdGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRQcm9ncmVzcygpIHtcblxuXHRcdC8vIFRoZSBudW1iZXIgb2YgcGFzdCBhbmQgdG90YWwgc2xpZGVzXG5cdFx0dmFyIHRvdGFsQ291bnQgPSBnZXRUb3RhbFNsaWRlcygpO1xuXHRcdHZhciBwYXN0Q291bnQgPSBnZXRTbGlkZVBhc3RDb3VudCgpO1xuXG5cdFx0aWYoIGN1cnJlbnRTbGlkZSApIHtcblxuXHRcdFx0dmFyIGFsbEZyYWdtZW50cyA9IGN1cnJlbnRTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgZnJhZ21lbnRzIGluIHRoZSBjdXJyZW50IHNsaWRlIHRob3NlIHNob3VsZCBiZVxuXHRcdFx0Ly8gYWNjb3VudGVkIGZvciBpbiB0aGUgcHJvZ3Jlc3MuXG5cdFx0XHRpZiggYWxsRnJhZ21lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdHZhciB2aXNpYmxlRnJhZ21lbnRzID0gY3VycmVudFNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICcuZnJhZ21lbnQudmlzaWJsZScgKTtcblxuXHRcdFx0XHQvLyBUaGlzIHZhbHVlIHJlcHJlc2VudHMgaG93IGJpZyBhIHBvcnRpb24gb2YgdGhlIHNsaWRlIHByb2dyZXNzXG5cdFx0XHRcdC8vIHRoYXQgaXMgbWFkZSB1cCBieSBpdHMgZnJhZ21lbnRzICgwLTEpXG5cdFx0XHRcdHZhciBmcmFnbWVudFdlaWdodCA9IDAuOTtcblxuXHRcdFx0XHQvLyBBZGQgZnJhZ21lbnQgcHJvZ3Jlc3MgdG8gdGhlIHBhc3Qgc2xpZGUgY291bnRcblx0XHRcdFx0cGFzdENvdW50ICs9ICggdmlzaWJsZUZyYWdtZW50cy5sZW5ndGggLyBhbGxGcmFnbWVudHMubGVuZ3RoICkgKiBmcmFnbWVudFdlaWdodDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXN0Q291bnQgLyAoIHRvdGFsQ291bnQgLSAxICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhpcyBwcmVzZW50YXRpb24gaXMgcnVubmluZyBpbnNpZGUgb2YgdGhlXG5cdCAqIHNwZWFrZXIgbm90ZXMgd2luZG93LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTcGVha2VyTm90ZXMoKSB7XG5cblx0XHRyZXR1cm4gISF3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKCAvcmVjZWl2ZXIvZ2kgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIHRoZSBjdXJyZW50IFVSTCAoaGFzaCkgYW5kIG5hdmlnYXRlcyBhY2NvcmRpbmdseS5cblx0ICovXG5cdGZ1bmN0aW9uIHJlYWRVUkwoKSB7XG5cblx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgaGFzaCBhcyBlaXRoZXIgYW4gaW5kZXggb3IgbmFtZVxuXHRcdHZhciBiaXRzID0gaGFzaC5zbGljZSggMiApLnNwbGl0KCAnLycgKSxcblx0XHRcdG5hbWUgPSBoYXNoLnJlcGxhY2UoIC8jfFxcLy9naSwgJycgKTtcblxuXHRcdC8vIElmIHRoZSBmaXJzdCBiaXQgaXMgaW52YWxpZCBhbmQgdGhlcmUgaXMgYSBuYW1lIHdlIGNhblxuXHRcdC8vIGFzc3VtZSB0aGF0IHRoaXMgaXMgYSBuYW1lZCBsaW5rXG5cdFx0aWYoIGlzTmFOKCBwYXJzZUludCggYml0c1swXSwgMTAgKSApICYmIG5hbWUubGVuZ3RoICkge1xuXHRcdFx0dmFyIGVsZW1lbnQ7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgbmFtZWQgbGluayBpcyBhIHZhbGlkIEhUTUwgSUQgYXR0cmlidXRlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGRlY29kZVVSSUNvbXBvbmVudCggbmFtZSApICk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoIGVycm9yICkgeyB9XG5cblx0XHRcdC8vIEVuc3VyZSB0aGF0IHdlJ3JlIG5vdCBhbHJlYWR5IG9uIGEgc2xpZGUgd2l0aCB0aGUgc2FtZSBuYW1lXG5cdFx0XHR2YXIgaXNTYW1lTmFtZUFzQ3VycmVudFNsaWRlID0gY3VycmVudFNsaWRlID8gY3VycmVudFNsaWRlLmdldEF0dHJpYnV0ZSggJ2lkJyApID09PSBuYW1lIDogZmFsc2U7XG5cblx0XHRcdGlmKCBlbGVtZW50ICYmICFpc1NhbWVOYW1lQXNDdXJyZW50U2xpZGUgKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYW1lZCBzbGlkZSBhbmQgbmF2aWdhdGUgdG8gaXRcblx0XHRcdFx0dmFyIGluZGljZXMgPSBSZXZlYWwuZ2V0SW5kaWNlcyggZWxlbWVudCApO1xuXHRcdFx0XHRzbGlkZSggaW5kaWNlcy5oLCBpbmRpY2VzLnYgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSBzbGlkZSBkb2Vzbid0IGV4aXN0LCBuYXZpZ2F0ZSB0byB0aGUgY3VycmVudCBzbGlkZVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNsaWRlKCBpbmRleGggfHwgMCwgaW5kZXh2IHx8IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgaGFzaEluZGV4QmFzZSA9IGNvbmZpZy5oYXNoT25lQmFzZWRJbmRleCA/IDEgOiAwO1xuXG5cdFx0XHQvLyBSZWFkIHRoZSBpbmRleCBjb21wb25lbnRzIG9mIHRoZSBoYXNoXG5cdFx0XHR2YXIgaCA9ICggcGFyc2VJbnQoIGJpdHNbMF0sIDEwICkgLSBoYXNoSW5kZXhCYXNlICkgfHwgMCxcblx0XHRcdFx0diA9ICggcGFyc2VJbnQoIGJpdHNbMV0sIDEwICkgLSBoYXNoSW5kZXhCYXNlICkgfHwgMCxcblx0XHRcdFx0ZjtcblxuXHRcdFx0aWYoIGNvbmZpZy5mcmFnbWVudEluVVJMICkge1xuXHRcdFx0XHRmID0gcGFyc2VJbnQoIGJpdHNbMl0sIDEwICk7XG5cdFx0XHRcdGlmKCBpc05hTiggZiApICkge1xuXHRcdFx0XHRcdGYgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIGggIT09IGluZGV4aCB8fCB2ICE9PSBpbmRleHYgfHwgZiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzbGlkZSggaCwgdiwgZiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHBhZ2UgVVJMIChoYXNoKSB0byByZWZsZWN0IHRoZSBjdXJyZW50XG5cdCAqIHN0YXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmVcblx0ICogd3JpdGluZyB0aGUgaGFzaFxuXHQgKi9cblx0ZnVuY3Rpb24gd3JpdGVVUkwoIGRlbGF5ICkge1xuXG5cdFx0aWYoIGNvbmZpZy5oaXN0b3J5ICkge1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlcmUncyBuZXZlciBtb3JlIHRoYW4gb25lIHRpbWVvdXQgcnVubmluZ1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB3cml0ZVVSTFRpbWVvdXQgKTtcblxuXHRcdFx0Ly8gSWYgYSBkZWxheSBpcyBzcGVjaWZpZWQsIHRpbWVvdXQgdGhpcyBjYWxsXG5cdFx0XHRpZiggdHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0d3JpdGVVUkxUaW1lb3V0ID0gc2V0VGltZW91dCggd3JpdGVVUkwsIGRlbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCBjdXJyZW50U2xpZGUgKSB7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gbG9jYXRpb25IYXNoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgaC92IGxvY2F0aW9uIGFuZCBmcmFnbWVudCBvZiB0aGUgY3VycmVudCxcblx0ICogb3Igc3BlY2lmaWVkLCBzbGlkZS5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW3NsaWRlXSBJZiBzcGVjaWZpZWQsIHRoZSByZXR1cm5lZFxuXHQgKiBpbmRleCB3aWxsIGJlIGZvciB0aGlzIHNsaWRlIHJhdGhlciB0aGFuIHRoZSBjdXJyZW50bHlcblx0ICogYWN0aXZlIG9uZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHt7aDogbnVtYmVyLCB2OiBudW1iZXIsIGY6IG51bWJlcn19XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRJbmRpY2VzKCBzbGlkZSApIHtcblxuXHRcdC8vIEJ5IGRlZmF1bHQsIHJldHVybiB0aGUgY3VycmVudCBpbmRpY2VzXG5cdFx0dmFyIGggPSBpbmRleGgsXG5cdFx0XHR2ID0gaW5kZXh2LFxuXHRcdFx0ZjtcblxuXHRcdC8vIElmIGEgc2xpZGUgaXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGluZGljZXMgb2YgdGhhdCBzbGlkZVxuXHRcdGlmKCBzbGlkZSApIHtcblx0XHRcdHZhciBpc1ZlcnRpY2FsID0gaXNWZXJ0aWNhbFNsaWRlKCBzbGlkZSApO1xuXHRcdFx0dmFyIHNsaWRlaCA9IGlzVmVydGljYWwgPyBzbGlkZS5wYXJlbnROb2RlIDogc2xpZGU7XG5cblx0XHRcdC8vIFNlbGVjdCBhbGwgaG9yaXpvbnRhbCBzbGlkZXNcblx0XHRcdHZhciBob3Jpem9udGFsU2xpZGVzID0gdG9BcnJheSggZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggSE9SSVpPTlRBTF9TTElERVNfU0VMRUNUT1IgKSApO1xuXG5cdFx0XHQvLyBOb3cgdGhhdCB3ZSBrbm93IHdoaWNoIHRoZSBob3Jpem9udGFsIHNsaWRlIGlzLCBnZXQgaXRzIGluZGV4XG5cdFx0XHRoID0gTWF0aC5tYXgoIGhvcml6b250YWxTbGlkZXMuaW5kZXhPZiggc2xpZGVoICksIDAgKTtcblxuXHRcdFx0Ly8gQXNzdW1lIHdlJ3JlIG5vdCB2ZXJ0aWNhbFxuXHRcdFx0diA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHZlcnRpY2FsIHNsaWRlLCBncmFiIHRoZSB2ZXJ0aWNhbCBpbmRleFxuXHRcdFx0aWYoIGlzVmVydGljYWwgKSB7XG5cdFx0XHRcdHYgPSBNYXRoLm1heCggdG9BcnJheSggc2xpZGUucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKSApLmluZGV4T2YoIHNsaWRlICksIDAgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggIXNsaWRlICYmIGN1cnJlbnRTbGlkZSApIHtcblx0XHRcdHZhciBoYXNGcmFnbWVudHMgPSBjdXJyZW50U2xpZGUucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudCcgKS5sZW5ndGggPiAwO1xuXHRcdFx0aWYoIGhhc0ZyYWdtZW50cyApIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRGcmFnbWVudCA9IGN1cnJlbnRTbGlkZS5xdWVyeVNlbGVjdG9yKCAnLmN1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdGlmKCBjdXJyZW50RnJhZ21lbnQgJiYgY3VycmVudEZyYWdtZW50Lmhhc0F0dHJpYnV0ZSggJ2RhdGEtZnJhZ21lbnQtaW5kZXgnICkgKSB7XG5cdFx0XHRcdFx0ZiA9IHBhcnNlSW50KCBjdXJyZW50RnJhZ21lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1mcmFnbWVudC1pbmRleCcgKSwgMTAgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRmID0gY3VycmVudFNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICcuZnJhZ21lbnQudmlzaWJsZScgKS5sZW5ndGggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgaDogaCwgdjogdiwgZjogZiB9O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIGFsbCBzbGlkZXMgaW4gdGhpcyBwcmVzZW50YXRpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTbGlkZXMoKSB7XG5cblx0XHRyZXR1cm4gdG9BcnJheSggZG9tLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCggU0xJREVTX1NFTEVDVE9SICsgJzpub3QoLnN0YWNrKScgKSk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBzbGlkZXMgaW4gdGhpcyBwcmVzZW50YXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldFRvdGFsU2xpZGVzKCkge1xuXG5cdFx0cmV0dXJuIGdldFNsaWRlcygpLmxlbmd0aDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNsaWRlIGVsZW1lbnQgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBpbmRleC5cblx0ICpcblx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTbGlkZSggeCwgeSApIHtcblxuXHRcdHZhciBob3Jpem9udGFsU2xpZGUgPSBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApWyB4IF07XG5cdFx0dmFyIHZlcnRpY2FsU2xpZGVzID0gaG9yaXpvbnRhbFNsaWRlICYmIGhvcml6b250YWxTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKTtcblxuXHRcdGlmKCB2ZXJ0aWNhbFNsaWRlcyAmJiB2ZXJ0aWNhbFNsaWRlcy5sZW5ndGggJiYgdHlwZW9mIHkgPT09ICdudW1iZXInICkge1xuXHRcdFx0cmV0dXJuIHZlcnRpY2FsU2xpZGVzID8gdmVydGljYWxTbGlkZXNbIHkgXSA6IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gaG9yaXpvbnRhbFNsaWRlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYmFja2dyb3VuZCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gc2xpZGUuXG5cdCAqIEFsbCBzbGlkZXMsIGV2ZW4gdGhlIG9uZXMgd2l0aCBubyBiYWNrZ3JvdW5kIHByb3BlcnRpZXNcblx0ICogZGVmaW5lZCwgaGF2ZSBhIGJhY2tncm91bmQgZWxlbWVudCBzbyBhcyBsb25nIGFzIHRoZVxuXHQgKiBpbmRleCBpcyB2YWxpZCBhbiBlbGVtZW50IHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IHggSG9yaXpvbnRhbCBiYWNrZ3JvdW5kIGluZGV4IE9SIGEgc2xpZGVcblx0ICogSFRNTCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IFZlcnRpY2FsIGJhY2tncm91bmQgaW5kZXhcblx0ICogQHJldHVybiB7KEhUTUxFbGVtZW50W118Kil9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTbGlkZUJhY2tncm91bmQoIHgsIHkgKSB7XG5cblx0XHR2YXIgc2xpZGUgPSB0eXBlb2YgeCA9PT0gJ251bWJlcicgPyBnZXRTbGlkZSggeCwgeSApIDogeDtcblx0XHRpZiggc2xpZGUgKSB7XG5cdFx0XHRyZXR1cm4gc2xpZGUuc2xpZGVCYWNrZ3JvdW5kRWxlbWVudDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBzcGVha2VyIG5vdGVzIGZyb20gYSBzbGlkZS4gTm90ZXMgY2FuIGJlXG5cdCAqIGRlZmluZWQgaW4gdHdvIHdheXM6XG5cdCAqIDEuIEFzIGEgZGF0YS1ub3RlcyBhdHRyaWJ1dGUgb24gdGhlIHNsaWRlIDxzZWN0aW9uPlxuXHQgKiAyLiBBcyBhbiA8YXNpZGUgY2xhc3M9XCJub3Rlc1wiPiBpbnNpZGUgb2YgdGhlIHNsaWRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtzbGlkZT1jdXJyZW50U2xpZGVdXG5cdCAqIEByZXR1cm4geyhzdHJpbmd8bnVsbCl9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTbGlkZU5vdGVzKCBzbGlkZSApIHtcblxuXHRcdC8vIERlZmF1bHQgdG8gdGhlIGN1cnJlbnQgc2xpZGVcblx0XHRzbGlkZSA9IHNsaWRlIHx8IGN1cnJlbnRTbGlkZTtcblxuXHRcdC8vIE5vdGVzIGNhbiBiZSBzcGVjaWZpZWQgdmlhIHRoZSBkYXRhLW5vdGVzIGF0dHJpYnV0ZS4uLlxuXHRcdGlmKCBzbGlkZS5oYXNBdHRyaWJ1dGUoICdkYXRhLW5vdGVzJyApICkge1xuXHRcdFx0cmV0dXJuIHNsaWRlLmdldEF0dHJpYnV0ZSggJ2RhdGEtbm90ZXMnICk7XG5cdFx0fVxuXG5cdFx0Ly8gLi4uIG9yIHVzaW5nIGFuIDxhc2lkZSBjbGFzcz1cIm5vdGVzXCI+IGVsZW1lbnRcblx0XHR2YXIgbm90ZXNFbGVtZW50ID0gc2xpZGUucXVlcnlTZWxlY3RvciggJ2FzaWRlLm5vdGVzJyApO1xuXHRcdGlmKCBub3Rlc0VsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gbm90ZXNFbGVtZW50LmlubmVySFRNTDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcHJlc2VudGF0aW9uIGFzXG5cdCAqIGFuIG9iamVjdC4gVGhpcyBzdGF0ZSBjYW4gdGhlbiBiZSByZXN0b3JlZCBhdCBhbnlcblx0ICogdGltZS5cblx0ICpcblx0ICogQHJldHVybiB7e2luZGV4aDogbnVtYmVyLCBpbmRleHY6IG51bWJlciwgaW5kZXhmOiBudW1iZXIsIHBhdXNlZDogYm9vbGVhbiwgb3ZlcnZpZXc6IGJvb2xlYW59fVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG5cblx0XHR2YXIgaW5kaWNlcyA9IGdldEluZGljZXMoKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbmRleGg6IGluZGljZXMuaCxcblx0XHRcdGluZGV4djogaW5kaWNlcy52LFxuXHRcdFx0aW5kZXhmOiBpbmRpY2VzLmYsXG5cdFx0XHRwYXVzZWQ6IGlzUGF1c2VkKCksXG5cdFx0XHRvdmVydmlldzogaXNPdmVydmlldygpXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlc3RvcmVzIHRoZSBwcmVzZW50YXRpb24gdG8gdGhlIGdpdmVuIHN0YXRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgQXMgZ2VuZXJhdGVkIGJ5IGdldFN0YXRlKClcblx0ICogQHNlZSB7QGxpbmsgZ2V0U3RhdGV9IGdlbmVyYXRlcyB0aGUgcGFyYW1ldGVyIGBzdGF0ZWBcblx0ICovXG5cdGZ1bmN0aW9uIHNldFN0YXRlKCBzdGF0ZSApIHtcblxuXHRcdGlmKCB0eXBlb2Ygc3RhdGUgPT09ICdvYmplY3QnICkge1xuXHRcdFx0c2xpZGUoIGRlc2VyaWFsaXplKCBzdGF0ZS5pbmRleGggKSwgZGVzZXJpYWxpemUoIHN0YXRlLmluZGV4diApLCBkZXNlcmlhbGl6ZSggc3RhdGUuaW5kZXhmICkgKTtcblxuXHRcdFx0dmFyIHBhdXNlZEZsYWcgPSBkZXNlcmlhbGl6ZSggc3RhdGUucGF1c2VkICksXG5cdFx0XHRcdG92ZXJ2aWV3RmxhZyA9IGRlc2VyaWFsaXplKCBzdGF0ZS5vdmVydmlldyApO1xuXG5cdFx0XHRpZiggdHlwZW9mIHBhdXNlZEZsYWcgPT09ICdib29sZWFuJyAmJiBwYXVzZWRGbGFnICE9PSBpc1BhdXNlZCgpICkge1xuXHRcdFx0XHR0b2dnbGVQYXVzZSggcGF1c2VkRmxhZyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggdHlwZW9mIG92ZXJ2aWV3RmxhZyA9PT0gJ2Jvb2xlYW4nICYmIG92ZXJ2aWV3RmxhZyAhPT0gaXNPdmVydmlldygpICkge1xuXHRcdFx0XHR0b2dnbGVPdmVydmlldyggb3ZlcnZpZXdGbGFnICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgc29ydGVkIGZyYWdtZW50cyBsaXN0LCBvcmRlcmVkIGJ5IGFuIGluY3JlYXNpbmdcblx0ICogXCJkYXRhLWZyYWdtZW50LWluZGV4XCIgYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBGcmFnbWVudHMgd2lsbCBiZSByZXZlYWxlZCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSByZXR1cm5lZCBieVxuXHQgKiB0aGlzIGZ1bmN0aW9uLCBzbyB5b3UgY2FuIHVzZSB0aGUgaW5kZXggYXR0cmlidXRlcyB0byBjb250cm9sIHRoZVxuXHQgKiBvcmRlciBvZiBmcmFnbWVudCBhcHBlYXJhbmNlLlxuXHQgKlxuXHQgKiBUbyBtYWludGFpbiBhIHNlbnNpYmxlIGRlZmF1bHQgZnJhZ21lbnQgb3JkZXIsIGZyYWdtZW50cyBhcmUgcHJlc3VtZWRcblx0ICogdG8gYmUgcGFzc2VkIGluIGRvY3VtZW50IG9yZGVyLiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBcImZyYWdtZW50LWluZGV4XCJcblx0ICogYXR0cmlidXRlIHRvIGVhY2ggbm9kZSBpZiBzdWNoIGFuIGF0dHJpYnV0ZSBpcyBub3QgYWxyZWFkeSBwcmVzZW50LFxuXHQgKiBhbmQgc2V0cyB0aGF0IGF0dHJpYnV0ZSB0byBhbiBpbnRlZ2VyIHZhbHVlIHdoaWNoIGlzIHRoZSBwb3NpdGlvbiBvZlxuXHQgKiB0aGUgZnJhZ21lbnQgd2l0aGluIHRoZSBmcmFnbWVudHMgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3RbXXwqfSBmcmFnbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBncm91cGVkIElmIHRydWUgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29udGFpblxuXHQgKiBuZXN0ZWQgYXJyYXlzIGZvciBhbGwgZnJhZ21lbnRzIHdpdGggdGhlIHNhbWUgaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0W119IHNvcnRlZCBTb3J0ZWQgYXJyYXkgb2YgZnJhZ21lbnRzXG5cdCAqL1xuXHRmdW5jdGlvbiBzb3J0RnJhZ21lbnRzKCBmcmFnbWVudHMsIGdyb3VwZWQgKSB7XG5cblx0XHRmcmFnbWVudHMgPSB0b0FycmF5KCBmcmFnbWVudHMgKTtcblxuXHRcdHZhciBvcmRlcmVkID0gW10sXG5cdFx0XHR1bm9yZGVyZWQgPSBbXSxcblx0XHRcdHNvcnRlZCA9IFtdO1xuXG5cdFx0Ly8gR3JvdXAgb3JkZXJlZCBhbmQgdW5vcmRlcmVkIGVsZW1lbnRzXG5cdFx0ZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBmcmFnbWVudCwgaSApIHtcblx0XHRcdGlmKCBmcmFnbWVudC5oYXNBdHRyaWJ1dGUoICdkYXRhLWZyYWdtZW50LWluZGV4JyApICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggZnJhZ21lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1mcmFnbWVudC1pbmRleCcgKSwgMTAgKTtcblxuXHRcdFx0XHRpZiggIW9yZGVyZWRbaW5kZXhdICkge1xuXHRcdFx0XHRcdG9yZGVyZWRbaW5kZXhdID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcmRlcmVkW2luZGV4XS5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHVub3JkZXJlZC5wdXNoKCBbIGZyYWdtZW50IF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBBcHBlbmQgZnJhZ21lbnRzIHdpdGhvdXQgZXhwbGljaXQgaW5kaWNlcyBpbiB0aGVpclxuXHRcdC8vIERPTSBvcmRlclxuXHRcdG9yZGVyZWQgPSBvcmRlcmVkLmNvbmNhdCggdW5vcmRlcmVkICk7XG5cblx0XHQvLyBNYW51YWxseSBjb3VudCB0aGUgaW5kZXggdXAgcGVyIGdyb3VwIHRvIGVuc3VyZSB0aGVyZVxuXHRcdC8vIGFyZSBubyBnYXBzXG5cdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdC8vIFB1c2ggYWxsIGZyYWdtZW50cyBpbiB0aGVpciBzb3J0ZWQgb3JkZXIgdG8gYW4gYXJyYXksXG5cdFx0Ly8gdGhpcyBmbGF0dGVucyB0aGUgZ3JvdXBzXG5cdFx0b3JkZXJlZC5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKSB7XG5cdFx0XHRncm91cC5mb3JFYWNoKCBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHNvcnRlZC5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRmcmFnbWVudC5zZXRBdHRyaWJ1dGUoICdkYXRhLWZyYWdtZW50LWluZGV4JywgaW5kZXggKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0aW5kZXggKys7XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGdyb3VwZWQgPT09IHRydWUgPyBvcmRlcmVkIDogc29ydGVkO1xuXG5cdH1cblxuXHQvKipcblx0ICogTmF2aWdhdGUgdG8gdGhlIHNwZWNpZmllZCBzbGlkZSBmcmFnbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHs/bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYWdtZW50IHRoYXRcblx0ICogc2hvdWxkIGJlIHNob3duLCAtMSBtZWFucyBhbGwgYXJlIGludmlzaWJsZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IEludGVnZXIgb2Zmc2V0IHRvIGFwcGx5IHRvIHRoZVxuXHQgKiBmcmFnbWVudCBpbmRleFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIHdhcyBtYWRlIGluIGFueVxuXHQgKiBmcmFnbWVudHMgdmlzaWJpbGl0eSBhcyBwYXJ0IG9mIHRoaXMgY2FsbFxuXHQgKi9cblx0ZnVuY3Rpb24gbmF2aWdhdGVGcmFnbWVudCggaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmKCBjdXJyZW50U2xpZGUgJiYgY29uZmlnLmZyYWdtZW50cyApIHtcblxuXHRcdFx0dmFyIGZyYWdtZW50cyA9IHNvcnRGcmFnbWVudHMoIGN1cnJlbnRTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApICk7XG5cdFx0XHRpZiggZnJhZ21lbnRzLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBJZiBubyBpbmRleCBpcyBzcGVjaWZpZWQsIGZpbmQgdGhlIGN1cnJlbnRcblx0XHRcdFx0aWYoIHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgKSB7XG5cdFx0XHRcdFx0dmFyIGxhc3RWaXNpYmxlRnJhZ21lbnQgPSBzb3J0RnJhZ21lbnRzKCBjdXJyZW50U2xpZGUucXVlcnlTZWxlY3RvckFsbCggJy5mcmFnbWVudC52aXNpYmxlJyApICkucG9wKCk7XG5cblx0XHRcdFx0XHRpZiggbGFzdFZpc2libGVGcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gcGFyc2VJbnQoIGxhc3RWaXNpYmxlRnJhZ21lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1mcmFnbWVudC1pbmRleCcgKSB8fCAwLCAxMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgYW4gb2Zmc2V0IGlzIHNwZWNpZmllZCwgYXBwbHkgaXQgdG8gdGhlIGluZGV4XG5cdFx0XHRcdGlmKCB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0XHRpbmRleCArPSBvZmZzZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZnJhZ21lbnRzU2hvd24gPSBbXSxcblx0XHRcdFx0XHRmcmFnbWVudHNIaWRkZW4gPSBbXTtcblxuXHRcdFx0XHR0b0FycmF5KCBmcmFnbWVudHMgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbWVudCwgaSApIHtcblxuXHRcdFx0XHRcdGlmKCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSggJ2RhdGEtZnJhZ21lbnQtaW5kZXgnICkgKSB7XG5cdFx0XHRcdFx0XHRpID0gcGFyc2VJbnQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1mcmFnbWVudC1pbmRleCcgKSwgMTAgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBWaXNpYmxlIGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmKCBpIDw9IGluZGV4ICkge1xuXHRcdFx0XHRcdFx0aWYoICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyggJ3Zpc2libGUnICkgKSBmcmFnbWVudHNTaG93bi5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoICd2aXNpYmxlJyApO1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAnY3VycmVudC1mcmFnbWVudCcgKTtcblxuXHRcdFx0XHRcdFx0Ly8gQW5ub3VuY2UgdGhlIGZyYWdtZW50cyBvbmUgYnkgb25lIHRvIHRoZSBTY3JlZW4gUmVhZGVyXG5cdFx0XHRcdFx0XHRkb20uc3RhdHVzRGl2LnRleHRDb250ZW50ID0gZ2V0U3RhdHVzVGV4dCggZWxlbWVudCApO1xuXG5cdFx0XHRcdFx0XHRpZiggaSA9PT0gaW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0RW1iZWRkZWRDb250ZW50KCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEhpZGRlbiBmcmFnbWVudHNcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmKCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyggJ3Zpc2libGUnICkgKSBmcmFnbWVudHNIaWRkZW4ucHVzaCggZWxlbWVudCApO1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCAndmlzaWJsZScgKTtcblx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ2N1cnJlbnQtZnJhZ21lbnQnICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRpZiggZnJhZ21lbnRzSGlkZGVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkaXNwYXRjaEV2ZW50KCAnZnJhZ21lbnRoaWRkZW4nLCB7IGZyYWdtZW50OiBmcmFnbWVudHNIaWRkZW5bMF0sIGZyYWdtZW50czogZnJhZ21lbnRzSGlkZGVuIH0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBmcmFnbWVudHNTaG93bi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hFdmVudCggJ2ZyYWdtZW50c2hvd24nLCB7IGZyYWdtZW50OiBmcmFnbWVudHNTaG93blswXSwgZnJhZ21lbnRzOiBmcmFnbWVudHNTaG93biB9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cGRhdGVDb250cm9scygpO1xuXHRcdFx0XHR1cGRhdGVQcm9ncmVzcygpO1xuXHRcdFx0XHRpZiggY29uZmlnLmZyYWdtZW50SW5VUkwgKSB7XG5cdFx0XHRcdFx0d3JpdGVVUkwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAhISggZnJhZ21lbnRzU2hvd24ubGVuZ3RoIHx8IGZyYWdtZW50c0hpZGRlbi5sZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHQvKipcblx0ICogTmF2aWdhdGUgdG8gdGhlIG5leHQgc2xpZGUgZnJhZ21lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUgd2FzIGEgbmV4dCBmcmFnbWVudCxcblx0ICogZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBuZXh0RnJhZ21lbnQoKSB7XG5cblx0XHRyZXR1cm4gbmF2aWdhdGVGcmFnbWVudCggbnVsbCwgMSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHNsaWRlIGZyYWdtZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIGZyYWdtZW50LFxuXHQgKiBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGZ1bmN0aW9uIHByZXZpb3VzRnJhZ21lbnQoKSB7XG5cblx0XHRyZXR1cm4gbmF2aWdhdGVGcmFnbWVudCggbnVsbCwgLTEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEN1ZXMgYSBuZXcgYXV0b21hdGVkIHNsaWRlIGlmIGVuYWJsZWQgaW4gdGhlIGNvbmZpZy5cblx0ICovXG5cdGZ1bmN0aW9uIGN1ZUF1dG9TbGlkZSgpIHtcblxuXHRcdGNhbmNlbEF1dG9TbGlkZSgpO1xuXG5cdFx0aWYoIGN1cnJlbnRTbGlkZSAmJiBjb25maWcuYXV0b1NsaWRlICE9PSBmYWxzZSApIHtcblxuXHRcdFx0dmFyIGZyYWdtZW50ID0gY3VycmVudFNsaWRlLnF1ZXJ5U2VsZWN0b3IoICcuY3VycmVudC1mcmFnbWVudCcgKTtcblxuXHRcdFx0Ly8gV2hlbiB0aGUgc2xpZGUgZmlyc3QgYXBwZWFycyB0aGVyZSBpcyBubyBcImN1cnJlbnRcIiBmcmFnbWVudCBzb1xuXHRcdFx0Ly8gd2UgbG9vayBmb3IgYSBkYXRhLWF1dG9zbGlkZSB0aW1pbmcgb24gdGhlIGZpcnN0IGZyYWdtZW50XG5cdFx0XHRpZiggIWZyYWdtZW50ICkgZnJhZ21lbnQgPSBjdXJyZW50U2xpZGUucXVlcnlTZWxlY3RvciggJy5mcmFnbWVudCcgKTtcblxuXHRcdFx0dmFyIGZyYWdtZW50QXV0b1NsaWRlID0gZnJhZ21lbnQgPyBmcmFnbWVudC5nZXRBdHRyaWJ1dGUoICdkYXRhLWF1dG9zbGlkZScgKSA6IG51bGw7XG5cdFx0XHR2YXIgcGFyZW50QXV0b1NsaWRlID0gY3VycmVudFNsaWRlLnBhcmVudE5vZGUgPyBjdXJyZW50U2xpZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoICdkYXRhLWF1dG9zbGlkZScgKSA6IG51bGw7XG5cdFx0XHR2YXIgc2xpZGVBdXRvU2xpZGUgPSBjdXJyZW50U2xpZGUuZ2V0QXR0cmlidXRlKCAnZGF0YS1hdXRvc2xpZGUnICk7XG5cblx0XHRcdC8vIFBpY2sgdmFsdWUgaW4gdGhlIGZvbGxvd2luZyBwcmlvcml0eSBvcmRlcjpcblx0XHRcdC8vIDEuIEN1cnJlbnQgZnJhZ21lbnQncyBkYXRhLWF1dG9zbGlkZVxuXHRcdFx0Ly8gMi4gQ3VycmVudCBzbGlkZSdzIGRhdGEtYXV0b3NsaWRlXG5cdFx0XHQvLyAzLiBQYXJlbnQgc2xpZGUncyBkYXRhLWF1dG9zbGlkZVxuXHRcdFx0Ly8gNC4gR2xvYmFsIGF1dG9TbGlkZSBzZXR0aW5nXG5cdFx0XHRpZiggZnJhZ21lbnRBdXRvU2xpZGUgKSB7XG5cdFx0XHRcdGF1dG9TbGlkZSA9IHBhcnNlSW50KCBmcmFnbWVudEF1dG9TbGlkZSwgMTAgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIHNsaWRlQXV0b1NsaWRlICkge1xuXHRcdFx0XHRhdXRvU2xpZGUgPSBwYXJzZUludCggc2xpZGVBdXRvU2xpZGUsIDEwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCBwYXJlbnRBdXRvU2xpZGUgKSB7XG5cdFx0XHRcdGF1dG9TbGlkZSA9IHBhcnNlSW50KCBwYXJlbnRBdXRvU2xpZGUsIDEwICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXV0b1NsaWRlID0gY29uZmlnLmF1dG9TbGlkZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG1lZGlhIGVsZW1lbnRzIHdpdGggZGF0YS1hdXRvcGxheSxcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSBhdXRvU2xpZGUgZHVyYXRpb24gdG8gdGhlXG5cdFx0XHQvLyBsZW5ndGggb2YgdGhhdCBtZWRpYS4gTm90IGFwcGxpY2FibGUgaWYgdGhlIHNsaWRlXG5cdFx0XHQvLyBpcyBkaXZpZGVkIHVwIGludG8gZnJhZ21lbnRzLlxuXHRcdFx0Ly8gcGxheWJhY2tSYXRlIGlzIGFjY291bnRlZCBmb3IgaW4gdGhlIGR1cmF0aW9uLlxuXHRcdFx0aWYoIGN1cnJlbnRTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnLmZyYWdtZW50JyApLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0dG9BcnJheSggY3VycmVudFNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoICd2aWRlbywgYXVkaW8nICkgKS5mb3JFYWNoKCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0aWYoIGVsLmhhc0F0dHJpYnV0ZSggJ2RhdGEtYXV0b3BsYXknICkgKSB7XG5cdFx0XHRcdFx0XHRpZiggYXV0b1NsaWRlICYmIChlbC5kdXJhdGlvbiAqIDEwMDAgLyBlbC5wbGF5YmFja1JhdGUgKSA+IGF1dG9TbGlkZSApIHtcblx0XHRcdFx0XHRcdFx0YXV0b1NsaWRlID0gKCBlbC5kdXJhdGlvbiAqIDEwMDAgLyBlbC5wbGF5YmFja1JhdGUgKSArIDEwMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEN1ZSB0aGUgbmV4dCBhdXRvLXNsaWRlIGlmOlxuXHRcdFx0Ly8gLSBUaGVyZSBpcyBhbiBhdXRvU2xpZGUgdmFsdWVcblx0XHRcdC8vIC0gQXV0by1zbGlkaW5nIGlzbid0IHBhdXNlZCBieSB0aGUgdXNlclxuXHRcdFx0Ly8gLSBUaGUgcHJlc2VudGF0aW9uIGlzbid0IHBhdXNlZFxuXHRcdFx0Ly8gLSBUaGUgb3ZlcnZpZXcgaXNuJ3QgYWN0aXZlXG5cdFx0XHQvLyAtIFRoZSBwcmVzZW50YXRpb24gaXNuJ3Qgb3ZlclxuXHRcdFx0aWYoIGF1dG9TbGlkZSAmJiAhYXV0b1NsaWRlUGF1c2VkICYmICFpc1BhdXNlZCgpICYmICFpc092ZXJ2aWV3KCkgJiYgKCAhUmV2ZWFsLmlzTGFzdFNsaWRlKCkgfHwgYXZhaWxhYmxlRnJhZ21lbnRzKCkubmV4dCB8fCBjb25maWcubG9vcCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRhdXRvU2xpZGVUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dHlwZW9mIGNvbmZpZy5hdXRvU2xpZGVNZXRob2QgPT09ICdmdW5jdGlvbicgPyBjb25maWcuYXV0b1NsaWRlTWV0aG9kKCkgOiBuYXZpZ2F0ZU5leHQoKTtcblx0XHRcdFx0XHRjdWVBdXRvU2xpZGUoKTtcblx0XHRcdFx0fSwgYXV0b1NsaWRlICk7XG5cdFx0XHRcdGF1dG9TbGlkZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBhdXRvU2xpZGVQbGF5ZXIgKSB7XG5cdFx0XHRcdGF1dG9TbGlkZVBsYXllci5zZXRQbGF5aW5nKCBhdXRvU2xpZGVUaW1lb3V0ICE9PSAtMSApO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2FuY2VscyBhbnkgb25nb2luZyByZXF1ZXN0IHRvIGF1dG8tc2xpZGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBjYW5jZWxBdXRvU2xpZGUoKSB7XG5cblx0XHRjbGVhclRpbWVvdXQoIGF1dG9TbGlkZVRpbWVvdXQgKTtcblx0XHRhdXRvU2xpZGVUaW1lb3V0ID0gLTE7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhdXNlQXV0b1NsaWRlKCkge1xuXG5cdFx0aWYoIGF1dG9TbGlkZSAmJiAhYXV0b1NsaWRlUGF1c2VkICkge1xuXHRcdFx0YXV0b1NsaWRlUGF1c2VkID0gdHJ1ZTtcblx0XHRcdGRpc3BhdGNoRXZlbnQoICdhdXRvc2xpZGVwYXVzZWQnICk7XG5cdFx0XHRjbGVhclRpbWVvdXQoIGF1dG9TbGlkZVRpbWVvdXQgKTtcblxuXHRcdFx0aWYoIGF1dG9TbGlkZVBsYXllciApIHtcblx0XHRcdFx0YXV0b1NsaWRlUGxheWVyLnNldFBsYXlpbmcoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZXN1bWVBdXRvU2xpZGUoKSB7XG5cblx0XHRpZiggYXV0b1NsaWRlICYmIGF1dG9TbGlkZVBhdXNlZCApIHtcblx0XHRcdGF1dG9TbGlkZVBhdXNlZCA9IGZhbHNlO1xuXHRcdFx0ZGlzcGF0Y2hFdmVudCggJ2F1dG9zbGlkZXJlc3VtZWQnICk7XG5cdFx0XHRjdWVBdXRvU2xpZGUoKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG5hdmlnYXRlTGVmdCgpIHtcblxuXHRcdC8vIFJldmVyc2UgZm9yIFJUTFxuXHRcdGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0aWYoICggaXNPdmVydmlldygpIHx8IG5leHRGcmFnbWVudCgpID09PSBmYWxzZSApICYmIGF2YWlsYWJsZVJvdXRlcygpLmxlZnQgKSB7XG5cdFx0XHRcdHNsaWRlKCBpbmRleGggKyAxICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE5vcm1hbCBuYXZpZ2F0aW9uXG5cdFx0ZWxzZSBpZiggKCBpc092ZXJ2aWV3KCkgfHwgcHJldmlvdXNGcmFnbWVudCgpID09PSBmYWxzZSApICYmIGF2YWlsYWJsZVJvdXRlcygpLmxlZnQgKSB7XG5cdFx0XHRzbGlkZSggaW5kZXhoIC0gMSApO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gbmF2aWdhdGVSaWdodCgpIHtcblxuXHRcdGhhc05hdmlnYXRlZFJpZ2h0ID0gdHJ1ZTtcblxuXHRcdC8vIFJldmVyc2UgZm9yIFJUTFxuXHRcdGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0aWYoICggaXNPdmVydmlldygpIHx8IHByZXZpb3VzRnJhZ21lbnQoKSA9PT0gZmFsc2UgKSAmJiBhdmFpbGFibGVSb3V0ZXMoKS5yaWdodCApIHtcblx0XHRcdFx0c2xpZGUoIGluZGV4aCAtIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTm9ybWFsIG5hdmlnYXRpb25cblx0XHRlbHNlIGlmKCAoIGlzT3ZlcnZpZXcoKSB8fCBuZXh0RnJhZ21lbnQoKSA9PT0gZmFsc2UgKSAmJiBhdmFpbGFibGVSb3V0ZXMoKS5yaWdodCApIHtcblx0XHRcdHNsaWRlKCBpbmRleGggKyAxICk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBuYXZpZ2F0ZVVwKCkge1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSBoaWRpbmcgZnJhZ21lbnRzXG5cdFx0aWYoICggaXNPdmVydmlldygpIHx8IHByZXZpb3VzRnJhZ21lbnQoKSA9PT0gZmFsc2UgKSAmJiBhdmFpbGFibGVSb3V0ZXMoKS51cCApIHtcblx0XHRcdHNsaWRlKCBpbmRleGgsIGluZGV4diAtIDEgKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG5hdmlnYXRlRG93bigpIHtcblxuXHRcdGhhc05hdmlnYXRlZERvd24gPSB0cnVlO1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSByZXZlYWxpbmcgZnJhZ21lbnRzXG5cdFx0aWYoICggaXNPdmVydmlldygpIHx8IG5leHRGcmFnbWVudCgpID09PSBmYWxzZSApICYmIGF2YWlsYWJsZVJvdXRlcygpLmRvd24gKSB7XG5cdFx0XHRzbGlkZSggaW5kZXhoLCBpbmRleHYgKyAxICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogTmF2aWdhdGVzIGJhY2t3YXJkcywgcHJpb3JpdGl6ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcblx0ICogMSkgUHJldmlvdXMgZnJhZ21lbnRcblx0ICogMikgUHJldmlvdXMgdmVydGljYWwgc2xpZGVcblx0ICogMykgUHJldmlvdXMgaG9yaXpvbnRhbCBzbGlkZVxuXHQgKi9cblx0ZnVuY3Rpb24gbmF2aWdhdGVQcmV2KCkge1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSByZXZlYWxpbmcgZnJhZ21lbnRzXG5cdFx0aWYoIHByZXZpb3VzRnJhZ21lbnQoKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRpZiggYXZhaWxhYmxlUm91dGVzKCkudXAgKSB7XG5cdFx0XHRcdG5hdmlnYXRlVXAoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBGZXRjaCB0aGUgcHJldmlvdXMgaG9yaXpvbnRhbCBzbGlkZSwgaWYgdGhlcmUgaXMgb25lXG5cdFx0XHRcdHZhciBwcmV2aW91c1NsaWRlO1xuXG5cdFx0XHRcdGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0XHRcdHByZXZpb3VzU2xpZGUgPSB0b0FycmF5KCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiArICcuZnV0dXJlJyApICkucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cHJldmlvdXNTbGlkZSA9IHRvQXJyYXkoIGRvbS53cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoIEhPUklaT05UQUxfU0xJREVTX1NFTEVDVE9SICsgJy5wYXN0JyApICkucG9wKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiggcHJldmlvdXNTbGlkZSApIHtcblx0XHRcdFx0XHR2YXIgdiA9ICggcHJldmlvdXNTbGlkZS5xdWVyeVNlbGVjdG9yQWxsKCAnc2VjdGlvbicgKS5sZW5ndGggLSAxICkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdHZhciBoID0gaW5kZXhoIC0gMTtcblx0XHRcdFx0XHRzbGlkZSggaCwgdiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJldmVyc2Ugb2YgI25hdmlnYXRlUHJldigpLlxuXHQgKi9cblx0ZnVuY3Rpb24gbmF2aWdhdGVOZXh0KCkge1xuXG5cdFx0aGFzTmF2aWdhdGVkUmlnaHQgPSB0cnVlO1xuXHRcdGhhc05hdmlnYXRlZERvd24gPSB0cnVlO1xuXG5cdFx0Ly8gUHJpb3JpdGl6ZSByZXZlYWxpbmcgZnJhZ21lbnRzXG5cdFx0aWYoIG5leHRGcmFnbWVudCgpID09PSBmYWxzZSApIHtcblxuXHRcdFx0dmFyIHJvdXRlcyA9IGF2YWlsYWJsZVJvdXRlcygpO1xuXG5cdFx0XHQvLyBXaGVuIGxvb3BpbmcgaXMgZW5hYmxlZCBgcm91dGVzLmRvd25gIGlzIGFsd2F5cyBhdmFpbGFibGVcblx0XHRcdC8vIHNvIHdlIG5lZWQgYSBzZXBhcmF0ZSBjaGVjayBmb3Igd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZVxuXHRcdFx0Ly8gZW5kIG9mIGEgc3RhY2sgYW5kIHNob3VsZCBtb3ZlIGhvcml6b250YWxseVxuXHRcdFx0aWYoIHJvdXRlcy5kb3duICYmIHJvdXRlcy5yaWdodCAmJiBjb25maWcubG9vcCAmJiBSZXZlYWwuaXNMYXN0VmVydGljYWxTbGlkZSggY3VycmVudFNsaWRlICkgKSB7XG5cdFx0XHRcdHJvdXRlcy5kb3duID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCByb3V0ZXMuZG93biApIHtcblx0XHRcdFx0bmF2aWdhdGVEb3duKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCBjb25maWcucnRsICkge1xuXHRcdFx0XHRuYXZpZ2F0ZUxlZnQoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRuYXZpZ2F0ZVJpZ2h0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBwcmV2ZW50cyB0aGUgdHJpZ2dlcmluZyBvZlxuXHQgKiBzd2lwZSBuYXZpZ2F0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTd2lwZVByZXZlbnRlZCggdGFyZ2V0ICkge1xuXG5cdFx0d2hpbGUoIHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGlmKCB0YXJnZXQuaGFzQXR0cmlidXRlKCAnZGF0YS1wcmV2ZW50LXN3aXBlJyApICkgcmV0dXJuIHRydWU7XG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IGFsbCBldmVudCBoYW5kbGVycyB0aGF0IGFyZSBiYXNlZCBvbiB1c2VyXG5cdCAqIGlucHV0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2V2ZW50XVxuXHQgKi9cblx0ZnVuY3Rpb24gb25Vc2VySW5wdXQoIGV2ZW50ICkge1xuXG5cdFx0aWYoIGNvbmZpZy5hdXRvU2xpZGVTdG9wcGFibGUgKSB7XG5cdFx0XHRwYXVzZUF1dG9TbGlkZSgpO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHRoZSBkb2N1bWVudCBsZXZlbCAna2V5cHJlc3MnIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcblx0ICovXG5cdGZ1bmN0aW9uIG9uRG9jdW1lbnRLZXlQcmVzcyggZXZlbnQgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgcHJlc3NlZCBrZXkgaXMgcXVlc3Rpb24gbWFya1xuXHRcdGlmKCBldmVudC5zaGlmdEtleSAmJiBldmVudC5jaGFyQ29kZSA9PT0gNjMgKSB7XG5cdFx0XHR0b2dnbGVIZWxwKCk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlciBmb3IgdGhlIGRvY3VtZW50IGxldmVsICdrZXlkb3duJyBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvbkRvY3VtZW50S2V5RG93biggZXZlbnQgKSB7XG5cblx0XHQvLyBJZiB0aGVyZSdzIGEgY29uZGl0aW9uIHNwZWNpZmllZCBhbmQgaXQgcmV0dXJucyBmYWxzZSxcblx0XHQvLyBpZ25vcmUgdGhpcyBldmVudFxuXHRcdGlmKCB0eXBlb2YgY29uZmlnLmtleWJvYXJkQ29uZGl0aW9uID09PSAnZnVuY3Rpb24nICYmIGNvbmZpZy5rZXlib2FyZENvbmRpdGlvbihldmVudCkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgaWYgYXV0by1zbGlkaW5nIHdhcyBwYXVzZWQgc28gd2UgY2FuIHRvZ2dsZSBpdFxuXHRcdHZhciBhdXRvU2xpZGVXYXNQYXVzZWQgPSBhdXRvU2xpZGVQYXVzZWQ7XG5cblx0XHRvblVzZXJJbnB1dCggZXZlbnQgKTtcblxuXHRcdC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBmb2N1c2VkIGVsZW1lbnQgdGhhdCBjb3VsZCBiZSB1c2luZ1xuXHRcdC8vIHRoZSBrZXlib2FyZFxuXHRcdHZhciBhY3RpdmVFbGVtZW50SXNDRSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgIT09ICdpbmhlcml0Jztcblx0XHR2YXIgYWN0aXZlRWxlbWVudElzSW5wdXQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSAmJiAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgKTtcblx0XHR2YXIgYWN0aXZlRWxlbWVudElzTm90ZXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xhc3NOYW1lICYmIC9zcGVha2VyLW5vdGVzL2kudGVzdCggZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc05hbWUpO1xuXG5cdFx0Ly8gRGlzcmVnYXJkIHRoZSBldmVudCBpZiB0aGVyZSdzIGEgZm9jdXNlZCBlbGVtZW50IG9yIGFcblx0XHQvLyBrZXlib2FyZCBtb2RpZmllciBrZXkgaXMgcHJlc2VudFxuXHRcdGlmKCBhY3RpdmVFbGVtZW50SXNDRSB8fCBhY3RpdmVFbGVtZW50SXNJbnB1dCB8fCBhY3RpdmVFbGVtZW50SXNOb3RlcyB8fCAoZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSAhPT0gMzIpIHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSByZXR1cm47XG5cblx0XHQvLyBXaGlsZSBwYXVzZWQgb25seSBhbGxvdyByZXN1bWUga2V5Ym9hcmQgZXZlbnRzOyAnYicsICd2JywgJy4nXG5cdFx0dmFyIHJlc3VtZUtleUNvZGVzID0gWzY2LDg2LDE5MCwxOTFdO1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBDdXN0b20ga2V5IGJpbmRpbmdzIGZvciB0b2dnbGVQYXVzZSBzaG91bGQgYmUgYWJsZSB0byByZXN1bWVcblx0XHRpZiggdHlwZW9mIGNvbmZpZy5rZXlib2FyZCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRmb3IoIGtleSBpbiBjb25maWcua2V5Ym9hcmQgKSB7XG5cdFx0XHRcdGlmKCBjb25maWcua2V5Ym9hcmRba2V5XSA9PT0gJ3RvZ2dsZVBhdXNlJyApIHtcblx0XHRcdFx0XHRyZXN1bWVLZXlDb2Rlcy5wdXNoKCBwYXJzZUludCgga2V5LCAxMCApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggaXNQYXVzZWQoKSAmJiByZXN1bWVLZXlDb2Rlcy5pbmRleE9mKCBldmVudC5rZXlDb2RlICkgPT09IC0xICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuXHRcdC8vIDEuIFVzZXIgZGVmaW5lZCBrZXkgYmluZGluZ3Ncblx0XHRpZiggdHlwZW9mIGNvbmZpZy5rZXlib2FyZCA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdGZvcigga2V5IGluIGNvbmZpZy5rZXlib2FyZCApIHtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGlzIGJpbmRpbmcgbWF0Y2hlcyB0aGUgcHJlc3NlZCBrZXlcblx0XHRcdFx0aWYoIHBhcnNlSW50KCBrZXksIDEwICkgPT09IGV2ZW50LmtleUNvZGUgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBjb25maWcua2V5Ym9hcmRbIGtleSBdO1xuXG5cdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdFx0XHRpZiggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0dmFsdWUuYXBwbHkoIG51bGwsIFsgZXZlbnQgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBTdHJpbmcgc2hvcnRjdXRzIHRvIHJldmVhbC5qcyBBUElcblx0XHRcdFx0XHRlbHNlIGlmKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBSZXZlYWxbIHZhbHVlIF0gPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRSZXZlYWxbIHZhbHVlIF0uY2FsbCgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyAyLiBSZWdpc3RlcmVkIGN1c3RvbSBrZXkgYmluZGluZ3Ncblx0XHRpZiggdHJpZ2dlcmVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0Zm9yKCBrZXkgaW4gcmVnaXN0ZXJlZEtleUJpbmRpbmdzICkge1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHRoaXMgYmluZGluZyBtYXRjaGVzIHRoZSBwcmVzc2VkIGtleVxuXHRcdFx0XHRpZiggcGFyc2VJbnQoIGtleSwgMTAgKSA9PT0gZXZlbnQua2V5Q29kZSApIHtcblxuXHRcdFx0XHRcdHZhciBhY3Rpb24gPSByZWdpc3RlcmVkS2V5QmluZGluZ3NbIGtleSBdLmNhbGxiYWNrO1xuXG5cdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgZnVuY3Rpb25cblx0XHRcdFx0XHRpZiggdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdGFjdGlvbi5hcHBseSggbnVsbCwgWyBldmVudCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFN0cmluZyBzaG9ydGN1dHMgdG8gcmV2ZWFsLmpzIEFQSVxuXHRcdFx0XHRcdGVsc2UgaWYoIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBSZXZlYWxbIGFjdGlvbiBdID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0UmV2ZWFsWyBhY3Rpb24gXS5jYWxsKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJpZ2dlcmVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMuIFN5c3RlbSBkZWZpbmVkIGtleSBiaW5kaW5nc1xuXHRcdGlmKCB0cmlnZ2VyZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgdHJ1ZSBhbmQgdHJ5IHRvIHByb3ZlIGZhbHNlXG5cdFx0XHR0cmlnZ2VyZWQgPSB0cnVlO1xuXG5cdFx0XHRzd2l0Y2goIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdC8vIHAsIHBhZ2UgdXBcblx0XHRcdFx0Y2FzZSA4MDogY2FzZSAzMzogbmF2aWdhdGVQcmV2KCk7IGJyZWFrO1xuXHRcdFx0XHQvLyBuLCBwYWdlIGRvd25cblx0XHRcdFx0Y2FzZSA3ODogY2FzZSAzNDogbmF2aWdhdGVOZXh0KCk7IGJyZWFrO1xuXHRcdFx0XHQvLyBoLCBsZWZ0XG5cdFx0XHRcdGNhc2UgNzI6IGNhc2UgMzc6IG5hdmlnYXRlTGVmdCgpOyBicmVhaztcblx0XHRcdFx0Ly8gbCwgcmlnaHRcblx0XHRcdFx0Y2FzZSA3NjogY2FzZSAzOTogbmF2aWdhdGVSaWdodCgpOyBicmVhaztcblx0XHRcdFx0Ly8gaywgdXBcblx0XHRcdFx0Y2FzZSA3NTogY2FzZSAzODogbmF2aWdhdGVVcCgpOyBicmVhaztcblx0XHRcdFx0Ly8gaiwgZG93blxuXHRcdFx0XHRjYXNlIDc0OiBjYXNlIDQwOiBuYXZpZ2F0ZURvd24oKTsgYnJlYWs7XG5cdFx0XHRcdC8vIGhvbWVcblx0XHRcdFx0Y2FzZSAzNjogc2xpZGUoIDAgKTsgYnJlYWs7XG5cdFx0XHRcdC8vIGVuZFxuXHRcdFx0XHRjYXNlIDM1OiBzbGlkZSggTnVtYmVyLk1BWF9WQUxVRSApOyBicmVhaztcblx0XHRcdFx0Ly8gc3BhY2Vcblx0XHRcdFx0Y2FzZSAzMjogaXNPdmVydmlldygpID8gZGVhY3RpdmF0ZU92ZXJ2aWV3KCkgOiBldmVudC5zaGlmdEtleSA/IG5hdmlnYXRlUHJldigpIDogbmF2aWdhdGVOZXh0KCk7IGJyZWFrO1xuXHRcdFx0XHQvLyByZXR1cm5cblx0XHRcdFx0Y2FzZSAxMzogaXNPdmVydmlldygpID8gZGVhY3RpdmF0ZU92ZXJ2aWV3KCkgOiB0cmlnZ2VyZWQgPSBmYWxzZTsgYnJlYWs7XG5cdFx0XHRcdC8vIHR3by1zcG90LCBzZW1pY29sb24sIGIsIHYsIHBlcmlvZCwgTG9naXRlY2ggcHJlc2VudGVyIHRvb2xzIFwiYmxhY2sgc2NyZWVuXCIgYnV0dG9uXG5cdFx0XHRcdGNhc2UgNTg6IGNhc2UgNTk6IGNhc2UgNjY6IGNhc2UgODY6IGNhc2UgMTkwOiBjYXNlIDE5MTogdG9nZ2xlUGF1c2UoKTsgYnJlYWs7XG5cdFx0XHRcdC8vIGZcblx0XHRcdFx0Y2FzZSA3MDogZW50ZXJGdWxsc2NyZWVuKCk7IGJyZWFrO1xuXHRcdFx0XHQvLyBhXG5cdFx0XHRcdGNhc2UgNjU6IGlmICggY29uZmlnLmF1dG9TbGlkZVN0b3BwYWJsZSApIHRvZ2dsZUF1dG9TbGlkZSggYXV0b1NsaWRlV2FzUGF1c2VkICk7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGlucHV0IHJlc3VsdGVkIGluIGEgdHJpZ2dlcmVkIGFjdGlvbiB3ZSBzaG91bGQgcHJldmVudFxuXHRcdC8vIHRoZSBicm93c2VycyBkZWZhdWx0IGJlaGF2aW9yXG5cdFx0aWYoIHRyaWdnZXJlZCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHRcdC8vIEVTQyBvciBPIGtleVxuXHRcdGVsc2UgaWYgKCAoIGV2ZW50LmtleUNvZGUgPT09IDI3IHx8IGV2ZW50LmtleUNvZGUgPT09IDc5ICkgJiYgZmVhdHVyZXMudHJhbnNmb3JtczNkICkge1xuXHRcdFx0aWYoIGRvbS5vdmVybGF5ICkge1xuXHRcdFx0XHRjbG9zZU92ZXJsYXkoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0b2dnbGVPdmVydmlldygpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdC8vIElmIGF1dG8tc2xpZGluZyBpcyBlbmFibGVkIHdlIG5lZWQgdG8gY3VlIHVwXG5cdFx0Ly8gYW5vdGhlciB0aW1lb3V0XG5cdFx0Y3VlQXV0b1NsaWRlKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50LCBlbmFibGVzIHN1cHBvcnQgZm9yXG5cdCAqIHN3aXBlIGFuZCBwaW5jaCBnZXN0dXJlcy5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdFx0aWYoIGlzU3dpcGVQcmV2ZW50ZWQoIGV2ZW50LnRhcmdldCApICkgcmV0dXJuIHRydWU7XG5cblx0XHR0b3VjaC5zdGFydFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0dG91Y2guc3RhcnRZID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuXHRcdHRvdWNoLnN0YXJ0Q291bnQgPSBldmVudC50b3VjaGVzLmxlbmd0aDtcblxuXHRcdC8vIElmIHRoZXJlJ3MgdHdvIHRvdWNoZXMgd2UgbmVlZCB0byBtZW1vcml6ZSB0aGUgZGlzdGFuY2Vcblx0XHQvLyBiZXR3ZWVuIHRob3NlIHR3byBwb2ludHMgdG8gZGV0ZWN0IHBpbmNoaW5nXG5cdFx0aWYoIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAyICYmIGNvbmZpZy5vdmVydmlldyApIHtcblx0XHRcdHRvdWNoLnN0YXJ0U3BhbiA9IGRpc3RhbmNlQmV0d2Vlbigge1xuXHRcdFx0XHR4OiBldmVudC50b3VjaGVzWzFdLmNsaWVudFgsXG5cdFx0XHRcdHk6IGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuXHRcdFx0fSwge1xuXHRcdFx0XHR4OiB0b3VjaC5zdGFydFgsXG5cdFx0XHRcdHk6IHRvdWNoLnN0YXJ0WVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHRoZSAndG91Y2htb3ZlJyBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiggaXNTd2lwZVByZXZlbnRlZCggZXZlbnQudGFyZ2V0ICkgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdC8vIEVhY2ggdG91Y2ggc2hvdWxkIG9ubHkgdHJpZ2dlciBvbmUgYWN0aW9uXG5cdFx0aWYoICF0b3VjaC5jYXB0dXJlZCApIHtcblx0XHRcdG9uVXNlcklucHV0KCBldmVudCApO1xuXG5cdFx0XHR2YXIgY3VycmVudFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG5cdFx0XHR2YXIgY3VycmVudFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG5cblx0XHRcdC8vIElmIHRoZSB0b3VjaCBzdGFydGVkIHdpdGggdHdvIHBvaW50cyBhbmQgc3RpbGwgaGFzXG5cdFx0XHQvLyB0d28gYWN0aXZlIHRvdWNoZXM7IHRlc3QgZm9yIHRoZSBwaW5jaCBnZXN0dXJlXG5cdFx0XHRpZiggZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIgJiYgdG91Y2guc3RhcnRDb3VudCA9PT0gMiAmJiBjb25maWcub3ZlcnZpZXcgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIGN1cnJlbnQgZGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW4gdGhlIHR3byB0b3VjaCBwb2ludHNcblx0XHRcdFx0dmFyIGN1cnJlbnRTcGFuID0gZGlzdGFuY2VCZXR3ZWVuKCB7XG5cdFx0XHRcdFx0eDogZXZlbnQudG91Y2hlc1sxXS5jbGllbnRYLFxuXHRcdFx0XHRcdHk6IGV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0eDogdG91Y2guc3RhcnRYLFxuXHRcdFx0XHRcdHk6IHRvdWNoLnN0YXJ0WVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHNwYW4gaXMgbGFyZ2VyIHRoYW4gdGhlIGRlc2lyZSBhbW91bnQgd2UndmUgZ290XG5cdFx0XHRcdC8vIG91cnNlbHZlcyBhIHBpbmNoXG5cdFx0XHRcdGlmKCBNYXRoLmFicyggdG91Y2guc3RhcnRTcGFuIC0gY3VycmVudFNwYW4gKSA+IHRvdWNoLnRocmVzaG9sZCApIHtcblx0XHRcdFx0XHR0b3VjaC5jYXB0dXJlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiggY3VycmVudFNwYW4gPCB0b3VjaC5zdGFydFNwYW4gKSB7XG5cdFx0XHRcdFx0XHRhY3RpdmF0ZU92ZXJ2aWV3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGVhY3RpdmF0ZU92ZXJ2aWV3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhlcmUgd2FzIG9ubHkgb25lIHRvdWNoIHBvaW50LCBsb29rIGZvciBhIHN3aXBlXG5cdFx0XHRlbHNlIGlmKCBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiB0b3VjaC5zdGFydENvdW50ICE9PSAyICkge1xuXG5cdFx0XHRcdHZhciBkZWx0YVggPSBjdXJyZW50WCAtIHRvdWNoLnN0YXJ0WCxcblx0XHRcdFx0XHRkZWx0YVkgPSBjdXJyZW50WSAtIHRvdWNoLnN0YXJ0WTtcblxuXHRcdFx0XHRpZiggZGVsdGFYID4gdG91Y2gudGhyZXNob2xkICYmIE1hdGguYWJzKCBkZWx0YVggKSA+IE1hdGguYWJzKCBkZWx0YVkgKSApIHtcblx0XHRcdFx0XHR0b3VjaC5jYXB0dXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0bmF2aWdhdGVMZWZ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiggZGVsdGFYIDwgLXRvdWNoLnRocmVzaG9sZCAmJiBNYXRoLmFicyggZGVsdGFYICkgPiBNYXRoLmFicyggZGVsdGFZICkgKSB7XG5cdFx0XHRcdFx0dG91Y2guY2FwdHVyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdG5hdmlnYXRlUmlnaHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBkZWx0YVkgPiB0b3VjaC50aHJlc2hvbGQgKSB7XG5cdFx0XHRcdFx0dG91Y2guY2FwdHVyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdG5hdmlnYXRlVXAoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCBkZWx0YVkgPCAtdG91Y2gudGhyZXNob2xkICkge1xuXHRcdFx0XHRcdHRvdWNoLmNhcHR1cmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRuYXZpZ2F0ZURvd24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHdlJ3JlIGVtYmVkZGVkLCBvbmx5IGJsb2NrIHRvdWNoIGV2ZW50cyBpZiB0aGV5IGhhdmVcblx0XHRcdFx0Ly8gdHJpZ2dlcmVkIGFuIGFjdGlvblxuXHRcdFx0XHRpZiggY29uZmlnLmVtYmVkZGVkICkge1xuXHRcdFx0XHRcdGlmKCB0b3VjaC5jYXB0dXJlZCB8fCBpc1ZlcnRpY2FsU2xpZGUoIGN1cnJlbnRTbGlkZSApICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTm90IGVtYmVkZGVkPyBCbG9jayB0aGVtIGFsbCB0byBhdm9pZCBuZWVkbGVzcyB0b3NzaW5nXG5cdFx0XHRcdC8vIGFyb3VuZCBvZiB0aGUgdmlld3BvcnQgaW4gaU9TXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBUaGVyZSdzIGEgYnVnIHdpdGggc3dpcGluZyBvbiBzb21lIEFuZHJvaWQgZGV2aWNlcyB1bmxlc3Ncblx0XHQvLyB0aGUgZGVmYXVsdCBhY3Rpb24gaXMgYWx3YXlzIHByZXZlbnRlZFxuXHRcdGVsc2UgaWYoIFVBLm1hdGNoKCAvYW5kcm9pZC9naSApICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB0aGUgJ3RvdWNoZW5kJyBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvblRvdWNoRW5kKCBldmVudCApIHtcblxuXHRcdHRvdWNoLmNhcHR1cmVkID0gZmFsc2U7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHBvaW50ZXIgZG93biB0byB0b3VjaCBzdGFydC5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvblBvaW50ZXJEb3duKCBldmVudCApIHtcblxuXHRcdGlmKCBldmVudC5wb2ludGVyVHlwZSA9PT0gZXZlbnQuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiApIHtcblx0XHRcdGV2ZW50LnRvdWNoZXMgPSBbeyBjbGllbnRYOiBldmVudC5jbGllbnRYLCBjbGllbnRZOiBldmVudC5jbGllbnRZIH1dO1xuXHRcdFx0b25Ub3VjaFN0YXJ0KCBldmVudCApO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgcG9pbnRlciBtb3ZlIHRvIHRvdWNoIG1vdmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gb25Qb2ludGVyTW92ZSggZXZlbnQgKSB7XG5cblx0XHRpZiggZXZlbnQucG9pbnRlclR5cGUgPT09IGV2ZW50Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgKSAge1xuXHRcdFx0ZXZlbnQudG91Y2hlcyA9IFt7IGNsaWVudFg6IGV2ZW50LmNsaWVudFgsIGNsaWVudFk6IGV2ZW50LmNsaWVudFkgfV07XG5cdFx0XHRvblRvdWNoTW92ZSggZXZlbnQgKTtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHBvaW50ZXIgdXAgdG8gdG91Y2ggZW5kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcblx0ICovXG5cdGZ1bmN0aW9uIG9uUG9pbnRlclVwKCBldmVudCApIHtcblxuXHRcdGlmKCBldmVudC5wb2ludGVyVHlwZSA9PT0gZXZlbnQuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiApICB7XG5cdFx0XHRldmVudC50b3VjaGVzID0gW3sgY2xpZW50WDogZXZlbnQuY2xpZW50WCwgY2xpZW50WTogZXZlbnQuY2xpZW50WSB9XTtcblx0XHRcdG9uVG91Y2hFbmQoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBtb3VzZSB3aGVlbCBzY3JvbGxpbmcsIHRocm90dGxlZCB0byBhdm9pZCBza2lwcGluZ1xuXHQgKiBtdWx0aXBsZSBzbGlkZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlU2Nyb2xsKCBldmVudCApIHtcblxuXHRcdGlmKCBEYXRlLm5vdygpIC0gbGFzdE1vdXNlV2hlZWxTdGVwID4gNjAwICkge1xuXG5cdFx0XHRsYXN0TW91c2VXaGVlbFN0ZXAgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHR2YXIgZGVsdGEgPSBldmVudC5kZXRhaWwgfHwgLWV2ZW50LndoZWVsRGVsdGE7XG5cdFx0XHRpZiggZGVsdGEgPiAwICkge1xuXHRcdFx0XHRuYXZpZ2F0ZU5leHQoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIGRlbHRhIDwgMCApIHtcblx0XHRcdFx0bmF2aWdhdGVQcmV2KCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDbGlja2luZyBvbiB0aGUgcHJvZ3Jlc3MgYmFyIHJlc3VsdHMgaW4gYSBuYXZpZ2F0aW9uIHRvIHRoZVxuXHQgKiBjbG9zZXN0IGFwcHJveGltYXRlIGhvcml6b250YWwgc2xpZGUgdXNpbmcgdGhpcyBlcXVhdGlvbjpcblx0ICpcblx0ICogKCBjbGlja1ggLyBwcmVzZW50YXRpb25XaWR0aCApICogbnVtYmVyT2ZTbGlkZXNcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBvblByb2dyZXNzQ2xpY2tlZCggZXZlbnQgKSB7XG5cblx0XHRvblVzZXJJbnB1dCggZXZlbnQgKTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR2YXIgc2xpZGVzVG90YWwgPSB0b0FycmF5KCBkb20ud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCBIT1JJWk9OVEFMX1NMSURFU19TRUxFQ1RPUiApICkubGVuZ3RoO1xuXHRcdHZhciBzbGlkZUluZGV4ID0gTWF0aC5mbG9vciggKCBldmVudC5jbGllbnRYIC8gZG9tLndyYXBwZXIub2Zmc2V0V2lkdGggKSAqIHNsaWRlc1RvdGFsICk7XG5cblx0XHRpZiggY29uZmlnLnJ0bCApIHtcblx0XHRcdHNsaWRlSW5kZXggPSBzbGlkZXNUb3RhbCAtIHNsaWRlSW5kZXg7XG5cdFx0fVxuXG5cdFx0c2xpZGUoIHNsaWRlSW5kZXggKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEV2ZW50IGhhbmRsZXIgZm9yIG5hdmlnYXRpb24gY29udHJvbCBidXR0b25zLlxuXHQgKi9cblx0ZnVuY3Rpb24gb25OYXZpZ2F0ZUxlZnRDbGlja2VkKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgb25Vc2VySW5wdXQoKTsgbmF2aWdhdGVMZWZ0KCk7IH1cblx0ZnVuY3Rpb24gb25OYXZpZ2F0ZVJpZ2h0Q2xpY2tlZCggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uVXNlcklucHV0KCk7IG5hdmlnYXRlUmlnaHQoKTsgfVxuXHRmdW5jdGlvbiBvbk5hdmlnYXRlVXBDbGlja2VkKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgb25Vc2VySW5wdXQoKTsgbmF2aWdhdGVVcCgpOyB9XG5cdGZ1bmN0aW9uIG9uTmF2aWdhdGVEb3duQ2xpY2tlZCggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uVXNlcklucHV0KCk7IG5hdmlnYXRlRG93bigpOyB9XG5cdGZ1bmN0aW9uIG9uTmF2aWdhdGVQcmV2Q2xpY2tlZCggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uVXNlcklucHV0KCk7IG5hdmlnYXRlUHJldigpOyB9XG5cdGZ1bmN0aW9uIG9uTmF2aWdhdGVOZXh0Q2xpY2tlZCggZXZlbnQgKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uVXNlcklucHV0KCk7IG5hdmlnYXRlTmV4dCgpOyB9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgbGV2ZWwgJ2hhc2hjaGFuZ2UnIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2V2ZW50XVxuXHQgKi9cblx0ZnVuY3Rpb24gb25XaW5kb3dIYXNoQ2hhbmdlKCBldmVudCApIHtcblxuXHRcdHJlYWRVUkwoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgbGV2ZWwgJ3Jlc2l6ZScgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbZXZlbnRdXG5cdCAqL1xuXHRmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSggZXZlbnQgKSB7XG5cblx0XHRsYXlvdXQoKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBmb3IgdGhlIHdpbmRvdyBsZXZlbCAndmlzaWJpbGl0eWNoYW5nZScgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbZXZlbnRdXG5cdCAqL1xuXHRmdW5jdGlvbiBvblBhZ2VWaXNpYmlsaXR5Q2hhbmdlKCBldmVudCApIHtcblxuXHRcdHZhciBpc0hpZGRlbiA9ICBkb2N1bWVudC53ZWJraXRIaWRkZW4gfHxcblx0XHRcdFx0XHRcdGRvY3VtZW50Lm1zSGlkZGVuIHx8XG5cdFx0XHRcdFx0XHRkb2N1bWVudC5oaWRkZW47XG5cblx0XHQvLyBJZiwgYWZ0ZXIgY2xpY2tpbmcgYSBsaW5rIG9yIHNpbWlsYXIgYW5kIHdlJ3JlIGNvbWluZyBiYWNrLFxuXHRcdC8vIGZvY3VzIHRoZSBkb2N1bWVudC5ib2R5IHRvIGVuc3VyZSB3ZSBjYW4gdXNlIGtleWJvYXJkIHNob3J0Y3V0c1xuXHRcdGlmKCBpc0hpZGRlbiA9PT0gZmFsc2UgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdC8vIE5vdCBhbGwgZWxlbWVudHMgc3VwcG9ydCAuYmx1cigpIC0gU1ZHcyBhbW9uZyB0aGVtLlxuXHRcdFx0aWYoIHR5cGVvZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdFx0fVxuXHRcdFx0ZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEludm9rZWQgd2hlbiBhIHNsaWRlIGlzIGFuZCB3ZSdyZSBpbiB0aGUgb3ZlcnZpZXcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gb25PdmVydmlld1NsaWRlQ2xpY2tlZCggZXZlbnQgKSB7XG5cblx0XHQvLyBUT0RPIFRoZXJlJ3MgYSBidWcgaGVyZSB3aGVyZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGFyZSBub3Rcblx0XHQvLyByZW1vdmVkIGFmdGVyIGRlYWN0aXZhdGluZyB0aGUgb3ZlcnZpZXcuXG5cdFx0aWYoIGV2ZW50c0FyZUJvdW5kICYmIGlzT3ZlcnZpZXcoKSApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHR3aGlsZSggZWxlbWVudCAmJiAhZWxlbWVudC5ub2RlTmFtZS5tYXRjaCggL3NlY3Rpb24vZ2kgKSApIHtcblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGVsZW1lbnQgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCAnZGlzYWJsZWQnICkgKSB7XG5cblx0XHRcdFx0ZGVhY3RpdmF0ZU92ZXJ2aWV3KCk7XG5cblx0XHRcdFx0aWYoIGVsZW1lbnQubm9kZU5hbWUubWF0Y2goIC9zZWN0aW9uL2dpICkgKSB7XG5cdFx0XHRcdFx0dmFyIGggPSBwYXJzZUludCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdkYXRhLWluZGV4LWgnICksIDEwICksXG5cdFx0XHRcdFx0XHR2ID0gcGFyc2VJbnQoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1pbmRleC12JyApLCAxMCApO1xuXG5cdFx0XHRcdFx0c2xpZGUoIGgsIHYgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBjbGlja3Mgb24gbGlua3MgdGhhdCBhcmUgc2V0IHRvIHByZXZpZXcgaW4gdGhlXG5cdCAqIGlmcmFtZSBvdmVybGF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcblx0ICovXG5cdGZ1bmN0aW9uIG9uUHJldmlld0xpbmtDbGlja2VkKCBldmVudCApIHtcblxuXHRcdGlmKCBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQuaGFzQXR0cmlidXRlKCAnaHJlZicgKSApIHtcblx0XHRcdHZhciB1cmwgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSggJ2hyZWYnICk7XG5cdFx0XHRpZiggdXJsICkge1xuXHRcdFx0XHRzaG93UHJldmlldyggdXJsICk7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBjbGljayBvbiB0aGUgYXV0by1zbGlkaW5nIGNvbnRyb2xzIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbZXZlbnRdXG5cdCAqL1xuXHRmdW5jdGlvbiBvbkF1dG9TbGlkZVBsYXllckNsaWNrKCBldmVudCApIHtcblxuXHRcdC8vIFJlcGxheVxuXHRcdGlmKCBSZXZlYWwuaXNMYXN0U2xpZGUoKSAmJiBjb25maWcubG9vcCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRzbGlkZSggMCwgMCApO1xuXHRcdFx0cmVzdW1lQXV0b1NsaWRlKCk7XG5cdFx0fVxuXHRcdC8vIFJlc3VtZVxuXHRcdGVsc2UgaWYoIGF1dG9TbGlkZVBhdXNlZCApIHtcblx0XHRcdHJlc3VtZUF1dG9TbGlkZSgpO1xuXHRcdH1cblx0XHQvLyBQYXVzZVxuXHRcdGVsc2Uge1xuXHRcdFx0cGF1c2VBdXRvU2xpZGUoKTtcblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUExBWUJBQ0sgQ09NUE9ORU5UIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIHBsYXliYWNrIGNvbXBvbmVudCwgd2hpY2ggZGlzcGxheXNcblx0ICogcGxheS9wYXVzZS9wcm9ncmVzcyBjb250cm9scy5cblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBjb21wb25lbnQgd2lsbCBhcHBlbmRcblx0ICogaXRzZWxmIHRvIHRoaXNcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3NDaGVjayBBIG1ldGhvZCB3aGljaCB3aWxsIGJlXG5cdCAqIGNhbGxlZCBmcmVxdWVudGx5IHRvIGdldCB0aGUgY3VycmVudCBwcm9ncmVzcyBvbiBhIHJhbmdlXG5cdCAqIG9mIDAtMVxuXHQgKi9cblx0ZnVuY3Rpb24gUGxheWJhY2soIGNvbnRhaW5lciwgcHJvZ3Jlc3NDaGVjayApIHtcblxuXHRcdC8vIENvc21ldGljc1xuXHRcdHRoaXMuZGlhbWV0ZXIgPSAxMDA7XG5cdFx0dGhpcy5kaWFtZXRlcjIgPSB0aGlzLmRpYW1ldGVyLzI7XG5cdFx0dGhpcy50aGlja25lc3MgPSA2O1xuXG5cdFx0Ly8gRmxhZ3MgaWYgd2UgYXJlIGN1cnJlbnRseSBwbGF5aW5nXG5cdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XG5cblx0XHQvLyBDdXJyZW50IHByb2dyZXNzIG9uIGEgMC0xIHJhbmdlXG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cblx0XHQvLyBVc2VkIHRvIGxvb3AgdGhlIGFuaW1hdGlvbiBzbW9vdGhseVxuXHRcdHRoaXMucHJvZ3Jlc3NPZmZzZXQgPSAxO1xuXG5cdFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0dGhpcy5wcm9ncmVzc0NoZWNrID0gcHJvZ3Jlc3NDaGVjaztcblxuXHRcdHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHR0aGlzLmNhbnZhcy5jbGFzc05hbWUgPSAncGxheWJhY2snO1xuXHRcdHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5kaWFtZXRlcjtcblx0XHR0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmRpYW1ldGVyO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5kaWFtZXRlcjIgKyAncHgnO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuZGlhbWV0ZXIyICsgJ3B4Jztcblx0XHR0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5jYW52YXMgKTtcblxuXHRcdHRoaXMucmVuZGVyKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICovXG5cdFBsYXliYWNrLnByb3RvdHlwZS5zZXRQbGF5aW5nID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0dmFyIHdhc1BsYXlpbmcgPSB0aGlzLnBsYXlpbmc7XG5cblx0XHR0aGlzLnBsYXlpbmcgPSB2YWx1ZTtcblxuXHRcdC8vIFN0YXJ0IHJlcGFpbnRpbmcgaWYgd2Ugd2VyZW4ndCBhbHJlYWR5XG5cdFx0aWYoICF3YXNQbGF5aW5nICYmIHRoaXMucGxheWluZyApIHtcblx0XHRcdHRoaXMuYW5pbWF0ZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0fVxuXG5cdH07XG5cblx0UGxheWJhY2sucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBwcm9ncmVzc0JlZm9yZSA9IHRoaXMucHJvZ3Jlc3M7XG5cblx0XHR0aGlzLnByb2dyZXNzID0gdGhpcy5wcm9ncmVzc0NoZWNrKCk7XG5cblx0XHQvLyBXaGVuIHdlIGxvb3AsIG9mZnNldCB0aGUgcHJvZ3Jlc3Mgc28gdGhhdCBpdCBlYXNlc1xuXHRcdC8vIHNtb290aGx5IHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IHJlc2V0dGluZ1xuXHRcdGlmKCBwcm9ncmVzc0JlZm9yZSA+IDAuOCAmJiB0aGlzLnByb2dyZXNzIDwgMC4yICkge1xuXHRcdFx0dGhpcy5wcm9ncmVzc09mZnNldCA9IHRoaXMucHJvZ3Jlc3M7XG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXIoKTtcblxuXHRcdGlmKCB0aGlzLnBsYXlpbmcgKSB7XG5cdFx0XHRmZWF0dXJlcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVNZXRob2QuY2FsbCggd2luZG93LCB0aGlzLmFuaW1hdGUuYmluZCggdGhpcyApICk7XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgYW5kIHBsYXliYWNrIHN0YXRlLlxuXHQgKi9cblx0UGxheWJhY2sucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHByb2dyZXNzID0gdGhpcy5wbGF5aW5nID8gdGhpcy5wcm9ncmVzcyA6IDAsXG5cdFx0XHRyYWRpdXMgPSAoIHRoaXMuZGlhbWV0ZXIyICkgLSB0aGlzLnRoaWNrbmVzcyxcblx0XHRcdHggPSB0aGlzLmRpYW1ldGVyMixcblx0XHRcdHkgPSB0aGlzLmRpYW1ldGVyMixcblx0XHRcdGljb25TaXplID0gMjg7XG5cblx0XHQvLyBFYXNlIHRvd2FyZHMgMVxuXHRcdHRoaXMucHJvZ3Jlc3NPZmZzZXQgKz0gKCAxIC0gdGhpcy5wcm9ncmVzc09mZnNldCApICogMC4xO1xuXG5cdFx0dmFyIGVuZEFuZ2xlID0gKCAtIE1hdGguUEkgLyAyICkgKyAoIHByb2dyZXNzICogKCBNYXRoLlBJICogMiApICk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSAoIC0gTWF0aC5QSSAvIDIgKSArICggdGhpcy5wcm9ncmVzc09mZnNldCAqICggTWF0aC5QSSAqIDIgKSApO1xuXG5cdFx0dGhpcy5jb250ZXh0LnNhdmUoKTtcblx0XHR0aGlzLmNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB0aGlzLmRpYW1ldGVyLCB0aGlzLmRpYW1ldGVyICk7XG5cblx0XHQvLyBTb2xpZCBiYWNrZ3JvdW5kIGNvbG9yXG5cdFx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMuY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cyArIDQsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSApO1xuXHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSggMCwgMCwgMCwgMC40ICknO1xuXHRcdHRoaXMuY29udGV4dC5maWxsKCk7XG5cblx0XHQvLyBEcmF3IHByb2dyZXNzIHRyYWNrXG5cdFx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdHRoaXMuY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlICk7XG5cdFx0dGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMudGhpY2tuZXNzO1xuXHRcdHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCAyNTUsIDI1NSwgMjU1LCAwLjIgKSc7XG5cdFx0dGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuXG5cdFx0aWYoIHRoaXMucGxheWluZyApIHtcblx0XHRcdC8vIERyYXcgcHJvZ3Jlc3Mgb24gdG9wIG9mIHRyYWNrXG5cdFx0XHR0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLmNvbnRleHQuYXJjKCB4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSApO1xuXHRcdFx0dGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMudGhpY2tuZXNzO1xuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gJyNmZmYnO1xuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuY29udGV4dC50cmFuc2xhdGUoIHggLSAoIGljb25TaXplIC8gMiApLCB5IC0gKCBpY29uU2l6ZSAvIDIgKSApO1xuXG5cdFx0Ly8gRHJhdyBwbGF5L3BhdXNlIGljb25zXG5cdFx0aWYoIHRoaXMucGxheWluZyApIHtcblx0XHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSAnI2ZmZic7XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIGljb25TaXplIC8gMiAtIDQsIGljb25TaXplICk7XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFJlY3QoIGljb25TaXplIC8gMiArIDQsIDAsIGljb25TaXplIC8gMiAtIDQsIGljb25TaXplICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5jb250ZXh0LnRyYW5zbGF0ZSggNCwgMCApO1xuXHRcdFx0dGhpcy5jb250ZXh0Lm1vdmVUbyggMCwgMCApO1xuXHRcdFx0dGhpcy5jb250ZXh0LmxpbmVUbyggaWNvblNpemUgLSA0LCBpY29uU2l6ZSAvIDIgKTtcblx0XHRcdHRoaXMuY29udGV4dC5saW5lVG8oIDAsIGljb25TaXplICk7XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGwoKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuXG5cdH07XG5cblx0UGxheWJhY2sucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oIHR5cGUsIGxpc3RlbmVyICkge1xuXHRcdHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSApO1xuXHR9O1xuXG5cdFBsYXliYWNrLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKSB7XG5cdFx0dGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIsIGZhbHNlICk7XG5cdH07XG5cblx0UGxheWJhY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMucGxheWluZyA9IGZhbHNlO1xuXG5cdFx0aWYoIHRoaXMuY2FudmFzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCggdGhpcy5jYW52YXMgKTtcblx0XHR9XG5cblx0fTtcblxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cblxuXHRSZXZlYWwgPSB7XG5cdFx0VkVSU0lPTjogVkVSU0lPTixcblxuXHRcdGluaXRpYWxpemU6IGluaXRpYWxpemUsXG5cdFx0Y29uZmlndXJlOiBjb25maWd1cmUsXG5cblx0XHRzeW5jOiBzeW5jLFxuXHRcdHN5bmNTbGlkZTogc3luY1NsaWRlLFxuXHRcdHN5bmNGcmFnbWVudHM6IHN5bmNGcmFnbWVudHMsXG5cblx0XHQvLyBOYXZpZ2F0aW9uIG1ldGhvZHNcblx0XHRzbGlkZTogc2xpZGUsXG5cdFx0bGVmdDogbmF2aWdhdGVMZWZ0LFxuXHRcdHJpZ2h0OiBuYXZpZ2F0ZVJpZ2h0LFxuXHRcdHVwOiBuYXZpZ2F0ZVVwLFxuXHRcdGRvd246IG5hdmlnYXRlRG93bixcblx0XHRwcmV2OiBuYXZpZ2F0ZVByZXYsXG5cdFx0bmV4dDogbmF2aWdhdGVOZXh0LFxuXG5cdFx0Ly8gRnJhZ21lbnQgbWV0aG9kc1xuXHRcdG5hdmlnYXRlRnJhZ21lbnQ6IG5hdmlnYXRlRnJhZ21lbnQsXG5cdFx0cHJldkZyYWdtZW50OiBwcmV2aW91c0ZyYWdtZW50LFxuXHRcdG5leHRGcmFnbWVudDogbmV4dEZyYWdtZW50LFxuXG5cdFx0Ly8gRGVwcmVjYXRlZCBhbGlhc2VzXG5cdFx0bmF2aWdhdGVUbzogc2xpZGUsXG5cdFx0bmF2aWdhdGVMZWZ0OiBuYXZpZ2F0ZUxlZnQsXG5cdFx0bmF2aWdhdGVSaWdodDogbmF2aWdhdGVSaWdodCxcblx0XHRuYXZpZ2F0ZVVwOiBuYXZpZ2F0ZVVwLFxuXHRcdG5hdmlnYXRlRG93bjogbmF2aWdhdGVEb3duLFxuXHRcdG5hdmlnYXRlUHJldjogbmF2aWdhdGVQcmV2LFxuXHRcdG5hdmlnYXRlTmV4dDogbmF2aWdhdGVOZXh0LFxuXG5cdFx0Ly8gRm9yY2VzIGFuIHVwZGF0ZSBpbiBzbGlkZSBsYXlvdXRcblx0XHRsYXlvdXQ6IGxheW91dCxcblxuXHRcdC8vIFJhbmRvbWl6ZXMgdGhlIG9yZGVyIG9mIHNsaWRlc1xuXHRcdHNodWZmbGU6IHNodWZmbGUsXG5cblx0XHQvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBhdmFpbGFibGUgcm91dGVzIGFzIGJvb2xlYW5zIChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20pXG5cdFx0YXZhaWxhYmxlUm91dGVzOiBhdmFpbGFibGVSb3V0ZXMsXG5cblx0XHQvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBhdmFpbGFibGUgZnJhZ21lbnRzIGFzIGJvb2xlYW5zIChwcmV2L25leHQpXG5cdFx0YXZhaWxhYmxlRnJhZ21lbnRzOiBhdmFpbGFibGVGcmFnbWVudHMsXG5cblx0XHQvLyBUb2dnbGVzIGEgaGVscCBvdmVybGF5IHdpdGgga2V5Ym9hcmQgc2hvcnRjdXRzXG5cdFx0dG9nZ2xlSGVscDogdG9nZ2xlSGVscCxcblxuXHRcdC8vIFRvZ2dsZXMgdGhlIG92ZXJ2aWV3IG1vZGUgb24vb2ZmXG5cdFx0dG9nZ2xlT3ZlcnZpZXc6IHRvZ2dsZU92ZXJ2aWV3LFxuXG5cdFx0Ly8gVG9nZ2xlcyB0aGUgXCJibGFjayBzY3JlZW5cIiBtb2RlIG9uL29mZlxuXHRcdHRvZ2dsZVBhdXNlOiB0b2dnbGVQYXVzZSxcblxuXHRcdC8vIFRvZ2dsZXMgdGhlIGF1dG8gc2xpZGUgbW9kZSBvbi9vZmZcblx0XHR0b2dnbGVBdXRvU2xpZGU6IHRvZ2dsZUF1dG9TbGlkZSxcblxuXHRcdC8vIFN0YXRlIGNoZWNrc1xuXHRcdGlzT3ZlcnZpZXc6IGlzT3ZlcnZpZXcsXG5cdFx0aXNQYXVzZWQ6IGlzUGF1c2VkLFxuXHRcdGlzQXV0b1NsaWRpbmc6IGlzQXV0b1NsaWRpbmcsXG5cdFx0aXNTcGVha2VyTm90ZXM6IGlzU3BlYWtlck5vdGVzLFxuXG5cdFx0Ly8gU2xpZGUgcHJlbG9hZGluZ1xuXHRcdGxvYWRTbGlkZTogbG9hZFNsaWRlLFxuXHRcdHVubG9hZFNsaWRlOiB1bmxvYWRTbGlkZSxcblxuXHRcdC8vIEFkZHMgb3IgcmVtb3ZlcyBhbGwgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzIChzdWNoIGFzIGtleWJvYXJkKVxuXHRcdGFkZEV2ZW50TGlzdGVuZXJzOiBhZGRFdmVudExpc3RlbmVycyxcblx0XHRyZW1vdmVFdmVudExpc3RlbmVyczogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG5cblx0XHQvLyBGYWNpbGl0eSBmb3IgcGVyc2lzdGluZyBhbmQgcmVzdG9yaW5nIHRoZSBwcmVzZW50YXRpb24gc3RhdGVcblx0XHRnZXRTdGF0ZTogZ2V0U3RhdGUsXG5cdFx0c2V0U3RhdGU6IHNldFN0YXRlLFxuXG5cdFx0Ly8gUHJlc2VudGF0aW9uIHByb2dyZXNzXG5cdFx0Z2V0U2xpZGVQYXN0Q291bnQ6IGdldFNsaWRlUGFzdENvdW50LFxuXG5cdFx0Ly8gUHJlc2VudGF0aW9uIHByb2dyZXNzIG9uIHJhbmdlIG9mIDAtMVxuXHRcdGdldFByb2dyZXNzOiBnZXRQcm9ncmVzcyxcblxuXHRcdC8vIFJldHVybnMgdGhlIGluZGljZXMgb2YgdGhlIGN1cnJlbnQsIG9yIHNwZWNpZmllZCwgc2xpZGVcblx0XHRnZXRJbmRpY2VzOiBnZXRJbmRpY2VzLFxuXG5cdFx0Ly8gUmV0dXJucyBhbiBBcnJheSBvZiBhbGwgc2xpZGVzXG5cdFx0Z2V0U2xpZGVzOiBnZXRTbGlkZXMsXG5cblx0XHQvLyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2xpZGVzXG5cdFx0Z2V0VG90YWxTbGlkZXM6IGdldFRvdGFsU2xpZGVzLFxuXG5cdFx0Ly8gUmV0dXJucyB0aGUgc2xpZGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG5cdFx0Z2V0U2xpZGU6IGdldFNsaWRlLFxuXG5cdFx0Ly8gUmV0dXJucyB0aGUgc2xpZGUgYmFja2dyb3VuZCBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcblx0XHRnZXRTbGlkZUJhY2tncm91bmQ6IGdldFNsaWRlQmFja2dyb3VuZCxcblxuXHRcdC8vIFJldHVybnMgdGhlIHNwZWFrZXIgbm90ZXMgc3RyaW5nIGZvciBhIHNsaWRlLCBvciBudWxsXG5cdFx0Z2V0U2xpZGVOb3RlczogZ2V0U2xpZGVOb3RlcyxcblxuXHRcdC8vIFJldHVybnMgdGhlIHByZXZpb3VzIHNsaWRlIGVsZW1lbnQsIG1heSBiZSBudWxsXG5cdFx0Z2V0UHJldmlvdXNTbGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXNTbGlkZTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzbGlkZSBlbGVtZW50XG5cdFx0Z2V0Q3VycmVudFNsaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjdXJyZW50U2xpZGU7XG5cdFx0fSxcblxuXHRcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2NhbGUgb2YgdGhlIHByZXNlbnRhdGlvbiBjb250ZW50XG5cdFx0Z2V0U2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHNjYWxlO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdFx0Z2V0Q29uZmlnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjb25maWc7XG5cdFx0fSxcblxuXHRcdC8vIEhlbHBlciBtZXRob2QsIHJldHJpZXZlcyBxdWVyeSBzdHJpbmcgYXMgYSBrZXkvdmFsdWUgaGFzaFxuXHRcdGdldFF1ZXJ5SGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcXVlcnkgPSB7fTtcblxuXHRcdFx0bG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoIC9bQS1aMC05XSs/PShbXFx3XFwuJS1dKikvZ2ksIGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0cXVlcnlbIGEuc3BsaXQoICc9JyApLnNoaWZ0KCkgXSA9IGEuc3BsaXQoICc9JyApLnBvcCgpO1xuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBCYXNpYyBkZXNlcmlhbGl6YXRpb25cblx0XHRcdGZvciggdmFyIGkgaW4gcXVlcnkgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHF1ZXJ5WyBpIF07XG5cblx0XHRcdFx0cXVlcnlbIGkgXSA9IGRlc2VyaWFsaXplKCB1bmVzY2FwZSggdmFsdWUgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcXVlcnk7XG5cdFx0fSxcblxuXHRcdC8vIFJldHVybnMgdHJ1ZSBpZiB3ZSdyZSBjdXJyZW50bHkgb24gdGhlIGZpcnN0IHNsaWRlXG5cdFx0aXNGaXJzdFNsaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAoIGluZGV4aCA9PT0gMCAmJiBpbmRleHYgPT09IDAgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJucyB0cnVlIGlmIHdlJ3JlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzbGlkZVxuXHRcdGlzTGFzdFNsaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCBjdXJyZW50U2xpZGUgKSB7XG5cdFx0XHRcdC8vIERvZXMgdGhpcyBzbGlkZSBoYXZlIGEgbmV4dCBzaWJsaW5nP1xuXHRcdFx0XHRpZiggY3VycmVudFNsaWRlLm5leHRFbGVtZW50U2libGluZyApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHQvLyBJZiBpdCdzIHZlcnRpY2FsLCBkb2VzIGl0cyBwYXJlbnQgaGF2ZSBhIG5leHQgc2libGluZz9cblx0XHRcdFx0aWYoIGlzVmVydGljYWxTbGlkZSggY3VycmVudFNsaWRlICkgJiYgY3VycmVudFNsaWRlLnBhcmVudE5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8vIFJldHVybnMgdHJ1ZSBpZiB3ZSdyZSBvbiB0aGUgbGFzdCBzbGlkZSBpbiB0aGUgY3VycmVudFxuXHRcdC8vIHZlcnRpY2FsIHN0YWNrXG5cdFx0aXNMYXN0VmVydGljYWxTbGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiggY3VycmVudFNsaWRlICYmIGlzVmVydGljYWxTbGlkZSggY3VycmVudFNsaWRlICkgKSB7XG5cdFx0XHRcdC8vIERvZXMgdGhpcyBzbGlkZSBoYXZlIGEgbmV4dCBzaWJsaW5nP1xuXHRcdFx0XHRpZiggY3VycmVudFNsaWRlLm5leHRFbGVtZW50U2libGluZyApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvLyBDaGVja3MgaWYgcmV2ZWFsLmpzIGhhcyBiZWVuIGxvYWRlZCBhbmQgaXMgcmVhZHkgZm9yIHVzZVxuXHRcdGlzUmVhZHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGxvYWRlZDtcblx0XHR9LFxuXG5cdFx0Ly8gRm9yd2FyZCBldmVudCBiaW5kaW5nIHRvIHRoZSByZXZlYWwgRE9NIGVsZW1lbnRcblx0XHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgKSB7XG5cdFx0XHRpZiggJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyApIHtcblx0XHRcdFx0KCBkb20ud3JhcHBlciB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLnJldmVhbCcgKSApLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgKSB7XG5cdFx0XHRpZiggJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyApIHtcblx0XHRcdFx0KCBkb20ud3JhcHBlciB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCAnLnJldmVhbCcgKSApLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFkZHMgYSBjdXN0b20ga2V5IGJpbmRpbmdcblx0XHRhZGRLZXlCaW5kaW5nOiBhZGRLZXlCaW5kaW5nLFxuXG5cdFx0Ly8gUmVtb3ZlcyBhIGN1c3RvbSBrZXkgYmluZGluZ1xuXHRcdHJlbW92ZUtleUJpbmRpbmc6IHJlbW92ZUtleUJpbmRpbmcsXG5cblx0XHQvLyBQcm9ncmFtYXRpY2FsbHkgdHJpZ2dlcnMgYSBrZXlib2FyZCBldmVudFxuXHRcdHRyaWdnZXJLZXk6IGZ1bmN0aW9uKCBrZXlDb2RlICkge1xuXHRcdFx0b25Eb2N1bWVudEtleURvd24oIHsga2V5Q29kZToga2V5Q29kZSB9ICk7XG5cdFx0fSxcblxuXHRcdC8vIFJlZ2lzdGVycyBhIG5ldyBzaG9ydGN1dCB0byBpbmNsdWRlIGluIHRoZSBoZWxwIG92ZXJsYXlcblx0XHRyZWdpc3RlcktleWJvYXJkU2hvcnRjdXQ6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0a2V5Ym9hcmRTaG9ydGN1dHNba2V5XSA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gUmV2ZWFsO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZXZlYWwuanMvanMvcmV2ZWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n");

/***/ }),

/***/ 55:
/***/ (function(module, exports) {

eval("var $ = window.jQuery;\n\n// These seem to be hard-coded into reveal.js.\nvar revealHeight = 700;\nvar revealWidth = 960;\n\nvar fontPixelSize;\n\n$(document).ready(function () {\n  $('#openDynamicOptions').click(window.toggleDynamicOptions);\n\n  fillDynamicOptions();\n  var p;\n\n  if ((p = urlParam('dp-vall')) !== false) {\n    setDisplay(p, 'all', false);\n  }\n  for (var i = 1; i <= countVerses(); i++) {\n    switchVerse(i, 'data-v' + i);\n    if (urlParam('dp-v' + i) !== false) {\n      setDisplay(urlParam('dp-v' + i), i, false);\n    }\n  }\n  alwaysShow('data-vrefrain');\n\n  if ((p = urlParam('dp-noteHeight')) !== false) {\n    setNoteHeight(parseInt(p));\n  }\n  if ((p = urlParam('dp-fontSize')) !== false) {\n    setFontSize(parseInt(p));\n  }\n\n  autosetNotesPerLine();\n\n  var audio = document.getElementById('audio');\n  audio.onended = function () {\n    if (window.Reveal.availableRoutes()['right']) {\n      window.Reveal.right();\n      this.play();\n    }\n  };\n\n  $('#dynamicOptions .copyUrl').click(function () {\n    var text = $('#dynamicOptions span.url').text();\n    var input = $('#dynamicOptions input.url')[0];\n    input.value = text;\n    input.select();\n    document.execCommand('copy');\n  });\n});\n\n/**\n * @brief Set the notes per line automatically based on the breathSections.\n */\nfunction autosetNotesPerLine() {\n  var breathSections = $('.dynamic.original svg:first #breathSections rect');\n  var maxNPL = 0;\n  if (breathSections.length) {\n    for (var i = 0; i < breathSections.length; i++) {\n      var npl = parseInt(breathSections[i].attributes['data-width'].value);\n      if (npl > maxNPL) {\n        maxNPL = npl;\n      }\n    }\n    if (maxNPL >= 1) {\n      return setNotesPerLine(maxNPL);\n    }\n  }\n  return setNotesPerLine(12);\n}\n\nfunction setDisplay(type) {\n  var verse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n  var doSetupPages = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  var options = $('.displayOpts').html().replace(/&amp;/g, '&');\n  if (verse === 'all') {\n    options = '';\n  }\n  var regex = new RegExp('&dp-v' + verse + '=[^&]*', 'g');\n  options = options.replace(regex, '');\n  options += '&dp-v' + verse + '=' + type;\n  $('.displayOpts').html(options);\n\n  if (type === 'lyrics') {\n    hideParts(verse);\n  } else if (type === 'melody') {\n    hideParts(verse);\n    var melodyColor = $('#parts rect[fill]:first-of-type').attr('fill');\n    togglePart(verse, melodyColor);\n  } else if (type === 'harmony') {\n    hideParts(verse, 'show');\n  }\n  resizeSVGHeight();\n  if (doSetupPages) {\n    setupPages();\n  }\n}\n\n/**\n * @brief Change the size of the font for the lyrics.\n */\nfunction setFontSize(s) {\n  $('.fontSize').html(s);\n  fontPixelSize = undefined;\n  $('.dynamic svg g text').each(function () {\n    this.setAttribute('font-size', s + 'pt');\n    this.setAttribute('dy', -1 / 2 * s);\n    squishText(this);\n  });\n  resizeSVGHeight();\n}\n\n/**\n * @brief Set the number of quarter notes to display per line.\n */\nfunction setNotesPerLine(n) {\n  if (n >= 1) {\n    setNoteWidth(revealWidth / n);\n  }\n}\n\n/**\n * @brief Change the size of a notes.\n */\nfunction setNoteHeight(h) {\n  $('.noteHeight').html(h);\n  $('.dynamic svg rect[data-y]').each(function () {\n    var y = parseFloat(this.attributes['data-y']['value']) * h;\n    this.setAttribute('y', y);\n    var height = parseFloat(this.attributes['data-height']['value']) * h;\n    this.setAttribute('height', height);\n  });\n  resizeSVGHeight();\n}\n\nfunction setNoteWidth(w) {\n  var width;\n  $('.dynamic svg [data-x]').each(function () {\n    var x = parseFloat(this.attributes['data-x']['value']) * w;\n    this.setAttribute('x', x);\n    if (typeof this.attributes['data-width'] !== 'undefined') {\n      width = parseFloat(this.attributes['data-width']['value']) * w;\n      this.setAttribute('width', width);\n    } else if (typeof this.attributes['data-tl'] !== 'undefined') {\n      width = parseFloat(this.attributes['data-tl']['value']) * w;\n      this.setAttribute('data-textlength', width);\n      squishText(this);\n    }\n  });\n  resizeSVGWidth();\n}\n\n/**\n * @brief Change the lyrics in a dynamic.svg to a different verse.\n */\nfunction switchVerse(verse, verseAttr) {\n  var hidePrevious = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  var selector = '.dynamic svg g text';\n  if (verse !== 'all') {\n    selector = '#v' + verse + ' ' + selector;\n  }\n\n  if (hidePrevious) {\n    $(selector).each(function () {\n      this.innerHTML = '';\n    });\n  }\n\n  var els = $(selector + '[' + verseAttr + ']');\n  for (var i = 0; i < els.length; i++) {\n    // Remove the hypens that start a syllable. We don't need two hypens per word.\n    var text = $(els[i]).attr(verseAttr).replace(/^[ -]*/, '');\n    // Add a non-breaking space if it is the end of a word.\n    text = text.replace(/([^-])$/, '$1&nbsp;');\n    els[i].innerHTML = text;\n    squishText(els[i]);\n  }\n}\n\n/**\n * @brief Show or hide dynamic options.\n */\nfunction toggleDynamicOptions() {\n  if ($('#dynamicOptions').hasClass('visible')) {\n    $('#dynamicOptions').removeClass('visible');\n  } else {\n    $('#dynamicOptions').addClass('visible');\n  }\n}\n\n/**\n * @brief Show or hide a part from a specific verse.\n */\nfunction togglePart(verse, partColor) {\n  var selector = '.dynamic svg rect[fill=\"' + partColor + '\"]';\n  if (verse !== 'all') {\n    selector = '#v' + verse + ' ' + selector;\n  }\n  $(selector).each(function () {\n    // TODO: Create CSS rule to toggle with less latency.\n    $(this).toggle();\n  });\n}\n\nwindow.autosetNotesPerLine = autosetNotesPerLine;\nwindow.setDisplay = setDisplay;\nwindow.setFontSize = setFontSize;\nwindow.setNotesPerLine = setNotesPerLine;\nwindow.setNoteHeight = setNoteHeight;\nwindow.setNoteWidth = setNoteWidth;\nwindow.switchVerse = switchVerse;\nwindow.toggleDynamicOptions = toggleDynamicOptions;\nwindow.togglePart = togglePart;\n\nfunction alwaysShow(name) {\n  switchVerse('all', name, false);\n}\n\n/**\n * @brief Count the number of verses in this dynamic presentation.\n */\nfunction countVerses() {\n  // Grab the first SVG\n  var svgSelector = '.slides > section:first-of-type > section:first-of-type .dynamic svg';\n  var i;\n  for (i = 1; i < 10; i++) {\n    var selector = svgSelector + ' [data-v' + i + ']';\n    if ($(selector).length === 0) {\n      return i - 1;\n    }\n  }\n  return i;\n}\n\n/**\n * @brief Fill the dynamic options with the controls for this song.\n */\nfunction fillDynamicOptions() {\n  var option = $('<div>');\n  option.html('All Verses');\n  $('#dynamicOptions .viewport-inner').append(option);\n  getDisplaySetter('all', option);\n  for (var i = 1; i <= countVerses(); i++) {\n    option = $('<div>');\n    $(option).addClass('v' + i);\n    option.html('Verse ' + i);\n    $('#dynamicOptions .viewport-inner').append(option);\n    getDisplaySetter(i, option);\n  }\n}\n\n/**\n * @brief Return the current font size of the lyrics, or 0 if there are no lyrics.\n */\nfunction getFontPixelSize() {\n  // Use a global variable to improve speed.\n  if (typeof fontPixelSize === 'undefined') {\n    var size = $('.dynamic svg text[data-v1]').attr('font-size');\n    if (size === undefined) {\n      fontPixelSize = 0;\n    } else if (size.indexOf('pt') !== -1) {\n      fontPixelSize = parseFloat(size.replace('pt', '')) * (4 / 3);\n    } else if (size.indexOf('px') !== -1) {\n      fontPixelSize = parseFloat(size.replace('px', ''));\n    }\n  }\n  return fontPixelSize;\n}\n\n/**\n * @brief Return the current pixel value for the note height.\n */\nfunction getNoteHeight() {\n  var denominator = parseFloat($('.dynamic svg rect[data-height]').attr('data-height'));\n  var numerator = parseInt($('.dynamic svg rect[data-height]').attr('height'));\n  return numerator / denominator;\n}\nfunction getNoteWidth() {\n  var denominator = parseFloat($('.dynamic svg rect[data-width]').attr('data-width'));\n  var numerator = parseInt($('.dynamic svg rect[data-width]').attr('width'));\n  return numerator / denominator;\n}\n\n/**\n * @brief Get the Number of notes tall a specific svg should be.\n */\nfunction getSVGNoteRange(svg) {\n  var parts = $(svg).find('#parts rect');\n  var max = 0;\n  for (var i = 0; i < parts.length; i++) {\n    // togglePart sets display to none.\n    if ($(parts[i]).css('display') !== 'none') {\n      var test = parseFloat($(parts[i]).attr('data-y')) + parseFloat($(parts[i]).attr('data-height'));\n      if (test > max) {\n        max = test;\n      }\n    }\n  }\n  return max;\n}\nfunction getSVGSongLength(svg) {\n  return $(svg).attr('data-songlength');\n}\n\n/**\n * @brief Append HTML for a setting to change the view of different verses.\n */\nfunction getDisplaySetter(verse, section) {\n  var choices = ['lyrics', 'melody', 'harmony'];\n  for (var i = 0; i < choices.length; i++) {\n    var button = $('<button>');\n    $(button).attr('value', choices[i]);\n    $(button).attr('onclick', 'window.setDisplay(this.value, \"' + verse + '\");');\n    $(button).html(choices[i]);\n    $(section).append(button);\n  }\n}\n\n/**\n * @brief Hide all parts of music.\n * @param verse either 'all', or the verse number for which you want to hide parts.\n * @param method optionally \"show\" to show parts instead of hide them.\n */\nfunction hideParts(verse) {\n  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';\n\n  var selector = '.dynamic svg rect[fill]';\n  if (verse !== 'all') {\n    selector = '#v' + verse + ' ' + selector;\n  }\n  $(selector).each(function () {\n    // TODO: Create CSS rule to show/hide with less latency.\n    $(this)[method]();\n  });\n}\n\n/**\n * @brief Reset RevealJS so it detects the changes we've made to the DOM.\n */\nfunction resetReveal() {\n  var indices = window.Reveal.getIndices();\n  window.Reveal.slide(indices.h, indices.v);\n}\n\n/**\n * @brief Resize all SVGs based on the current note height and font size.\n */\nfunction resizeSVGHeight() {\n  var nh = getNoteHeight();\n  var fs = getFontPixelSize();\n  $('svg').each(function () {\n    var noteRange = getSVGNoteRange(this);\n    var h = noteRange * nh + fs * (4 / 3);\n    this.setAttribute('height', h);\n  });\n  setViewBoxes();\n  resetReveal();\n}\n/**\n * @brief Resize all SVGs based on the current note width.\n */\nfunction resizeSVGWidth() {\n  var nw = getNoteWidth();\n  $('svg').each(function () {\n    var songLength = getSVGSongLength(this);\n    this.setAttribute('width', songLength * nw);\n  });\n  setupPages();\n}\n\n/**\n * @brief Create different pages for each verse. Fill them with multiple svg \"lines\".\n *  Note: This function is a little slow. We should only run it when needed.\n */\nfunction setupPages() {\n  var unoriginal = $('.dynamic:not(.original)');\n  // Do this syncronously so we don't have a race condition for item.parentElement.children.length.\n  for (var i = 0; i < unoriginal.length; i++) {\n    var item = unoriginal[i];\n    if (item.parentElement.children.length === 1) {\n      item.parentElement.remove();\n    } else {\n      item.remove();\n    }\n  }\n  $('.dynamic.original svg').each(function () {\n    var slide = $(this).closest('section');\n\n    var numPages = 0;\n    if ($(this).find('#breathSections rect').length > 1) {\n      numPages = $(this).find('#breathSections rect').length;\n    } else {\n      numPages = Math.ceil($(this).attr('width') / revealWidth);\n    }\n    // Start at 1 because page 0 already exists.\n    for (var i = 1; i < numPages; i++) {\n      if (setupPageSlideIsFull(slide)) {\n        slide = setupPageNewSlide(slide);\n      }\n      var child = $('<div>');\n      $(child).addClass('dynamic');\n      $(child).css('opacity', 0);\n      $(child).attr('data-page', i);\n      if (i % 2 === 1) {\n        $(child).addClass('odd');\n      }\n      slide.append(child);\n      $(slide).find('[data-page=\"' + i + '\"]')[0].innerHTML = this.outerHTML;\n    }\n  });\n  setViewBoxes();\n  resetReveal();\n}\n\n/**\n * @brief Create and return a new slide after currentSlide.\n */\nfunction setupPageNewSlide(currentSlide) {\n  var slideGroup = $(currentSlide).closest('section.stack');\n  slideGroup.append($('<section>'));\n  return slideGroup.find('section:last-of-type');\n}\n\n/**\n * @brief return TRUE if slide cannot hold another svg \"line\" in it.\n */\nfunction setupPageSlideIsFull(slide) {\n  var svgHeight = parseInt($(slide).find('.dynamic svg').attr('height'));\n  // Subtract a few pixels from revealHeight\n  // so that there's always at least a little space between each line.\n  var canHold = Math.floor((revealHeight - 50) / svgHeight);\n  var numberOfChildren = $(slide).find('.dynamic svg').length;\n  return numberOfChildren >= canHold;\n}\n\n/**\n * @brief Set the view boxes for each svg \"line\" so they start at the correct x value.\n */\nfunction setViewBoxes() {\n  var sections = $('.dynamic.original svg:first #breathSections rect');\n\n  $('.dynamic svg').each(function () {\n    var x = 0;\n    var pageNum = $(this).closest('[data-page]').attr('data-page');\n    if (sections.length > pageNum && $(sections[pageNum]).attr('width') > 0) {\n      x = sections[pageNum].attributes['x']['value'];\n      $(this).attr('width', sections[pageNum].attributes['width']['value']);\n    } else {\n      x = pageNum * revealWidth;\n    }\n\n    var height = $(this).attr('height');\n    var width = $(this).attr('width');\n    this.setAttribute('viewBox', x + ' 0 ' + width + ' ' + height);\n  });\n  $('.dynamic').css('opacity', 1);\n}\n\n/**\n * @brief Squish text so it doesn't go beyond the boundaries of its box.\n *  Also possibly removes hypens or adds non-breaking spaces to squished text elements.\n * @param el The element that you want to squish the text on.\n * @precondition The text in the element ends with a non-breaking space if it is the end of a word.\n */\nfunction squishText(el) {\n  // If there is no text here, we don't have to do anything.\n  if (typeof el.childNodes[0] === 'undefined') return;\n  var text = el.childNodes[0].nodeValue;\n  // Setting a specific letter width isn't perfect since \"One\" is wider than \"ly,\"\n  var widthPerLetter = getFontPixelSize() * 0.7;\n  var boxWidth = $(el).attr('data-textlength');\n\n  // Add a hyphen if it doesn't end in a hypen or a non-breaking space.\n  if (!text.match(/[\\xA0-]$/)) {\n    text += '-';\n  }\n\n  if (text.length * widthPerLetter >= boxWidth) {\n    // Apply the textLength attribute if we need to squish these letters.\n    $(el).attr('textLength', boxWidth);\n\n    // If we need to squish this letter, it's okay to remove any trailing hyphens,\n    // as long as removing those won't stretch the letter out.\n    // (this syllable is the middle of a word, but is squished against its continuation)\n    if ((text.length - 1) * widthPerLetter >= boxWidth) {\n      text = text.replace(/-$/, '');\n    }\n  } else {\n    $(el).attr('textLength', null);\n  }\n  el.innerHTML = text;\n}\n\nfunction urlParam(name) {\n  var results = new RegExp('[?&]' + name + '=([^&#]*)').exec(window.location.search);\n\n  return results !== null ? results[1] || 0 : false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZHluYW1pYy5qcz84MzI5Il0sIm5hbWVzIjpbIiQiLCJ3aW5kb3ciLCJqUXVlcnkiLCJyZXZlYWxIZWlnaHQiLCJyZXZlYWxXaWR0aCIsImZvbnRQaXhlbFNpemUiLCJkb2N1bWVudCIsInJlYWR5IiwiY2xpY2siLCJ0b2dnbGVEeW5hbWljT3B0aW9ucyIsImZpbGxEeW5hbWljT3B0aW9ucyIsInAiLCJ1cmxQYXJhbSIsInNldERpc3BsYXkiLCJpIiwiY291bnRWZXJzZXMiLCJzd2l0Y2hWZXJzZSIsImFsd2F5c1Nob3ciLCJzZXROb3RlSGVpZ2h0IiwicGFyc2VJbnQiLCJzZXRGb250U2l6ZSIsImF1dG9zZXROb3Rlc1BlckxpbmUiLCJhdWRpbyIsImdldEVsZW1lbnRCeUlkIiwib25lbmRlZCIsIlJldmVhbCIsImF2YWlsYWJsZVJvdXRlcyIsInJpZ2h0IiwicGxheSIsInRleHQiLCJpbnB1dCIsInZhbHVlIiwic2VsZWN0IiwiZXhlY0NvbW1hbmQiLCJicmVhdGhTZWN0aW9ucyIsIm1heE5QTCIsImxlbmd0aCIsIm5wbCIsImF0dHJpYnV0ZXMiLCJzZXROb3Rlc1BlckxpbmUiLCJ0eXBlIiwidmVyc2UiLCJkb1NldHVwUGFnZXMiLCJvcHRpb25zIiwiaHRtbCIsInJlcGxhY2UiLCJyZWdleCIsIlJlZ0V4cCIsImhpZGVQYXJ0cyIsIm1lbG9keUNvbG9yIiwiYXR0ciIsInRvZ2dsZVBhcnQiLCJyZXNpemVTVkdIZWlnaHQiLCJzZXR1cFBhZ2VzIiwicyIsInVuZGVmaW5lZCIsImVhY2giLCJzZXRBdHRyaWJ1dGUiLCJzcXVpc2hUZXh0IiwibiIsInNldE5vdGVXaWR0aCIsImgiLCJ5IiwicGFyc2VGbG9hdCIsImhlaWdodCIsInciLCJ3aWR0aCIsIngiLCJyZXNpemVTVkdXaWR0aCIsInZlcnNlQXR0ciIsImhpZGVQcmV2aW91cyIsInNlbGVjdG9yIiwiaW5uZXJIVE1MIiwiZWxzIiwiaGFzQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImFkZENsYXNzIiwicGFydENvbG9yIiwidG9nZ2xlIiwibmFtZSIsInN2Z1NlbGVjdG9yIiwib3B0aW9uIiwiYXBwZW5kIiwiZ2V0RGlzcGxheVNldHRlciIsImdldEZvbnRQaXhlbFNpemUiLCJzaXplIiwiaW5kZXhPZiIsImdldE5vdGVIZWlnaHQiLCJkZW5vbWluYXRvciIsIm51bWVyYXRvciIsImdldE5vdGVXaWR0aCIsImdldFNWR05vdGVSYW5nZSIsInN2ZyIsInBhcnRzIiwiZmluZCIsIm1heCIsImNzcyIsInRlc3QiLCJnZXRTVkdTb25nTGVuZ3RoIiwic2VjdGlvbiIsImNob2ljZXMiLCJidXR0b24iLCJtZXRob2QiLCJyZXNldFJldmVhbCIsImluZGljZXMiLCJnZXRJbmRpY2VzIiwic2xpZGUiLCJ2IiwibmgiLCJmcyIsIm5vdGVSYW5nZSIsInNldFZpZXdCb3hlcyIsIm53Iiwic29uZ0xlbmd0aCIsInVub3JpZ2luYWwiLCJpdGVtIiwicGFyZW50RWxlbWVudCIsImNoaWxkcmVuIiwicmVtb3ZlIiwiY2xvc2VzdCIsIm51bVBhZ2VzIiwiTWF0aCIsImNlaWwiLCJzZXR1cFBhZ2VTbGlkZUlzRnVsbCIsInNldHVwUGFnZU5ld1NsaWRlIiwiY2hpbGQiLCJvdXRlckhUTUwiLCJjdXJyZW50U2xpZGUiLCJzbGlkZUdyb3VwIiwic3ZnSGVpZ2h0IiwiY2FuSG9sZCIsImZsb29yIiwibnVtYmVyT2ZDaGlsZHJlbiIsInNlY3Rpb25zIiwicGFnZU51bSIsImVsIiwiY2hpbGROb2RlcyIsIm5vZGVWYWx1ZSIsIndpZHRoUGVyTGV0dGVyIiwiYm94V2lkdGgiLCJtYXRjaCIsInJlc3VsdHMiLCJleGVjIiwibG9jYXRpb24iLCJzZWFyY2giXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLElBQUlDLE9BQU9DLE1BQWY7O0FBRUE7QUFDQSxJQUFJQyxlQUFlLEdBQW5CO0FBQ0EsSUFBSUMsY0FBYyxHQUFsQjs7QUFFQSxJQUFJQyxhQUFKOztBQUVBTCxFQUFFTSxRQUFGLEVBQVlDLEtBQVosQ0FBa0IsWUFBWTtBQUM1QlAsSUFBRSxxQkFBRixFQUF5QlEsS0FBekIsQ0FBK0JQLE9BQU9RLG9CQUF0Qzs7QUFFQUM7QUFDQSxNQUFJQyxDQUFKOztBQUVBLE1BQUksQ0FBQ0EsSUFBSUMsU0FBUyxTQUFULENBQUwsTUFBOEIsS0FBbEMsRUFBeUM7QUFDdkNDLGVBQVdGLENBQVgsRUFBYyxLQUFkLEVBQXFCLEtBQXJCO0FBQ0Q7QUFDRCxPQUFLLElBQUlHLElBQUksQ0FBYixFQUFnQkEsS0FBS0MsYUFBckIsRUFBb0NELEdBQXBDLEVBQXlDO0FBQ3ZDRSxnQkFBWUYsQ0FBWixFQUFlLFdBQVdBLENBQTFCO0FBQ0EsUUFBSUYsU0FBUyxTQUFTRSxDQUFsQixNQUF5QixLQUE3QixFQUFvQztBQUNsQ0QsaUJBQVdELFNBQVMsU0FBU0UsQ0FBbEIsQ0FBWCxFQUFpQ0EsQ0FBakMsRUFBb0MsS0FBcEM7QUFDRDtBQUNGO0FBQ0RHLGFBQVcsZUFBWDs7QUFFQSxNQUFJLENBQUNOLElBQUlDLFNBQVMsZUFBVCxDQUFMLE1BQW9DLEtBQXhDLEVBQStDO0FBQzdDTSxrQkFBY0MsU0FBU1IsQ0FBVCxDQUFkO0FBQ0Q7QUFDRCxNQUFJLENBQUNBLElBQUlDLFNBQVMsYUFBVCxDQUFMLE1BQWtDLEtBQXRDLEVBQTZDO0FBQzNDUSxnQkFBWUQsU0FBU1IsQ0FBVCxDQUFaO0FBQ0Q7O0FBRURVOztBQUVBLE1BQUlDLFFBQVFoQixTQUFTaUIsY0FBVCxDQUF3QixPQUF4QixDQUFaO0FBQ0FELFFBQU1FLE9BQU4sR0FBZ0IsWUFBWTtBQUMxQixRQUFJdkIsT0FBT3dCLE1BQVAsQ0FBY0MsZUFBZCxHQUFnQyxPQUFoQyxDQUFKLEVBQThDO0FBQzVDekIsYUFBT3dCLE1BQVAsQ0FBY0UsS0FBZDtBQUNBLFdBQUtDLElBQUw7QUFDRDtBQUNGLEdBTEQ7O0FBT0E1QixJQUFFLDBCQUFGLEVBQThCUSxLQUE5QixDQUFvQyxZQUFZO0FBQzlDLFFBQUlxQixPQUFPN0IsRUFBRSwwQkFBRixFQUE4QjZCLElBQTlCLEVBQVg7QUFDQSxRQUFJQyxRQUFROUIsRUFBRSwyQkFBRixFQUErQixDQUEvQixDQUFaO0FBQ0E4QixVQUFNQyxLQUFOLEdBQWNGLElBQWQ7QUFDQUMsVUFBTUUsTUFBTjtBQUNBMUIsYUFBUzJCLFdBQVQsQ0FBcUIsTUFBckI7QUFDRCxHQU5EO0FBT0QsQ0F6Q0Q7O0FBMkNBOzs7QUFHQSxTQUFTWixtQkFBVCxHQUFnQztBQUM5QixNQUFJYSxpQkFBaUJsQyxFQUFFLGtEQUFGLENBQXJCO0FBQ0EsTUFBSW1DLFNBQVMsQ0FBYjtBQUNBLE1BQUlELGVBQWVFLE1BQW5CLEVBQTJCO0FBQ3pCLFNBQUssSUFBSXRCLElBQUksQ0FBYixFQUFnQkEsSUFBSW9CLGVBQWVFLE1BQW5DLEVBQTJDdEIsR0FBM0MsRUFBZ0Q7QUFDOUMsVUFBSXVCLE1BQU1sQixTQUFTZSxlQUFlcEIsQ0FBZixFQUFrQndCLFVBQWxCLENBQTZCLFlBQTdCLEVBQTJDUCxLQUFwRCxDQUFWO0FBQ0EsVUFBSU0sTUFBTUYsTUFBVixFQUFrQjtBQUNoQkEsaUJBQVNFLEdBQVQ7QUFDRDtBQUNGO0FBQ0QsUUFBSUYsVUFBVSxDQUFkLEVBQWlCO0FBQ2YsYUFBT0ksZ0JBQWdCSixNQUFoQixDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU9JLGdCQUFnQixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzFCLFVBQVQsQ0FBcUIyQixJQUFyQixFQUErRDtBQUFBLE1BQXBDQyxLQUFvQyx1RUFBNUIsS0FBNEI7QUFBQSxNQUFyQkMsWUFBcUIsdUVBQU4sSUFBTTs7QUFDN0QsTUFBSUMsVUFBVTNDLEVBQUUsY0FBRixFQUNYNEMsSUFEVyxHQUVYQyxPQUZXLENBRUgsUUFGRyxFQUVPLEdBRlAsQ0FBZDtBQUdBLE1BQUlKLFVBQVUsS0FBZCxFQUFxQjtBQUNuQkUsY0FBVSxFQUFWO0FBQ0Q7QUFDRCxNQUFJRyxRQUFRLElBQUlDLE1BQUosQ0FBVyxVQUFVTixLQUFWLEdBQWtCLFFBQTdCLEVBQXVDLEdBQXZDLENBQVo7QUFDQUUsWUFBVUEsUUFBUUUsT0FBUixDQUFnQkMsS0FBaEIsRUFBdUIsRUFBdkIsQ0FBVjtBQUNBSCxhQUFXLFVBQVVGLEtBQVYsR0FBa0IsR0FBbEIsR0FBd0JELElBQW5DO0FBQ0F4QyxJQUFFLGNBQUYsRUFBa0I0QyxJQUFsQixDQUF1QkQsT0FBdkI7O0FBRUEsTUFBSUgsU0FBUyxRQUFiLEVBQXVCO0FBQ3JCUSxjQUFVUCxLQUFWO0FBQ0QsR0FGRCxNQUVPLElBQUlELFNBQVMsUUFBYixFQUF1QjtBQUM1QlEsY0FBVVAsS0FBVjtBQUNBLFFBQUlRLGNBQWNqRCxFQUFFLGlDQUFGLEVBQXFDa0QsSUFBckMsQ0FBMEMsTUFBMUMsQ0FBbEI7QUFDQUMsZUFBV1YsS0FBWCxFQUFrQlEsV0FBbEI7QUFDRCxHQUpNLE1BSUEsSUFBSVQsU0FBUyxTQUFiLEVBQXdCO0FBQzdCUSxjQUFVUCxLQUFWLEVBQWlCLE1BQWpCO0FBQ0Q7QUFDRFc7QUFDQSxNQUFJVixZQUFKLEVBQWtCO0FBQ2hCVztBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFNBQVNqQyxXQUFULENBQXNCa0MsQ0FBdEIsRUFBeUI7QUFDdkJ0RCxJQUFFLFdBQUYsRUFBZTRDLElBQWYsQ0FBb0JVLENBQXBCO0FBQ0FqRCxrQkFBZ0JrRCxTQUFoQjtBQUNBdkQsSUFBRSxxQkFBRixFQUF5QndELElBQXpCLENBQThCLFlBQVk7QUFDeEMsU0FBS0MsWUFBTCxDQUFrQixXQUFsQixFQUErQkgsSUFBSSxJQUFuQztBQUNBLFNBQUtHLFlBQUwsQ0FBa0IsSUFBbEIsRUFBeUIsQ0FBQyxDQUFELEdBQUssQ0FBTixHQUFXSCxDQUFuQztBQUNBSSxlQUFXLElBQVg7QUFDRCxHQUpEO0FBS0FOO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNiLGVBQVQsQ0FBMEJvQixDQUExQixFQUE2QjtBQUMzQixNQUFJQSxLQUFLLENBQVQsRUFBWTtBQUNWQyxpQkFBYXhELGNBQWN1RCxDQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFNBQVN6QyxhQUFULENBQXdCMkMsQ0FBeEIsRUFBMkI7QUFDekI3RCxJQUFFLGFBQUYsRUFBaUI0QyxJQUFqQixDQUFzQmlCLENBQXRCO0FBQ0E3RCxJQUFFLDJCQUFGLEVBQStCd0QsSUFBL0IsQ0FBb0MsWUFBWTtBQUM5QyxRQUFJTSxJQUFJQyxXQUFXLEtBQUt6QixVQUFMLENBQWdCLFFBQWhCLEVBQTBCLE9BQTFCLENBQVgsSUFBaUR1QixDQUF6RDtBQUNBLFNBQUtKLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUJLLENBQXZCO0FBQ0EsUUFBSUUsU0FBU0QsV0FBVyxLQUFLekIsVUFBTCxDQUFnQixhQUFoQixFQUErQixPQUEvQixDQUFYLElBQXNEdUIsQ0FBbkU7QUFDQSxTQUFLSixZQUFMLENBQWtCLFFBQWxCLEVBQTRCTyxNQUE1QjtBQUNELEdBTEQ7QUFNQVo7QUFDRDs7QUFFRCxTQUFTUSxZQUFULENBQXVCSyxDQUF2QixFQUEwQjtBQUN4QixNQUFJQyxLQUFKO0FBQ0FsRSxJQUFFLHVCQUFGLEVBQTJCd0QsSUFBM0IsQ0FBZ0MsWUFBWTtBQUMxQyxRQUFJVyxJQUFJSixXQUFXLEtBQUt6QixVQUFMLENBQWdCLFFBQWhCLEVBQTBCLE9BQTFCLENBQVgsSUFBaUQyQixDQUF6RDtBQUNBLFNBQUtSLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUJVLENBQXZCO0FBQ0EsUUFBSSxPQUFPLEtBQUs3QixVQUFMLENBQWdCLFlBQWhCLENBQVAsS0FBeUMsV0FBN0MsRUFBMEQ7QUFDeEQ0QixjQUFRSCxXQUFXLEtBQUt6QixVQUFMLENBQWdCLFlBQWhCLEVBQThCLE9BQTlCLENBQVgsSUFBcUQyQixDQUE3RDtBQUNBLFdBQUtSLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkJTLEtBQTNCO0FBQ0QsS0FIRCxNQUdPLElBQUksT0FBTyxLQUFLNUIsVUFBTCxDQUFnQixTQUFoQixDQUFQLEtBQXNDLFdBQTFDLEVBQXVEO0FBQzVENEIsY0FBUUgsV0FBVyxLQUFLekIsVUFBTCxDQUFnQixTQUFoQixFQUEyQixPQUEzQixDQUFYLElBQWtEMkIsQ0FBMUQ7QUFDQSxXQUFLUixZQUFMLENBQWtCLGlCQUFsQixFQUFxQ1MsS0FBckM7QUFDQVIsaUJBQVcsSUFBWDtBQUNEO0FBQ0YsR0FYRDtBQVlBVTtBQUNEOztBQUVEOzs7QUFHQSxTQUFTcEQsV0FBVCxDQUFzQnlCLEtBQXRCLEVBQTZCNEIsU0FBN0IsRUFBNkQ7QUFBQSxNQUFyQkMsWUFBcUIsdUVBQU4sSUFBTTs7QUFDM0QsTUFBSUMsV0FBVyxxQkFBZjtBQUNBLE1BQUk5QixVQUFVLEtBQWQsRUFBcUI7QUFDbkI4QixlQUFXLE9BQU85QixLQUFQLEdBQWUsR0FBZixHQUFxQjhCLFFBQWhDO0FBQ0Q7O0FBRUQsTUFBSUQsWUFBSixFQUFrQjtBQUNoQnRFLE1BQUV1RSxRQUFGLEVBQVlmLElBQVosQ0FBaUIsWUFBWTtBQUMzQixXQUFLZ0IsU0FBTCxHQUFpQixFQUFqQjtBQUNELEtBRkQ7QUFHRDs7QUFFRCxNQUFJQyxNQUFNekUsRUFBRXVFLFdBQVcsR0FBWCxHQUFpQkYsU0FBakIsR0FBNkIsR0FBL0IsQ0FBVjtBQUNBLE9BQUssSUFBSXZELElBQUksQ0FBYixFQUFnQkEsSUFBSTJELElBQUlyQyxNQUF4QixFQUFnQ3RCLEdBQWhDLEVBQXFDO0FBQ25DO0FBQ0EsUUFBSWUsT0FBTzdCLEVBQUV5RSxJQUFJM0QsQ0FBSixDQUFGLEVBQ1JvQyxJQURRLENBQ0htQixTQURHLEVBRVJ4QixPQUZRLENBRUEsUUFGQSxFQUVVLEVBRlYsQ0FBWDtBQUdBO0FBQ0FoQixXQUFPQSxLQUFLZ0IsT0FBTCxDQUFhLFNBQWIsRUFBd0IsVUFBeEIsQ0FBUDtBQUNBNEIsUUFBSTNELENBQUosRUFBTzBELFNBQVAsR0FBbUIzQyxJQUFuQjtBQUNBNkIsZUFBV2UsSUFBSTNELENBQUosQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFNBQVNMLG9CQUFULEdBQWlDO0FBQy9CLE1BQUlULEVBQUUsaUJBQUYsRUFBcUIwRSxRQUFyQixDQUE4QixTQUE5QixDQUFKLEVBQThDO0FBQzVDMUUsTUFBRSxpQkFBRixFQUFxQjJFLFdBQXJCLENBQWlDLFNBQWpDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wzRSxNQUFFLGlCQUFGLEVBQXFCNEUsUUFBckIsQ0FBOEIsU0FBOUI7QUFDRDtBQUNGOztBQUVEOzs7QUFHQSxTQUFTekIsVUFBVCxDQUFxQlYsS0FBckIsRUFBNEJvQyxTQUE1QixFQUF1QztBQUNyQyxNQUFJTixXQUFXLDZCQUE2Qk0sU0FBN0IsR0FBeUMsSUFBeEQ7QUFDQSxNQUFJcEMsVUFBVSxLQUFkLEVBQXFCO0FBQ25COEIsZUFBVyxPQUFPOUIsS0FBUCxHQUFlLEdBQWYsR0FBcUI4QixRQUFoQztBQUNEO0FBQ0R2RSxJQUFFdUUsUUFBRixFQUFZZixJQUFaLENBQWlCLFlBQVk7QUFDM0I7QUFDQXhELE1BQUUsSUFBRixFQUFROEUsTUFBUjtBQUNELEdBSEQ7QUFJRDs7QUFFRDdFLE9BQU9vQixtQkFBUCxHQUE2QkEsbUJBQTdCO0FBQ0FwQixPQUFPWSxVQUFQLEdBQW9CQSxVQUFwQjtBQUNBWixPQUFPbUIsV0FBUCxHQUFxQkEsV0FBckI7QUFDQW5CLE9BQU9zQyxlQUFQLEdBQXlCQSxlQUF6QjtBQUNBdEMsT0FBT2lCLGFBQVAsR0FBdUJBLGFBQXZCO0FBQ0FqQixPQUFPMkQsWUFBUCxHQUFzQkEsWUFBdEI7QUFDQTNELE9BQU9lLFdBQVAsR0FBcUJBLFdBQXJCO0FBQ0FmLE9BQU9RLG9CQUFQLEdBQThCQSxvQkFBOUI7QUFDQVIsT0FBT2tELFVBQVAsR0FBb0JBLFVBQXBCOztBQUVBLFNBQVNsQyxVQUFULENBQXFCOEQsSUFBckIsRUFBMkI7QUFDekIvRCxjQUFZLEtBQVosRUFBbUIrRCxJQUFuQixFQUF5QixLQUF6QjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTaEUsV0FBVCxHQUF3QjtBQUN0QjtBQUNBLE1BQUlpRSxjQUNGLHNFQURGO0FBRUEsTUFBSWxFLENBQUo7QUFDQSxPQUFLQSxJQUFJLENBQVQsRUFBWUEsSUFBSSxFQUFoQixFQUFvQkEsR0FBcEIsRUFBeUI7QUFDdkIsUUFBSXlELFdBQVdTLGNBQWMsVUFBZCxHQUEyQmxFLENBQTNCLEdBQStCLEdBQTlDO0FBQ0EsUUFBSWQsRUFBRXVFLFFBQUYsRUFBWW5DLE1BQVosS0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUIsYUFBT3RCLElBQUksQ0FBWDtBQUNEO0FBQ0Y7QUFDRCxTQUFPQSxDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNKLGtCQUFULEdBQStCO0FBQzdCLE1BQUl1RSxTQUFTakYsRUFBRSxPQUFGLENBQWI7QUFDQWlGLFNBQU9yQyxJQUFQLENBQVksWUFBWjtBQUNBNUMsSUFBRSxpQ0FBRixFQUFxQ2tGLE1BQXJDLENBQTRDRCxNQUE1QztBQUNBRSxtQkFBaUIsS0FBakIsRUFBd0JGLE1BQXhCO0FBQ0EsT0FBSyxJQUFJbkUsSUFBSSxDQUFiLEVBQWdCQSxLQUFLQyxhQUFyQixFQUFvQ0QsR0FBcEMsRUFBeUM7QUFDdkNtRSxhQUFTakYsRUFBRSxPQUFGLENBQVQ7QUFDQUEsTUFBRWlGLE1BQUYsRUFBVUwsUUFBVixDQUFtQixNQUFNOUQsQ0FBekI7QUFDQW1FLFdBQU9yQyxJQUFQLENBQVksV0FBVzlCLENBQXZCO0FBQ0FkLE1BQUUsaUNBQUYsRUFBcUNrRixNQUFyQyxDQUE0Q0QsTUFBNUM7QUFDQUUscUJBQWlCckUsQ0FBakIsRUFBb0JtRSxNQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFNBQVNHLGdCQUFULEdBQTZCO0FBQzNCO0FBQ0EsTUFBSSxPQUFPL0UsYUFBUCxLQUF5QixXQUE3QixFQUEwQztBQUN4QyxRQUFJZ0YsT0FBT3JGLEVBQUUsNEJBQUYsRUFBZ0NrRCxJQUFoQyxDQUFxQyxXQUFyQyxDQUFYO0FBQ0EsUUFBSW1DLFNBQVM5QixTQUFiLEVBQXdCO0FBQ3RCbEQsc0JBQWdCLENBQWhCO0FBQ0QsS0FGRCxNQUVPLElBQUlnRixLQUFLQyxPQUFMLENBQWEsSUFBYixNQUF1QixDQUFDLENBQTVCLEVBQStCO0FBQ3BDakYsc0JBQWdCMEQsV0FBV3NCLEtBQUt4QyxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixDQUFYLEtBQXNDLElBQUksQ0FBMUMsQ0FBaEI7QUFDRCxLQUZNLE1BRUEsSUFBSXdDLEtBQUtDLE9BQUwsQ0FBYSxJQUFiLE1BQXVCLENBQUMsQ0FBNUIsRUFBK0I7QUFDcENqRixzQkFBZ0IwRCxXQUFXc0IsS0FBS3hDLE9BQUwsQ0FBYSxJQUFiLEVBQW1CLEVBQW5CLENBQVgsQ0FBaEI7QUFDRDtBQUNGO0FBQ0QsU0FBT3hDLGFBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU2tGLGFBQVQsR0FBMEI7QUFDeEIsTUFBSUMsY0FBY3pCLFdBQ2hCL0QsRUFBRSxnQ0FBRixFQUFvQ2tELElBQXBDLENBQXlDLGFBQXpDLENBRGdCLENBQWxCO0FBR0EsTUFBSXVDLFlBQVl0RSxTQUFTbkIsRUFBRSxnQ0FBRixFQUFvQ2tELElBQXBDLENBQXlDLFFBQXpDLENBQVQsQ0FBaEI7QUFDQSxTQUFPdUMsWUFBWUQsV0FBbkI7QUFDRDtBQUNELFNBQVNFLFlBQVQsR0FBeUI7QUFDdkIsTUFBSUYsY0FBY3pCLFdBQ2hCL0QsRUFBRSwrQkFBRixFQUFtQ2tELElBQW5DLENBQXdDLFlBQXhDLENBRGdCLENBQWxCO0FBR0EsTUFBSXVDLFlBQVl0RSxTQUFTbkIsRUFBRSwrQkFBRixFQUFtQ2tELElBQW5DLENBQXdDLE9BQXhDLENBQVQsQ0FBaEI7QUFDQSxTQUFPdUMsWUFBWUQsV0FBbkI7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU0csZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsTUFBSUMsUUFBUTdGLEVBQUU0RixHQUFGLEVBQU9FLElBQVAsQ0FBWSxhQUFaLENBQVo7QUFDQSxNQUFJQyxNQUFNLENBQVY7QUFDQSxPQUFLLElBQUlqRixJQUFJLENBQWIsRUFBZ0JBLElBQUkrRSxNQUFNekQsTUFBMUIsRUFBa0N0QixHQUFsQyxFQUF1QztBQUNyQztBQUNBLFFBQUlkLEVBQUU2RixNQUFNL0UsQ0FBTixDQUFGLEVBQVlrRixHQUFaLENBQWdCLFNBQWhCLE1BQStCLE1BQW5DLEVBQTJDO0FBQ3pDLFVBQUlDLE9BQ0ZsQyxXQUFXL0QsRUFBRTZGLE1BQU0vRSxDQUFOLENBQUYsRUFBWW9DLElBQVosQ0FBaUIsUUFBakIsQ0FBWCxJQUNBYSxXQUFXL0QsRUFBRTZGLE1BQU0vRSxDQUFOLENBQUYsRUFBWW9DLElBQVosQ0FBaUIsYUFBakIsQ0FBWCxDQUZGO0FBR0EsVUFBSStDLE9BQU9GLEdBQVgsRUFBZ0I7QUFDZEEsY0FBTUUsSUFBTjtBQUNEO0FBQ0Y7QUFDRjtBQUNELFNBQU9GLEdBQVA7QUFDRDtBQUNELFNBQVNHLGdCQUFULENBQTJCTixHQUEzQixFQUFnQztBQUM5QixTQUFPNUYsRUFBRTRGLEdBQUYsRUFBTzFDLElBQVAsQ0FBWSxpQkFBWixDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNpQyxnQkFBVCxDQUEyQjFDLEtBQTNCLEVBQWtDMEQsT0FBbEMsRUFBMkM7QUFDekMsTUFBSUMsVUFBVSxDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLFNBQXJCLENBQWQ7QUFDQSxPQUFLLElBQUl0RixJQUFJLENBQWIsRUFBZ0JBLElBQUlzRixRQUFRaEUsTUFBNUIsRUFBb0N0QixHQUFwQyxFQUF5QztBQUN2QyxRQUFJdUYsU0FBU3JHLEVBQUUsVUFBRixDQUFiO0FBQ0FBLE1BQUVxRyxNQUFGLEVBQVVuRCxJQUFWLENBQWUsT0FBZixFQUF3QmtELFFBQVF0RixDQUFSLENBQXhCO0FBQ0FkLE1BQUVxRyxNQUFGLEVBQVVuRCxJQUFWLENBQ0UsU0FERixFQUVFLG9DQUFvQ1QsS0FBcEMsR0FBNEMsS0FGOUM7QUFJQXpDLE1BQUVxRyxNQUFGLEVBQVV6RCxJQUFWLENBQWV3RCxRQUFRdEYsQ0FBUixDQUFmO0FBQ0FkLE1BQUVtRyxPQUFGLEVBQVdqQixNQUFYLENBQWtCbUIsTUFBbEI7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVNyRCxTQUFULENBQW9CUCxLQUFwQixFQUE0QztBQUFBLE1BQWpCNkQsTUFBaUIsdUVBQVIsTUFBUTs7QUFDMUMsTUFBSS9CLFdBQVcseUJBQWY7QUFDQSxNQUFJOUIsVUFBVSxLQUFkLEVBQXFCO0FBQ25COEIsZUFBVyxPQUFPOUIsS0FBUCxHQUFlLEdBQWYsR0FBcUI4QixRQUFoQztBQUNEO0FBQ0R2RSxJQUFFdUUsUUFBRixFQUFZZixJQUFaLENBQWlCLFlBQVk7QUFDM0I7QUFDQXhELE1BQUUsSUFBRixFQUFRc0csTUFBUjtBQUNELEdBSEQ7QUFJRDs7QUFFRDs7O0FBR0EsU0FBU0MsV0FBVCxHQUF3QjtBQUN0QixNQUFJQyxVQUFVdkcsT0FBT3dCLE1BQVAsQ0FBY2dGLFVBQWQsRUFBZDtBQUNBeEcsU0FBT3dCLE1BQVAsQ0FBY2lGLEtBQWQsQ0FBb0JGLFFBQVEzQyxDQUE1QixFQUErQjJDLFFBQVFHLENBQXZDO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVN2RCxlQUFULEdBQTRCO0FBQzFCLE1BQUl3RCxLQUFLckIsZUFBVDtBQUNBLE1BQUlzQixLQUFLekIsa0JBQVQ7QUFDQXBGLElBQUUsS0FBRixFQUFTd0QsSUFBVCxDQUFjLFlBQVk7QUFDeEIsUUFBSXNELFlBQVluQixnQkFBZ0IsSUFBaEIsQ0FBaEI7QUFDQSxRQUFJOUIsSUFBSWlELFlBQVlGLEVBQVosR0FBaUJDLE1BQU0sSUFBSSxDQUFWLENBQXpCO0FBQ0EsU0FBS3BELFlBQUwsQ0FBa0IsUUFBbEIsRUFBNEJJLENBQTVCO0FBQ0QsR0FKRDtBQUtBa0Q7QUFDQVI7QUFDRDtBQUNEOzs7QUFHQSxTQUFTbkMsY0FBVCxHQUEyQjtBQUN6QixNQUFJNEMsS0FBS3RCLGNBQVQ7QUFDQTFGLElBQUUsS0FBRixFQUFTd0QsSUFBVCxDQUFjLFlBQVk7QUFDeEIsUUFBSXlELGFBQWFmLGlCQUFpQixJQUFqQixDQUFqQjtBQUNBLFNBQUt6QyxZQUFMLENBQWtCLE9BQWxCLEVBQTJCd0QsYUFBYUQsRUFBeEM7QUFDRCxHQUhEO0FBSUEzRDtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU0EsVUFBVCxHQUF1QjtBQUNyQixNQUFJNkQsYUFBYWxILEVBQUUseUJBQUYsQ0FBakI7QUFDQTtBQUNBLE9BQUssSUFBSWMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJb0csV0FBVzlFLE1BQS9CLEVBQXVDdEIsR0FBdkMsRUFBNEM7QUFDMUMsUUFBSXFHLE9BQU9ELFdBQVdwRyxDQUFYLENBQVg7QUFDQSxRQUFJcUcsS0FBS0MsYUFBTCxDQUFtQkMsUUFBbkIsQ0FBNEJqRixNQUE1QixLQUF1QyxDQUEzQyxFQUE4QztBQUM1QytFLFdBQUtDLGFBQUwsQ0FBbUJFLE1BQW5CO0FBQ0QsS0FGRCxNQUVPO0FBQ0xILFdBQUtHLE1BQUw7QUFDRDtBQUNGO0FBQ0R0SCxJQUFFLHVCQUFGLEVBQTJCd0QsSUFBM0IsQ0FBZ0MsWUFBWTtBQUMxQyxRQUFJa0QsUUFBUTFHLEVBQUUsSUFBRixFQUFRdUgsT0FBUixDQUFnQixTQUFoQixDQUFaOztBQUVBLFFBQUlDLFdBQVcsQ0FBZjtBQUNBLFFBQUl4SCxFQUFFLElBQUYsRUFBUThGLElBQVIsQ0FBYSxzQkFBYixFQUFxQzFELE1BQXJDLEdBQThDLENBQWxELEVBQXFEO0FBQ25Eb0YsaUJBQVd4SCxFQUFFLElBQUYsRUFBUThGLElBQVIsQ0FBYSxzQkFBYixFQUFxQzFELE1BQWhEO0FBQ0QsS0FGRCxNQUVPO0FBQ0xvRixpQkFBV0MsS0FBS0MsSUFBTCxDQUFVMUgsRUFBRSxJQUFGLEVBQVFrRCxJQUFSLENBQWEsT0FBYixJQUF3QjlDLFdBQWxDLENBQVg7QUFDRDtBQUNEO0FBQ0EsU0FBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUkwRyxRQUFwQixFQUE4QjFHLEdBQTlCLEVBQW1DO0FBQ2pDLFVBQUk2RyxxQkFBcUJqQixLQUFyQixDQUFKLEVBQWlDO0FBQy9CQSxnQkFBUWtCLGtCQUFrQmxCLEtBQWxCLENBQVI7QUFDRDtBQUNELFVBQUltQixRQUFRN0gsRUFBRSxPQUFGLENBQVo7QUFDQUEsUUFBRTZILEtBQUYsRUFBU2pELFFBQVQsQ0FBa0IsU0FBbEI7QUFDQTVFLFFBQUU2SCxLQUFGLEVBQVM3QixHQUFULENBQWEsU0FBYixFQUF3QixDQUF4QjtBQUNBaEcsUUFBRTZILEtBQUYsRUFBUzNFLElBQVQsQ0FBYyxXQUFkLEVBQTJCcEMsQ0FBM0I7QUFDQSxVQUFJQSxJQUFJLENBQUosS0FBVSxDQUFkLEVBQWlCO0FBQ2ZkLFVBQUU2SCxLQUFGLEVBQVNqRCxRQUFULENBQWtCLEtBQWxCO0FBQ0Q7QUFDRDhCLFlBQU14QixNQUFOLENBQWEyQyxLQUFiO0FBQ0E3SCxRQUFFMEcsS0FBRixFQUFTWixJQUFULENBQWMsaUJBQWlCaEYsQ0FBakIsR0FBcUIsSUFBbkMsRUFBeUMsQ0FBekMsRUFBNEMwRCxTQUE1QyxHQUF3RCxLQUFLc0QsU0FBN0Q7QUFDRDtBQUNGLEdBeEJEO0FBeUJBZjtBQUNBUjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTcUIsaUJBQVQsQ0FBNEJHLFlBQTVCLEVBQTBDO0FBQ3hDLE1BQUlDLGFBQWFoSSxFQUFFK0gsWUFBRixFQUFnQlIsT0FBaEIsQ0FBd0IsZUFBeEIsQ0FBakI7QUFDQVMsYUFBVzlDLE1BQVgsQ0FBa0JsRixFQUFFLFdBQUYsQ0FBbEI7QUFDQSxTQUFPZ0ksV0FBV2xDLElBQVgsQ0FBZ0Isc0JBQWhCLENBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBUzZCLG9CQUFULENBQStCakIsS0FBL0IsRUFBc0M7QUFDcEMsTUFBSXVCLFlBQVk5RyxTQUNkbkIsRUFBRTBHLEtBQUYsRUFDR1osSUFESCxDQUNRLGNBRFIsRUFFRzVDLElBRkgsQ0FFUSxRQUZSLENBRGMsQ0FBaEI7QUFLQTtBQUNBO0FBQ0EsTUFBSWdGLFVBQVVULEtBQUtVLEtBQUwsQ0FBVyxDQUFDaEksZUFBZSxFQUFoQixJQUFzQjhILFNBQWpDLENBQWQ7QUFDQSxNQUFJRyxtQkFBbUJwSSxFQUFFMEcsS0FBRixFQUFTWixJQUFULENBQWMsY0FBZCxFQUE4QjFELE1BQXJEO0FBQ0EsU0FBT2dHLG9CQUFvQkYsT0FBM0I7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU25CLFlBQVQsR0FBeUI7QUFDdkIsTUFBSXNCLFdBQVdySSxFQUFFLGtEQUFGLENBQWY7O0FBRUFBLElBQUUsY0FBRixFQUFrQndELElBQWxCLENBQXVCLFlBQVk7QUFDakMsUUFBSVcsSUFBSSxDQUFSO0FBQ0EsUUFBSW1FLFVBQVV0SSxFQUFFLElBQUYsRUFDWHVILE9BRFcsQ0FDSCxhQURHLEVBRVhyRSxJQUZXLENBRU4sV0FGTSxDQUFkO0FBR0EsUUFBSW1GLFNBQVNqRyxNQUFULEdBQWtCa0csT0FBbEIsSUFBNkJ0SSxFQUFFcUksU0FBU0MsT0FBVCxDQUFGLEVBQXFCcEYsSUFBckIsQ0FBMEIsT0FBMUIsSUFBcUMsQ0FBdEUsRUFBeUU7QUFDdkVpQixVQUFJa0UsU0FBU0MsT0FBVCxFQUFrQmhHLFVBQWxCLENBQTZCLEdBQTdCLEVBQWtDLE9BQWxDLENBQUo7QUFDQXRDLFFBQUUsSUFBRixFQUFRa0QsSUFBUixDQUFhLE9BQWIsRUFBc0JtRixTQUFTQyxPQUFULEVBQWtCaEcsVUFBbEIsQ0FBNkIsT0FBN0IsRUFBc0MsT0FBdEMsQ0FBdEI7QUFDRCxLQUhELE1BR087QUFDTDZCLFVBQUltRSxVQUFVbEksV0FBZDtBQUNEOztBQUVELFFBQUk0RCxTQUFTaEUsRUFBRSxJQUFGLEVBQVFrRCxJQUFSLENBQWEsUUFBYixDQUFiO0FBQ0EsUUFBSWdCLFFBQVFsRSxFQUFFLElBQUYsRUFBUWtELElBQVIsQ0FBYSxPQUFiLENBQVo7QUFDQSxTQUFLTyxZQUFMLENBQWtCLFNBQWxCLEVBQTZCVSxJQUFJLEtBQUosR0FBWUQsS0FBWixHQUFvQixHQUFwQixHQUEwQkYsTUFBdkQ7QUFDRCxHQWZEO0FBZ0JBaEUsSUFBRSxVQUFGLEVBQWNnRyxHQUFkLENBQWtCLFNBQWxCLEVBQTZCLENBQTdCO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVN0QyxVQUFULENBQXFCNkUsRUFBckIsRUFBeUI7QUFDdkI7QUFDQSxNQUFJLE9BQU9BLEdBQUdDLFVBQUgsQ0FBYyxDQUFkLENBQVAsS0FBNEIsV0FBaEMsRUFBNkM7QUFDN0MsTUFBSTNHLE9BQU8wRyxHQUFHQyxVQUFILENBQWMsQ0FBZCxFQUFpQkMsU0FBNUI7QUFDQTtBQUNBLE1BQUlDLGlCQUFpQnRELHFCQUFxQixHQUExQztBQUNBLE1BQUl1RCxXQUFXM0ksRUFBRXVJLEVBQUYsRUFBTXJGLElBQU4sQ0FBVyxpQkFBWCxDQUFmOztBQUVBO0FBQ0EsTUFBSSxDQUFDckIsS0FBSytHLEtBQUwsQ0FBVyxVQUFYLENBQUwsRUFBNkI7QUFDM0IvRyxZQUFRLEdBQVI7QUFDRDs7QUFFRCxNQUFJQSxLQUFLTyxNQUFMLEdBQWNzRyxjQUFkLElBQWdDQyxRQUFwQyxFQUE4QztBQUM1QztBQUNBM0ksTUFBRXVJLEVBQUYsRUFBTXJGLElBQU4sQ0FBVyxZQUFYLEVBQXlCeUYsUUFBekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDOUcsS0FBS08sTUFBTCxHQUFjLENBQWYsSUFBb0JzRyxjQUFwQixJQUFzQ0MsUUFBMUMsRUFBb0Q7QUFDbEQ5RyxhQUFPQSxLQUFLZ0IsT0FBTCxDQUFhLElBQWIsRUFBbUIsRUFBbkIsQ0FBUDtBQUNEO0FBQ0YsR0FWRCxNQVVPO0FBQ0w3QyxNQUFFdUksRUFBRixFQUFNckYsSUFBTixDQUFXLFlBQVgsRUFBeUIsSUFBekI7QUFDRDtBQUNEcUYsS0FBRy9ELFNBQUgsR0FBZTNDLElBQWY7QUFDRDs7QUFFRCxTQUFTakIsUUFBVCxDQUFtQm1FLElBQW5CLEVBQXlCO0FBQ3ZCLE1BQUk4RCxVQUFVLElBQUk5RixNQUFKLENBQVcsU0FBU2dDLElBQVQsR0FBZ0IsV0FBM0IsRUFBd0MrRCxJQUF4QyxDQUNaN0ksT0FBTzhJLFFBQVAsQ0FBZ0JDLE1BREosQ0FBZDs7QUFJQSxTQUFPSCxZQUFZLElBQVosR0FBbUJBLFFBQVEsQ0FBUixLQUFjLENBQWpDLEdBQXFDLEtBQTVDO0FBQ0QiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJCA9IHdpbmRvdy5qUXVlcnk7XG5cbi8vIFRoZXNlIHNlZW0gdG8gYmUgaGFyZC1jb2RlZCBpbnRvIHJldmVhbC5qcy5cbnZhciByZXZlYWxIZWlnaHQgPSA3MDA7XG52YXIgcmV2ZWFsV2lkdGggPSA5NjA7XG5cbnZhciBmb250UGl4ZWxTaXplO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICQoJyNvcGVuRHluYW1pY09wdGlvbnMnKS5jbGljayh3aW5kb3cudG9nZ2xlRHluYW1pY09wdGlvbnMpO1xuXG4gIGZpbGxEeW5hbWljT3B0aW9ucygpO1xuICB2YXIgcDtcblxuICBpZiAoKHAgPSB1cmxQYXJhbSgnZHAtdmFsbCcpKSAhPT0gZmFsc2UpIHtcbiAgICBzZXREaXNwbGF5KHAsICdhbGwnLCBmYWxzZSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gY291bnRWZXJzZXMoKTsgaSsrKSB7XG4gICAgc3dpdGNoVmVyc2UoaSwgJ2RhdGEtdicgKyBpKTtcbiAgICBpZiAodXJsUGFyYW0oJ2RwLXYnICsgaSkgIT09IGZhbHNlKSB7XG4gICAgICBzZXREaXNwbGF5KHVybFBhcmFtKCdkcC12JyArIGkpLCBpLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGFsd2F5c1Nob3coJ2RhdGEtdnJlZnJhaW4nKTtcblxuICBpZiAoKHAgPSB1cmxQYXJhbSgnZHAtbm90ZUhlaWdodCcpKSAhPT0gZmFsc2UpIHtcbiAgICBzZXROb3RlSGVpZ2h0KHBhcnNlSW50KHApKTtcbiAgfVxuICBpZiAoKHAgPSB1cmxQYXJhbSgnZHAtZm9udFNpemUnKSkgIT09IGZhbHNlKSB7XG4gICAgc2V0Rm9udFNpemUocGFyc2VJbnQocCkpO1xuICB9XG5cbiAgYXV0b3NldE5vdGVzUGVyTGluZSgpO1xuXG4gIHZhciBhdWRpbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdWRpbycpO1xuICBhdWRpby5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3cuUmV2ZWFsLmF2YWlsYWJsZVJvdXRlcygpWydyaWdodCddKSB7XG4gICAgICB3aW5kb3cuUmV2ZWFsLnJpZ2h0KCk7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgJCgnI2R5bmFtaWNPcHRpb25zIC5jb3B5VXJsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0ID0gJCgnI2R5bmFtaWNPcHRpb25zIHNwYW4udXJsJykudGV4dCgpO1xuICAgIHZhciBpbnB1dCA9ICQoJyNkeW5hbWljT3B0aW9ucyBpbnB1dC51cmwnKVswXTtcbiAgICBpbnB1dC52YWx1ZSA9IHRleHQ7XG4gICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBAYnJpZWYgU2V0IHRoZSBub3RlcyBwZXIgbGluZSBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBicmVhdGhTZWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXV0b3NldE5vdGVzUGVyTGluZSAoKSB7XG4gIHZhciBicmVhdGhTZWN0aW9ucyA9ICQoJy5keW5hbWljLm9yaWdpbmFsIHN2ZzpmaXJzdCAjYnJlYXRoU2VjdGlvbnMgcmVjdCcpO1xuICB2YXIgbWF4TlBMID0gMDtcbiAgaWYgKGJyZWF0aFNlY3Rpb25zLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYXRoU2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBucGwgPSBwYXJzZUludChicmVhdGhTZWN0aW9uc1tpXS5hdHRyaWJ1dGVzWydkYXRhLXdpZHRoJ10udmFsdWUpO1xuICAgICAgaWYgKG5wbCA+IG1heE5QTCkge1xuICAgICAgICBtYXhOUEwgPSBucGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXhOUEwgPj0gMSkge1xuICAgICAgcmV0dXJuIHNldE5vdGVzUGVyTGluZShtYXhOUEwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2V0Tm90ZXNQZXJMaW5lKDEyKTtcbn1cblxuZnVuY3Rpb24gc2V0RGlzcGxheSAodHlwZSwgdmVyc2UgPSAnYWxsJywgZG9TZXR1cFBhZ2VzID0gdHJ1ZSkge1xuICB2YXIgb3B0aW9ucyA9ICQoJy5kaXNwbGF5T3B0cycpXG4gICAgLmh0bWwoKVxuICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpO1xuICBpZiAodmVyc2UgPT09ICdhbGwnKSB7XG4gICAgb3B0aW9ucyA9ICcnO1xuICB9XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJyZkcC12JyArIHZlcnNlICsgJz1bXiZdKicsICdnJyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zLnJlcGxhY2UocmVnZXgsICcnKTtcbiAgb3B0aW9ucyArPSAnJmRwLXYnICsgdmVyc2UgKyAnPScgKyB0eXBlO1xuICAkKCcuZGlzcGxheU9wdHMnKS5odG1sKG9wdGlvbnMpO1xuXG4gIGlmICh0eXBlID09PSAnbHlyaWNzJykge1xuICAgIGhpZGVQYXJ0cyh2ZXJzZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21lbG9keScpIHtcbiAgICBoaWRlUGFydHModmVyc2UpO1xuICAgIHZhciBtZWxvZHlDb2xvciA9ICQoJyNwYXJ0cyByZWN0W2ZpbGxdOmZpcnN0LW9mLXR5cGUnKS5hdHRyKCdmaWxsJyk7XG4gICAgdG9nZ2xlUGFydCh2ZXJzZSwgbWVsb2R5Q29sb3IpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoYXJtb255Jykge1xuICAgIGhpZGVQYXJ0cyh2ZXJzZSwgJ3Nob3cnKTtcbiAgfVxuICByZXNpemVTVkdIZWlnaHQoKTtcbiAgaWYgKGRvU2V0dXBQYWdlcykge1xuICAgIHNldHVwUGFnZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBicmllZiBDaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZvbnQgZm9yIHRoZSBseXJpY3MuXG4gKi9cbmZ1bmN0aW9uIHNldEZvbnRTaXplIChzKSB7XG4gICQoJy5mb250U2l6ZScpLmh0bWwocyk7XG4gIGZvbnRQaXhlbFNpemUgPSB1bmRlZmluZWQ7XG4gICQoJy5keW5hbWljIHN2ZyBnIHRleHQnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgcyArICdwdCcpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkeScsICgtMSAvIDIpICogcyk7XG4gICAgc3F1aXNoVGV4dCh0aGlzKTtcbiAgfSk7XG4gIHJlc2l6ZVNWR0hlaWdodCgpO1xufVxuXG4vKipcbiAqIEBicmllZiBTZXQgdGhlIG51bWJlciBvZiBxdWFydGVyIG5vdGVzIHRvIGRpc3BsYXkgcGVyIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIHNldE5vdGVzUGVyTGluZSAobikge1xuICBpZiAobiA+PSAxKSB7XG4gICAgc2V0Tm90ZVdpZHRoKHJldmVhbFdpZHRoIC8gbik7XG4gIH1cbn1cblxuLyoqXG4gKiBAYnJpZWYgQ2hhbmdlIHRoZSBzaXplIG9mIGEgbm90ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldE5vdGVIZWlnaHQgKGgpIHtcbiAgJCgnLm5vdGVIZWlnaHQnKS5odG1sKGgpO1xuICAkKCcuZHluYW1pYyBzdmcgcmVjdFtkYXRhLXldJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cmlidXRlc1snZGF0YS15J11bJ3ZhbHVlJ10pICogaDtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgneScsIHkpO1xuICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cmlidXRlc1snZGF0YS1oZWlnaHQnXVsndmFsdWUnXSkgKiBoO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuICB9KTtcbiAgcmVzaXplU1ZHSGVpZ2h0KCk7XG59XG5cbmZ1bmN0aW9uIHNldE5vdGVXaWR0aCAodykge1xuICB2YXIgd2lkdGg7XG4gICQoJy5keW5hbWljIHN2ZyBbZGF0YS14XScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciB4ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHJpYnV0ZXNbJ2RhdGEteCddWyd2YWx1ZSddKSAqIHc7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3gnLCB4KTtcbiAgICBpZiAodHlwZW9mIHRoaXMuYXR0cmlidXRlc1snZGF0YS13aWR0aCddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cmlidXRlc1snZGF0YS13aWR0aCddWyd2YWx1ZSddKSAqIHc7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdHRyaWJ1dGVzWydkYXRhLXRsJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyaWJ1dGVzWydkYXRhLXRsJ11bJ3ZhbHVlJ10pICogdztcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkYXRhLXRleHRsZW5ndGgnLCB3aWR0aCk7XG4gICAgICBzcXVpc2hUZXh0KHRoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHJlc2l6ZVNWR1dpZHRoKCk7XG59XG5cbi8qKlxuICogQGJyaWVmIENoYW5nZSB0aGUgbHlyaWNzIGluIGEgZHluYW1pYy5zdmcgdG8gYSBkaWZmZXJlbnQgdmVyc2UuXG4gKi9cbmZ1bmN0aW9uIHN3aXRjaFZlcnNlICh2ZXJzZSwgdmVyc2VBdHRyLCBoaWRlUHJldmlvdXMgPSB0cnVlKSB7XG4gIHZhciBzZWxlY3RvciA9ICcuZHluYW1pYyBzdmcgZyB0ZXh0JztcbiAgaWYgKHZlcnNlICE9PSAnYWxsJykge1xuICAgIHNlbGVjdG9yID0gJyN2JyArIHZlcnNlICsgJyAnICsgc2VsZWN0b3I7XG4gIH1cblxuICBpZiAoaGlkZVByZXZpb3VzKSB7XG4gICAgJChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGVscyA9ICQoc2VsZWN0b3IgKyAnWycgKyB2ZXJzZUF0dHIgKyAnXScpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSB0aGUgaHlwZW5zIHRoYXQgc3RhcnQgYSBzeWxsYWJsZS4gV2UgZG9uJ3QgbmVlZCB0d28gaHlwZW5zIHBlciB3b3JkLlxuICAgIHZhciB0ZXh0ID0gJChlbHNbaV0pXG4gICAgICAuYXR0cih2ZXJzZUF0dHIpXG4gICAgICAucmVwbGFjZSgvXlsgLV0qLywgJycpO1xuICAgIC8vIEFkZCBhIG5vbi1icmVha2luZyBzcGFjZSBpZiBpdCBpcyB0aGUgZW5kIG9mIGEgd29yZC5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oW14tXSkkLywgJyQxJm5ic3A7Jyk7XG4gICAgZWxzW2ldLmlubmVySFRNTCA9IHRleHQ7XG4gICAgc3F1aXNoVGV4dChlbHNbaV0pO1xuICB9XG59XG5cbi8qKlxuICogQGJyaWVmIFNob3cgb3IgaGlkZSBkeW5hbWljIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUR5bmFtaWNPcHRpb25zICgpIHtcbiAgaWYgKCQoJyNkeW5hbWljT3B0aW9ucycpLmhhc0NsYXNzKCd2aXNpYmxlJykpIHtcbiAgICAkKCcjZHluYW1pY09wdGlvbnMnKS5yZW1vdmVDbGFzcygndmlzaWJsZScpO1xuICB9IGVsc2Uge1xuICAgICQoJyNkeW5hbWljT3B0aW9ucycpLmFkZENsYXNzKCd2aXNpYmxlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYnJpZWYgU2hvdyBvciBoaWRlIGEgcGFydCBmcm9tIGEgc3BlY2lmaWMgdmVyc2UuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVBhcnQgKHZlcnNlLCBwYXJ0Q29sb3IpIHtcbiAgdmFyIHNlbGVjdG9yID0gJy5keW5hbWljIHN2ZyByZWN0W2ZpbGw9XCInICsgcGFydENvbG9yICsgJ1wiXSc7XG4gIGlmICh2ZXJzZSAhPT0gJ2FsbCcpIHtcbiAgICBzZWxlY3RvciA9ICcjdicgKyB2ZXJzZSArICcgJyArIHNlbGVjdG9yO1xuICB9XG4gICQoc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IENyZWF0ZSBDU1MgcnVsZSB0byB0b2dnbGUgd2l0aCBsZXNzIGxhdGVuY3kuXG4gICAgJCh0aGlzKS50b2dnbGUoKTtcbiAgfSk7XG59XG5cbndpbmRvdy5hdXRvc2V0Tm90ZXNQZXJMaW5lID0gYXV0b3NldE5vdGVzUGVyTGluZTtcbndpbmRvdy5zZXREaXNwbGF5ID0gc2V0RGlzcGxheTtcbndpbmRvdy5zZXRGb250U2l6ZSA9IHNldEZvbnRTaXplO1xud2luZG93LnNldE5vdGVzUGVyTGluZSA9IHNldE5vdGVzUGVyTGluZTtcbndpbmRvdy5zZXROb3RlSGVpZ2h0ID0gc2V0Tm90ZUhlaWdodDtcbndpbmRvdy5zZXROb3RlV2lkdGggPSBzZXROb3RlV2lkdGg7XG53aW5kb3cuc3dpdGNoVmVyc2UgPSBzd2l0Y2hWZXJzZTtcbndpbmRvdy50b2dnbGVEeW5hbWljT3B0aW9ucyA9IHRvZ2dsZUR5bmFtaWNPcHRpb25zO1xud2luZG93LnRvZ2dsZVBhcnQgPSB0b2dnbGVQYXJ0O1xuXG5mdW5jdGlvbiBhbHdheXNTaG93IChuYW1lKSB7XG4gIHN3aXRjaFZlcnNlKCdhbGwnLCBuYW1lLCBmYWxzZSk7XG59XG5cbi8qKlxuICogQGJyaWVmIENvdW50IHRoZSBudW1iZXIgb2YgdmVyc2VzIGluIHRoaXMgZHluYW1pYyBwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvdW50VmVyc2VzICgpIHtcbiAgLy8gR3JhYiB0aGUgZmlyc3QgU1ZHXG4gIHZhciBzdmdTZWxlY3RvciA9XG4gICAgJy5zbGlkZXMgPiBzZWN0aW9uOmZpcnN0LW9mLXR5cGUgPiBzZWN0aW9uOmZpcnN0LW9mLXR5cGUgLmR5bmFtaWMgc3ZnJztcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gc3ZnU2VsZWN0b3IgKyAnIFtkYXRhLXYnICsgaSArICddJztcbiAgICBpZiAoJChzZWxlY3RvcikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufVxuXG4vKipcbiAqIEBicmllZiBGaWxsIHRoZSBkeW5hbWljIG9wdGlvbnMgd2l0aCB0aGUgY29udHJvbHMgZm9yIHRoaXMgc29uZy5cbiAqL1xuZnVuY3Rpb24gZmlsbER5bmFtaWNPcHRpb25zICgpIHtcbiAgdmFyIG9wdGlvbiA9ICQoJzxkaXY+Jyk7XG4gIG9wdGlvbi5odG1sKCdBbGwgVmVyc2VzJyk7XG4gICQoJyNkeW5hbWljT3B0aW9ucyAudmlld3BvcnQtaW5uZXInKS5hcHBlbmQob3B0aW9uKTtcbiAgZ2V0RGlzcGxheVNldHRlcignYWxsJywgb3B0aW9uKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY291bnRWZXJzZXMoKTsgaSsrKSB7XG4gICAgb3B0aW9uID0gJCgnPGRpdj4nKTtcbiAgICAkKG9wdGlvbikuYWRkQ2xhc3MoJ3YnICsgaSk7XG4gICAgb3B0aW9uLmh0bWwoJ1ZlcnNlICcgKyBpKTtcbiAgICAkKCcjZHluYW1pY09wdGlvbnMgLnZpZXdwb3J0LWlubmVyJykuYXBwZW5kKG9wdGlvbik7XG4gICAgZ2V0RGlzcGxheVNldHRlcihpLCBvcHRpb24pO1xuICB9XG59XG5cbi8qKlxuICogQGJyaWVmIFJldHVybiB0aGUgY3VycmVudCBmb250IHNpemUgb2YgdGhlIGx5cmljcywgb3IgMCBpZiB0aGVyZSBhcmUgbm8gbHlyaWNzLlxuICovXG5mdW5jdGlvbiBnZXRGb250UGl4ZWxTaXplICgpIHtcbiAgLy8gVXNlIGEgZ2xvYmFsIHZhcmlhYmxlIHRvIGltcHJvdmUgc3BlZWQuXG4gIGlmICh0eXBlb2YgZm9udFBpeGVsU2l6ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc2l6ZSA9ICQoJy5keW5hbWljIHN2ZyB0ZXh0W2RhdGEtdjFdJykuYXR0cignZm9udC1zaXplJyk7XG4gICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9udFBpeGVsU2l6ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChzaXplLmluZGV4T2YoJ3B0JykgIT09IC0xKSB7XG4gICAgICBmb250UGl4ZWxTaXplID0gcGFyc2VGbG9hdChzaXplLnJlcGxhY2UoJ3B0JywgJycpKSAqICg0IC8gMyk7XG4gICAgfSBlbHNlIGlmIChzaXplLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICBmb250UGl4ZWxTaXplID0gcGFyc2VGbG9hdChzaXplLnJlcGxhY2UoJ3B4JywgJycpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvbnRQaXhlbFNpemU7XG59XG5cbi8qKlxuICogQGJyaWVmIFJldHVybiB0aGUgY3VycmVudCBwaXhlbCB2YWx1ZSBmb3IgdGhlIG5vdGUgaGVpZ2h0LlxuICovXG5mdW5jdGlvbiBnZXROb3RlSGVpZ2h0ICgpIHtcbiAgdmFyIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChcbiAgICAkKCcuZHluYW1pYyBzdmcgcmVjdFtkYXRhLWhlaWdodF0nKS5hdHRyKCdkYXRhLWhlaWdodCcpXG4gICk7XG4gIHZhciBudW1lcmF0b3IgPSBwYXJzZUludCgkKCcuZHluYW1pYyBzdmcgcmVjdFtkYXRhLWhlaWdodF0nKS5hdHRyKCdoZWlnaHQnKSk7XG4gIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbn1cbmZ1bmN0aW9uIGdldE5vdGVXaWR0aCAoKSB7XG4gIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoXG4gICAgJCgnLmR5bmFtaWMgc3ZnIHJlY3RbZGF0YS13aWR0aF0nKS5hdHRyKCdkYXRhLXdpZHRoJylcbiAgKTtcbiAgdmFyIG51bWVyYXRvciA9IHBhcnNlSW50KCQoJy5keW5hbWljIHN2ZyByZWN0W2RhdGEtd2lkdGhdJykuYXR0cignd2lkdGgnKSk7XG4gIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbn1cblxuLyoqXG4gKiBAYnJpZWYgR2V0IHRoZSBOdW1iZXIgb2Ygbm90ZXMgdGFsbCBhIHNwZWNpZmljIHN2ZyBzaG91bGQgYmUuXG4gKi9cbmZ1bmN0aW9uIGdldFNWR05vdGVSYW5nZSAoc3ZnKSB7XG4gIHZhciBwYXJ0cyA9ICQoc3ZnKS5maW5kKCcjcGFydHMgcmVjdCcpO1xuICB2YXIgbWF4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHRvZ2dsZVBhcnQgc2V0cyBkaXNwbGF5IHRvIG5vbmUuXG4gICAgaWYgKCQocGFydHNbaV0pLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciB0ZXN0ID1cbiAgICAgICAgcGFyc2VGbG9hdCgkKHBhcnRzW2ldKS5hdHRyKCdkYXRhLXknKSkgK1xuICAgICAgICBwYXJzZUZsb2F0KCQocGFydHNbaV0pLmF0dHIoJ2RhdGEtaGVpZ2h0JykpO1xuICAgICAgaWYgKHRlc3QgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdGVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cbmZ1bmN0aW9uIGdldFNWR1NvbmdMZW5ndGggKHN2Zykge1xuICByZXR1cm4gJChzdmcpLmF0dHIoJ2RhdGEtc29uZ2xlbmd0aCcpO1xufVxuXG4vKipcbiAqIEBicmllZiBBcHBlbmQgSFRNTCBmb3IgYSBzZXR0aW5nIHRvIGNoYW5nZSB0aGUgdmlldyBvZiBkaWZmZXJlbnQgdmVyc2VzLlxuICovXG5mdW5jdGlvbiBnZXREaXNwbGF5U2V0dGVyICh2ZXJzZSwgc2VjdGlvbikge1xuICB2YXIgY2hvaWNlcyA9IFsnbHlyaWNzJywgJ21lbG9keScsICdoYXJtb255J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidXR0b24gPSAkKCc8YnV0dG9uPicpO1xuICAgICQoYnV0dG9uKS5hdHRyKCd2YWx1ZScsIGNob2ljZXNbaV0pO1xuICAgICQoYnV0dG9uKS5hdHRyKFxuICAgICAgJ29uY2xpY2snLFxuICAgICAgJ3dpbmRvdy5zZXREaXNwbGF5KHRoaXMudmFsdWUsIFwiJyArIHZlcnNlICsgJ1wiKTsnXG4gICAgKTtcbiAgICAkKGJ1dHRvbikuaHRtbChjaG9pY2VzW2ldKTtcbiAgICAkKHNlY3Rpb24pLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbi8qKlxuICogQGJyaWVmIEhpZGUgYWxsIHBhcnRzIG9mIG11c2ljLlxuICogQHBhcmFtIHZlcnNlIGVpdGhlciAnYWxsJywgb3IgdGhlIHZlcnNlIG51bWJlciBmb3Igd2hpY2ggeW91IHdhbnQgdG8gaGlkZSBwYXJ0cy5cbiAqIEBwYXJhbSBtZXRob2Qgb3B0aW9uYWxseSBcInNob3dcIiB0byBzaG93IHBhcnRzIGluc3RlYWQgb2YgaGlkZSB0aGVtLlxuICovXG5mdW5jdGlvbiBoaWRlUGFydHMgKHZlcnNlLCBtZXRob2QgPSAnaGlkZScpIHtcbiAgdmFyIHNlbGVjdG9yID0gJy5keW5hbWljIHN2ZyByZWN0W2ZpbGxdJztcbiAgaWYgKHZlcnNlICE9PSAnYWxsJykge1xuICAgIHNlbGVjdG9yID0gJyN2JyArIHZlcnNlICsgJyAnICsgc2VsZWN0b3I7XG4gIH1cbiAgJChzZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETzogQ3JlYXRlIENTUyBydWxlIHRvIHNob3cvaGlkZSB3aXRoIGxlc3MgbGF0ZW5jeS5cbiAgICAkKHRoaXMpW21ldGhvZF0oKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGJyaWVmIFJlc2V0IFJldmVhbEpTIHNvIGl0IGRldGVjdHMgdGhlIGNoYW5nZXMgd2UndmUgbWFkZSB0byB0aGUgRE9NLlxuICovXG5mdW5jdGlvbiByZXNldFJldmVhbCAoKSB7XG4gIHZhciBpbmRpY2VzID0gd2luZG93LlJldmVhbC5nZXRJbmRpY2VzKCk7XG4gIHdpbmRvdy5SZXZlYWwuc2xpZGUoaW5kaWNlcy5oLCBpbmRpY2VzLnYpO1xufVxuXG4vKipcbiAqIEBicmllZiBSZXNpemUgYWxsIFNWR3MgYmFzZWQgb24gdGhlIGN1cnJlbnQgbm90ZSBoZWlnaHQgYW5kIGZvbnQgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gcmVzaXplU1ZHSGVpZ2h0ICgpIHtcbiAgdmFyIG5oID0gZ2V0Tm90ZUhlaWdodCgpO1xuICB2YXIgZnMgPSBnZXRGb250UGl4ZWxTaXplKCk7XG4gICQoJ3N2ZycpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3RlUmFuZ2UgPSBnZXRTVkdOb3RlUmFuZ2UodGhpcyk7XG4gICAgdmFyIGggPSBub3RlUmFuZ2UgKiBuaCArIGZzICogKDQgLyAzKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaCk7XG4gIH0pO1xuICBzZXRWaWV3Qm94ZXMoKTtcbiAgcmVzZXRSZXZlYWwoKTtcbn1cbi8qKlxuICogQGJyaWVmIFJlc2l6ZSBhbGwgU1ZHcyBiYXNlZCBvbiB0aGUgY3VycmVudCBub3RlIHdpZHRoLlxuICovXG5mdW5jdGlvbiByZXNpemVTVkdXaWR0aCAoKSB7XG4gIHZhciBudyA9IGdldE5vdGVXaWR0aCgpO1xuICAkKCdzdmcnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc29uZ0xlbmd0aCA9IGdldFNWR1NvbmdMZW5ndGgodGhpcyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc29uZ0xlbmd0aCAqIG53KTtcbiAgfSk7XG4gIHNldHVwUGFnZXMoKTtcbn1cblxuLyoqXG4gKiBAYnJpZWYgQ3JlYXRlIGRpZmZlcmVudCBwYWdlcyBmb3IgZWFjaCB2ZXJzZS4gRmlsbCB0aGVtIHdpdGggbXVsdGlwbGUgc3ZnIFwibGluZXNcIi5cbiAqICBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGEgbGl0dGxlIHNsb3cuIFdlIHNob3VsZCBvbmx5IHJ1biBpdCB3aGVuIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gc2V0dXBQYWdlcyAoKSB7XG4gIHZhciB1bm9yaWdpbmFsID0gJCgnLmR5bmFtaWM6bm90KC5vcmlnaW5hbCknKTtcbiAgLy8gRG8gdGhpcyBzeW5jcm9ub3VzbHkgc28gd2UgZG9uJ3QgaGF2ZSBhIHJhY2UgY29uZGl0aW9uIGZvciBpdGVtLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVub3JpZ2luYWwubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHVub3JpZ2luYWxbaV07XG4gICAgaWYgKGl0ZW0ucGFyZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGl0ZW0ucGFyZW50RWxlbWVudC5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgJCgnLmR5bmFtaWMub3JpZ2luYWwgc3ZnJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNsaWRlID0gJCh0aGlzKS5jbG9zZXN0KCdzZWN0aW9uJyk7XG5cbiAgICB2YXIgbnVtUGFnZXMgPSAwO1xuICAgIGlmICgkKHRoaXMpLmZpbmQoJyNicmVhdGhTZWN0aW9ucyByZWN0JykubGVuZ3RoID4gMSkge1xuICAgICAgbnVtUGFnZXMgPSAkKHRoaXMpLmZpbmQoJyNicmVhdGhTZWN0aW9ucyByZWN0JykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1QYWdlcyA9IE1hdGguY2VpbCgkKHRoaXMpLmF0dHIoJ3dpZHRoJykgLyByZXZlYWxXaWR0aCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGF0IDEgYmVjYXVzZSBwYWdlIDAgYWxyZWFkeSBleGlzdHMuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW1QYWdlczsgaSsrKSB7XG4gICAgICBpZiAoc2V0dXBQYWdlU2xpZGVJc0Z1bGwoc2xpZGUpKSB7XG4gICAgICAgIHNsaWRlID0gc2V0dXBQYWdlTmV3U2xpZGUoc2xpZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gJCgnPGRpdj4nKTtcbiAgICAgICQoY2hpbGQpLmFkZENsYXNzKCdkeW5hbWljJyk7XG4gICAgICAkKGNoaWxkKS5jc3MoJ29wYWNpdHknLCAwKTtcbiAgICAgICQoY2hpbGQpLmF0dHIoJ2RhdGEtcGFnZScsIGkpO1xuICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICQoY2hpbGQpLmFkZENsYXNzKCdvZGQnKTtcbiAgICAgIH1cbiAgICAgIHNsaWRlLmFwcGVuZChjaGlsZCk7XG4gICAgICAkKHNsaWRlKS5maW5kKCdbZGF0YS1wYWdlPVwiJyArIGkgKyAnXCJdJylbMF0uaW5uZXJIVE1MID0gdGhpcy5vdXRlckhUTUw7XG4gICAgfVxuICB9KTtcbiAgc2V0Vmlld0JveGVzKCk7XG4gIHJlc2V0UmV2ZWFsKCk7XG59XG5cbi8qKlxuICogQGJyaWVmIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IHNsaWRlIGFmdGVyIGN1cnJlbnRTbGlkZS5cbiAqL1xuZnVuY3Rpb24gc2V0dXBQYWdlTmV3U2xpZGUgKGN1cnJlbnRTbGlkZSkge1xuICB2YXIgc2xpZGVHcm91cCA9ICQoY3VycmVudFNsaWRlKS5jbG9zZXN0KCdzZWN0aW9uLnN0YWNrJyk7XG4gIHNsaWRlR3JvdXAuYXBwZW5kKCQoJzxzZWN0aW9uPicpKTtcbiAgcmV0dXJuIHNsaWRlR3JvdXAuZmluZCgnc2VjdGlvbjpsYXN0LW9mLXR5cGUnKTtcbn1cblxuLyoqXG4gKiBAYnJpZWYgcmV0dXJuIFRSVUUgaWYgc2xpZGUgY2Fubm90IGhvbGQgYW5vdGhlciBzdmcgXCJsaW5lXCIgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIHNldHVwUGFnZVNsaWRlSXNGdWxsIChzbGlkZSkge1xuICB2YXIgc3ZnSGVpZ2h0ID0gcGFyc2VJbnQoXG4gICAgJChzbGlkZSlcbiAgICAgIC5maW5kKCcuZHluYW1pYyBzdmcnKVxuICAgICAgLmF0dHIoJ2hlaWdodCcpXG4gICk7XG4gIC8vIFN1YnRyYWN0IGEgZmV3IHBpeGVscyBmcm9tIHJldmVhbEhlaWdodFxuICAvLyBzbyB0aGF0IHRoZXJlJ3MgYWx3YXlzIGF0IGxlYXN0IGEgbGl0dGxlIHNwYWNlIGJldHdlZW4gZWFjaCBsaW5lLlxuICB2YXIgY2FuSG9sZCA9IE1hdGguZmxvb3IoKHJldmVhbEhlaWdodCAtIDUwKSAvIHN2Z0hlaWdodCk7XG4gIHZhciBudW1iZXJPZkNoaWxkcmVuID0gJChzbGlkZSkuZmluZCgnLmR5bmFtaWMgc3ZnJykubGVuZ3RoO1xuICByZXR1cm4gbnVtYmVyT2ZDaGlsZHJlbiA+PSBjYW5Ib2xkO1xufVxuXG4vKipcbiAqIEBicmllZiBTZXQgdGhlIHZpZXcgYm94ZXMgZm9yIGVhY2ggc3ZnIFwibGluZVwiIHNvIHRoZXkgc3RhcnQgYXQgdGhlIGNvcnJlY3QgeCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2V0Vmlld0JveGVzICgpIHtcbiAgdmFyIHNlY3Rpb25zID0gJCgnLmR5bmFtaWMub3JpZ2luYWwgc3ZnOmZpcnN0ICNicmVhdGhTZWN0aW9ucyByZWN0Jyk7XG5cbiAgJCgnLmR5bmFtaWMgc3ZnJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBwYWdlTnVtID0gJCh0aGlzKVxuICAgICAgLmNsb3Nlc3QoJ1tkYXRhLXBhZ2VdJylcbiAgICAgIC5hdHRyKCdkYXRhLXBhZ2UnKTtcbiAgICBpZiAoc2VjdGlvbnMubGVuZ3RoID4gcGFnZU51bSAmJiAkKHNlY3Rpb25zW3BhZ2VOdW1dKS5hdHRyKCd3aWR0aCcpID4gMCkge1xuICAgICAgeCA9IHNlY3Rpb25zW3BhZ2VOdW1dLmF0dHJpYnV0ZXNbJ3gnXVsndmFsdWUnXTtcbiAgICAgICQodGhpcykuYXR0cignd2lkdGgnLCBzZWN0aW9uc1twYWdlTnVtXS5hdHRyaWJ1dGVzWyd3aWR0aCddWyd2YWx1ZSddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBhZ2VOdW0gKiByZXZlYWxXaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0ID0gJCh0aGlzKS5hdHRyKCdoZWlnaHQnKTtcbiAgICB2YXIgd2lkdGggPSAkKHRoaXMpLmF0dHIoJ3dpZHRoJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB4ICsgJyAwICcgKyB3aWR0aCArICcgJyArIGhlaWdodCk7XG4gIH0pO1xuICAkKCcuZHluYW1pYycpLmNzcygnb3BhY2l0eScsIDEpO1xufVxuXG4vKipcbiAqIEBicmllZiBTcXVpc2ggdGV4dCBzbyBpdCBkb2Vzbid0IGdvIGJleW9uZCB0aGUgYm91bmRhcmllcyBvZiBpdHMgYm94LlxuICogIEFsc28gcG9zc2libHkgcmVtb3ZlcyBoeXBlbnMgb3IgYWRkcyBub24tYnJlYWtpbmcgc3BhY2VzIHRvIHNxdWlzaGVkIHRleHQgZWxlbWVudHMuXG4gKiBAcGFyYW0gZWwgVGhlIGVsZW1lbnQgdGhhdCB5b3Ugd2FudCB0byBzcXVpc2ggdGhlIHRleHQgb24uXG4gKiBAcHJlY29uZGl0aW9uIFRoZSB0ZXh0IGluIHRoZSBlbGVtZW50IGVuZHMgd2l0aCBhIG5vbi1icmVha2luZyBzcGFjZSBpZiBpdCBpcyB0aGUgZW5kIG9mIGEgd29yZC5cbiAqL1xuZnVuY3Rpb24gc3F1aXNoVGV4dCAoZWwpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBoZXJlLCB3ZSBkb24ndCBoYXZlIHRvIGRvIGFueXRoaW5nLlxuICBpZiAodHlwZW9mIGVsLmNoaWxkTm9kZXNbMF0gPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIHZhciB0ZXh0ID0gZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG4gIC8vIFNldHRpbmcgYSBzcGVjaWZpYyBsZXR0ZXIgd2lkdGggaXNuJ3QgcGVyZmVjdCBzaW5jZSBcIk9uZVwiIGlzIHdpZGVyIHRoYW4gXCJseSxcIlxuICB2YXIgd2lkdGhQZXJMZXR0ZXIgPSBnZXRGb250UGl4ZWxTaXplKCkgKiAwLjc7XG4gIHZhciBib3hXaWR0aCA9ICQoZWwpLmF0dHIoJ2RhdGEtdGV4dGxlbmd0aCcpO1xuXG4gIC8vIEFkZCBhIGh5cGhlbiBpZiBpdCBkb2Vzbid0IGVuZCBpbiBhIGh5cGVuIG9yIGEgbm9uLWJyZWFraW5nIHNwYWNlLlxuICBpZiAoIXRleHQubWF0Y2goL1tcXHhBMC1dJC8pKSB7XG4gICAgdGV4dCArPSAnLSc7XG4gIH1cblxuICBpZiAodGV4dC5sZW5ndGggKiB3aWR0aFBlckxldHRlciA+PSBib3hXaWR0aCkge1xuICAgIC8vIEFwcGx5IHRoZSB0ZXh0TGVuZ3RoIGF0dHJpYnV0ZSBpZiB3ZSBuZWVkIHRvIHNxdWlzaCB0aGVzZSBsZXR0ZXJzLlxuICAgICQoZWwpLmF0dHIoJ3RleHRMZW5ndGgnLCBib3hXaWR0aCk7XG5cbiAgICAvLyBJZiB3ZSBuZWVkIHRvIHNxdWlzaCB0aGlzIGxldHRlciwgaXQncyBva2F5IHRvIHJlbW92ZSBhbnkgdHJhaWxpbmcgaHlwaGVucyxcbiAgICAvLyBhcyBsb25nIGFzIHJlbW92aW5nIHRob3NlIHdvbid0IHN0cmV0Y2ggdGhlIGxldHRlciBvdXQuXG4gICAgLy8gKHRoaXMgc3lsbGFibGUgaXMgdGhlIG1pZGRsZSBvZiBhIHdvcmQsIGJ1dCBpcyBzcXVpc2hlZCBhZ2FpbnN0IGl0cyBjb250aW51YXRpb24pXG4gICAgaWYgKCh0ZXh0Lmxlbmd0aCAtIDEpICogd2lkdGhQZXJMZXR0ZXIgPj0gYm94V2lkdGgpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLy0kLywgJycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAkKGVsKS5hdHRyKCd0ZXh0TGVuZ3RoJywgbnVsbCk7XG4gIH1cbiAgZWwuaW5uZXJIVE1MID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gdXJsUGFyYW0gKG5hbWUpIHtcbiAgdmFyIHJlc3VsdHMgPSBuZXcgUmVnRXhwKCdbPyZdJyArIG5hbWUgKyAnPShbXiYjXSopJykuZXhlYyhcbiAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG4gICk7XG5cbiAgcmV0dXJuIHJlc3VsdHMgIT09IG51bGwgPyByZXN1bHRzWzFdIHx8IDAgOiBmYWxzZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9qcy9keW5hbWljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n");

/***/ })

/******/ });